[
  {
    "head": "分布式通知",
    "relation": "实现方式",
    "tail": "ZooKeeper节点状态变化",
    "source_topic": "题目：分布式通知和协调"
  },
  {
    "head": "ZooKeeper",
    "relation": "功能",
    "tail": "通知和协调",
    "source_topic": "题目：分布式通知和协调"
  },
  {
    "head": "工作进程",
    "relation": "创建",
    "tail": "临时节点",
    "source_topic": "题目：分布式通知和协调"
  },
  {
    "head": "临时节点",
    "relation": "包含",
    "tail": "工作进度数据",
    "source_topic": "题目：分布式通知和协调"
  },
  {
    "head": "目录子节点",
    "relation": "监控",
    "tail": "工作进度变化",
    "source_topic": "题目：分布式通知和协调"
  },
  {
    "head": "ZooKeeper",
    "relation": "支持",
    "tail": "Watcher机制",
    "source_topic": "题目：分布式通知和协调"
  },
  {
    "head": "zk",
    "relation": "实现",
    "tail": "配置管理",
    "source_topic": "题目：zk的配置管理"
  },
  {
    "head": "配置管理",
    "relation": "利用",
    "tail": "watcher通知",
    "source_topic": "题目：zk的配置管理"
  },
  {
    "head": "配置管理",
    "relation": "通过",
    "tail": "znode发生变化",
    "source_topic": "题目：zk的配置管理"
  },
  {
    "head": "znode",
    "relation": "属于",
    "tail": "zk",
    "source_topic": "题目：zk的配置管理"
  },
  {
    "head": "Zookeeper",
    "relation": "采用",
    "tail": "写任意",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "写任意",
    "relation": "属于",
    "tail": "数据复制集群系统",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "写任意",
    "relation": "允许",
    "tail": "数据的修改提交给任意的节点",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "写任意",
    "relation": "与",
    "tail": "写主",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "写主",
    "relation": "属于",
    "tail": "数据复制集群系统",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "写主",
    "relation": "要求",
    "tail": "数据的修改提交给指定的节点",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "Zookeeper",
    "relation": "通过",
    "tail": "增加机器",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "增加机器",
    "relation": "提高",
    "tail": "读吞吐能力",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "增加机器",
    "relation": "提高",
    "tail": "响应能力",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "写任意",
    "relation": "导致",
    "tail": "写吞吐能力下降",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "Zookeeper",
    "relation": "建立",
    "tail": "Observer",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "Observer",
    "relation": "解决",
    "tail": "写吞吐能力下降",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "数据复制",
    "relation": "带来",
    "tail": "容错",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "数据复制",
    "relation": "带来",
    "tail": "提高系统的扩展能力",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "数据复制",
    "relation": "带来",
    "tail": "提高性能",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "写任意",
    "relation": "与",
    "tail": "读任意",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "Zookeeper",
    "relation": "实现",
    "tail": "延迟复制",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "Zookeeper",
    "relation": "实现",
    "tail": "立即复制",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "延迟复制",
    "relation": "保持",
    "tail": "最终一致性",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "立即复制",
    "relation": "实现",
    "tail": "快速响应",
    "source_topic": "题目：zk数据复制"
  },
  {
    "head": "Internet",
    "relation": "采用",
    "tail": "TCP/IP协议",
    "source_topic": "题目：Internet采用哪种网络协议？该协议的主要层次结构？"
  },
  {
    "head": "TCP/IP协议",
    "relation": "包含",
    "tail": "应用层",
    "source_topic": "题目：Internet采用哪种网络协议？该协议的主要层次结构？"
  },
  {
    "head": "TCP/IP协议",
    "relation": "包含",
    "tail": "传输层",
    "source_topic": "题目：Internet采用哪种网络协议？该协议的主要层次结构？"
  },
  {
    "head": "TCP/IP协议",
    "relation": "包含",
    "tail": "网络层",
    "source_topic": "题目：Internet采用哪种网络协议？该协议的主要层次结构？"
  },
  {
    "head": "TCP/IP协议",
    "relation": "包含",
    "tail": "数据链路层",
    "source_topic": "题目：Internet采用哪种网络协议？该协议的主要层次结构？"
  },
  {
    "head": "TCP/IP协议",
    "relation": "包含",
    "tail": "物理层",
    "source_topic": "题目：Internet采用哪种网络协议？该协议的主要层次结构？"
  },
  {
    "head": "ZooKeeper",
    "relation": "分配",
    "tail": "Session",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "用于标识",
    "tail": "客户端身份",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "作用",
    "tail": "客户端标识",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "作用",
    "tail": "超时检查",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "作用",
    "tail": "请求的顺序执行",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "作用",
    "tail": "维护临时节点的生命周期",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "作用",
    "tail": "watcher通知",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "状态",
    "tail": "CONNECTING",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "状态",
    "tail": "CONNECTED",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "状态",
    "tail": "RECONNECTING",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "状态",
    "tail": "RECONNECTED",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "状态",
    "tail": "CLOSED",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "属性",
    "tail": "SessionID",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "属性",
    "tail": "TimeOut",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "属性",
    "tail": "TickTime",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "Session",
    "relation": "属性",
    "tail": "isClosing",
    "source_topic": "题目：zk的session机制"
  },
  {
    "head": "判断两个链表是否相交",
    "relation": "解决",
    "tail": "两层遍历",
    "source_topic": "题目：如何判断两个链表是否相交"
  },
  {
    "head": "判断两个链表是否相交",
    "relation": "解决",
    "tail": "一层遍历",
    "source_topic": "题目：如何判断两个链表是否相交"
  },
  {
    "head": "一层遍历",
    "relation": "判断条件",
    "tail": "两个链表的最后一个结点指针相同",
    "source_topic": "题目：如何判断两个链表是否相交"
  },
  {
    "head": "两层遍历",
    "relation": "时间复杂度",
    "tail": "O(n^2)",
    "source_topic": "题目：如何判断两个链表是否相交"
  },
  {
    "head": "一层遍历",
    "relation": "时间复杂度",
    "tail": "O(n)",
    "source_topic": "题目：如何判断两个链表是否相交"
  },
  {
    "head": "IP地址",
    "relation": "包含",
    "tail": "网络号",
    "source_topic": "题目：IP地址的编码分为哪俩部分？"
  },
  {
    "head": "IP地址",
    "relation": "包含",
    "tail": "主机号",
    "source_topic": "题目：IP地址的编码分为哪俩部分？"
  },
  {
    "head": "IP地址",
    "relation": "需要与",
    "tail": "子网掩码",
    "source_topic": "题目：IP地址的编码分为哪俩部分？"
  },
  {
    "head": "子网掩码",
    "relation": "按位与",
    "tail": "IP地址",
    "source_topic": "题目：IP地址的编码分为哪俩部分？"
  },
  {
    "head": "MongoDB",
    "relation": "包含",
    "tail": "命名空间",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "属于",
    "tail": "数据库元数据",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "存储于",
    "tail": "*.ns文件",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "*.ns文件",
    "relation": "大小为",
    "tail": "16M",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "占用空间",
    "tail": "628字节",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "上限为",
    "tail": "24000",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "集合",
    "relation": "对应",
    "tail": "命名空间",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "索引",
    "relation": "对应",
    "tail": "命名空间",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间文件",
    "relation": "最大为",
    "tail": "2G",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "MongoDB",
    "relation": "支持",
    "tail": "启动参数--nssize",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "分配方式",
    "tail": "预分配空间",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "数据文件",
    "relation": "增长方式",
    "tail": "每次分配大小为上一次的2倍",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "盘区分配",
    "tail": "非连续",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "回收机制",
    "tail": "$freelist",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "$freelist",
    "relation": "记录",
    "tail": "不再使用的盘区",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "命名空间",
    "relation": "分配时",
    "tail": "优先使用$freelist",
    "source_topic": "题目：MongoDB中的命名空间是什么意思?"
  },
  {
    "head": "mongod",
    "relation": "包含",
    "tail": "数据库存储路径",
    "source_topic": "题目：\"mongod\"参数有什么"
  },
  {
    "head": "数据库存储路径",
    "relation": "默认值",
    "tail": "/data/db",
    "source_topic": "题目：\"mongod\"参数有什么"
  },
  {
    "head": "mongod",
    "relation": "包含",
    "tail": "端口号",
    "source_topic": "题目：\"mongod\"参数有什么"
  },
  {
    "head": "端口号",
    "relation": "默认值",
    "tail": "27017",
    "source_topic": "题目：\"mongod\"参数有什么"
  },
  {
    "head": "ZooKeeper",
    "relation": "支持",
    "tail": "名字服务",
    "source_topic": "题目：zookeeper有哪些应用场景"
  },
  {
    "head": "ZooKeeper",
    "relation": "支持",
    "tail": "配置管理",
    "source_topic": "题目：zookeeper有哪些应用场景"
  },
  {
    "head": "ZooKeeper",
    "relation": "支持",
    "tail": "集群管理",
    "source_topic": "题目：zookeeper有哪些应用场景"
  },
  {
    "head": "ZooKeeper",
    "relation": "支持",
    "tail": "分布式锁",
    "source_topic": "题目：zookeeper有哪些应用场景"
  },
  {
    "head": "ZooKeeper",
    "relation": "支持",
    "tail": "队列管理",
    "source_topic": "题目：zookeeper有哪些应用场景"
  },
  {
    "head": "ZooKeeper",
    "relation": "支持",
    "tail": "消息订阅",
    "source_topic": "题目：zookeeper有哪些应用场景"
  },
  {
    "head": "zk队列管理",
    "relation": "包含",
    "tail": "同步队列",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "zk队列管理",
    "relation": "包含",
    "tail": "FIFO队列",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "同步队列",
    "relation": "核心特性",
    "tail": "成员聚齐后队列才可用",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "同步队列",
    "relation": "实现方式",
    "tail": "创建临时目录节点并监听节点数目",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "FIFO队列",
    "relation": "核心特性",
    "tail": "按照先进先出方式入队和出队",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "znode",
    "relation": "用途",
    "tail": "消息存储",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "znode",
    "relation": "存储内容",
    "tail": "消息队列中的消息内容",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "SEQUENTIAL序列号",
    "relation": "用途",
    "tail": "消息的编号",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "持久化存储",
    "relation": "解决",
    "tail": "队列消息丢失问题",
    "source_topic": "题目：zk队列管理"
  },
  {
    "head": "实时系统",
    "relation": "核心特性",
    "tail": "实时性",
    "source_topic": "题目：描述实时系统的基本特性"
  },
  {
    "head": "实时系统",
    "relation": "核心特性",
    "tail": "可靠性",
    "source_topic": "题目：描述实时系统的基本特性"
  },
  {
    "head": "Redis",
    "relation": "包含",
    "tail": "数据淘汰策略",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "数据淘汰策略",
    "relation": "分类",
    "tail": "volatile-lru",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "数据淘汰策略",
    "relation": "分类",
    "tail": "volatile-ttl",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "数据淘汰策略",
    "relation": "分类",
    "tail": "volatile-random",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "数据淘汰策略",
    "relation": "分类",
    "tail": "allkeys-lru",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "数据淘汰策略",
    "relation": "分类",
    "tail": "allkeys-random",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "数据淘汰策略",
    "relation": "分类",
    "tail": "no-enviction",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "volatile-lru",
    "relation": "基于",
    "tail": "最近最少使用算法",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "volatile-ttl",
    "relation": "基于",
    "tail": "过期时间",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "volatile-random",
    "relation": "基于",
    "tail": "随机选择",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "allkeys-lru",
    "relation": "基于",
    "tail": "最近最少使用算法",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "allkeys-random",
    "relation": "基于",
    "tail": "随机选择",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "no-enviction",
    "relation": "特性",
    "tail": "禁止驱逐数据",
    "source_topic": "题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "架构简单",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "没有复杂的连接",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "深度查询能力",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "支持动态查询",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "容易调试",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "容易扩展",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "使用内部内存作为存储工作区",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "更快的存取数据",
    "source_topic": "题目：为什么用MOngoDB？"
  },
  {
    "head": "Redis",
    "relation": "适合",
    "tail": "in-memory场景",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "list数据结构",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "set数据结构",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "zset数据结构",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "hash数据结构",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "master-slave模式",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "数据持久化",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis持久化",
    "relation": "属于",
    "tail": "disk-backed功能",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Redis",
    "relation": "区别",
    "tail": "Memcached",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "Memcached",
    "relation": "属于",
    "tail": "简单k/v类型存储",
    "source_topic": "题目：redis 最适合的场景"
  },
  {
    "head": "sizeof(str)",
    "relation": "等于",
    "tail": "17",
    "source_topic": "题目：某32位系统下, C++程序，请计算sizeof 的值."
  },
  {
    "head": "MongoDB",
    "relation": "支持语言",
    "tail": "C++",
    "source_topic": "题目 ： 哪些语言支持MongoDB?"
  },
  {
    "head": "MongoDB",
    "relation": "支持语言",
    "tail": "C#",
    "source_topic": "题目 ： 哪些语言支持MongoDB?"
  },
  {
    "head": "MongoDB",
    "relation": "支持语言",
    "tail": "Java",
    "source_topic": "题目 ： 哪些语言支持MongoDB?"
  },
  {
    "head": "MongoDB",
    "relation": "支持语言",
    "tail": "Node.js",
    "source_topic": "题目 ： 哪些语言支持MongoDB?"
  },
  {
    "head": "MongoDB",
    "relation": "支持语言",
    "tail": "Perl",
    "source_topic": "题目 ： 哪些语言支持MongoDB?"
  },
  {
    "head": "MongoDB",
    "relation": "支持语言",
    "tail": "Php",
    "source_topic": "题目 ： 哪些语言支持MongoDB?"
  },
  {
    "head": "消息中间件",
    "relation": "实现",
    "tail": "发布者订阅者模式",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "发布者订阅者模式",
    "relation": "解决",
    "tail": "任务分配",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "master-slave部署",
    "relation": "包含",
    "tail": "master节点",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "master节点",
    "relation": "负责",
    "tail": "任务分配",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "集群",
    "relation": "包含",
    "tail": "节点",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "节点",
    "relation": "具有",
    "tail": "动态扩容缩容能力",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "消息中间件",
    "relation": "属于",
    "tail": "分布式架构",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "master-slave部署",
    "relation": "属于",
    "tail": "分布式架构",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "发布者订阅者模式",
    "relation": "属于",
    "tail": "消息传递机制",
    "source_topic": "题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！"
  },
  {
    "head": "触发器",
    "relation": "属于",
    "tail": "存储过程",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "触发器",
    "relation": "区别",
    "tail": "不能通过EXECUTE语句调用",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "存储过程",
    "relation": "区别",
    "tail": "可以通过存储过程名称直接调用",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "触发器",
    "relation": "触发条件",
    "tail": "修改指定表中的数据",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "触发器",
    "relation": "特性",
    "tail": "用户不能绕过触发器",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "触发器",
    "relation": "执行操作",
    "tail": "UPDATE",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "触发器",
    "relation": "执行操作",
    "tail": "INSERT",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "触发器",
    "relation": "执行操作",
    "tail": "DELETE",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "触发器",
    "relation": "执行环境",
    "tail": "SQLSERVER",
    "source_topic": "题目：存储过程与触发器的区别"
  },
  {
    "head": "数据库",
    "relation": "属于",
    "tail": "电子化的文件柜",
    "source_topic": "题目：什么是数据库"
  },
  {
    "head": "数据库",
    "relation": "包含",
    "tail": "数据操作",
    "source_topic": "题目：什么是数据库"
  },
  {
    "head": "数据操作",
    "relation": "包含",
    "tail": "新增",
    "source_topic": "题目：什么是数据库"
  },
  {
    "head": "数据操作",
    "relation": "包含",
    "tail": "检索",
    "source_topic": "题目：什么是数据库"
  },
  {
    "head": "数据操作",
    "relation": "包含",
    "tail": "更新",
    "source_topic": "题目：什么是数据库"
  },
  {
    "head": "数据库",
    "relation": "属于",
    "tail": "所有集合的容器",
    "source_topic": "题目：什么是数据库"
  },
  {
    "head": "数据库",
    "relation": "对应",
    "tail": "物理文件",
    "source_topic": "题目：什么是数据库"
  },
  {
    "head": "Key-Value 存储",
    "relation": "属于",
    "tail": "非关系型数据库类型",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "Amazon S3",
    "relation": "属于",
    "tail": "Key-Value 存储",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "图表",
    "relation": "属于",
    "tail": "非关系型数据库类型",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "Neo4J",
    "relation": "属于",
    "tail": "图表",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "文档存储",
    "relation": "属于",
    "tail": "非关系型数据库类型",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "MongoDB",
    "relation": "属于",
    "tail": "文档存储",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "基于列存储",
    "relation": "属于",
    "tail": "非关系型数据库类型",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "Cassandra",
    "relation": "属于",
    "tail": "基于列存储",
    "source_topic": "题目：非关系型数据库有哪些类型"
  },
  {
    "head": "ZooKeeper集群管理",
    "relation": "包含",
    "tail": "机器退出检测",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "ZooKeeper集群管理",
    "relation": "包含",
    "tail": "机器加入检测",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "ZooKeeper集群管理",
    "relation": "包含",
    "tail": "Master选举",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "机器退出检测",
    "relation": "实现方式",
    "tail": "临时目录节点",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "临时目录节点",
    "relation": "创建于",
    "tail": "父目录",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "机器退出检测",
    "relation": "依赖",
    "tail": "监听父目录节点的子节点变化消息",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "机器加入检测",
    "relation": "实现方式",
    "tail": "临时目录节点",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "机器加入检测",
    "relation": "依赖",
    "tail": "监听父目录节点的子节点变化消息",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "Master选举",
    "relation": "实现方式",
    "tail": "临时顺序编号目录节点",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "Master选举",
    "relation": "选取规则",
    "tail": "编号最小的机器作为Master",
    "source_topic": "题目：zookeeper集群管理"
  },
  {
    "head": "MongoDB",
    "relation": "使用",
    "tail": "use命令",
    "source_topic": "题目：在MongoDB中如何创建一个新的数据库"
  },
  {
    "head": "use命令",
    "relation": "功能",
    "tail": "创建数据库",
    "source_topic": "题目：在MongoDB中如何创建一个新的数据库"
  },
  {
    "head": "use命令",
    "relation": "行为",
    "tail": "切换到指定数据库",
    "source_topic": "题目：在MongoDB中如何创建一个新的数据库"
  },
  {
    "head": "use命令",
    "relation": "条件",
    "tail": "数据库不存在时创建",
    "source_topic": "题目：在MongoDB中如何创建一个新的数据库"
  },
  {
    "head": "质量保障",
    "relation": "包含",
    "tail": "代码开发",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "质量保障",
    "relation": "包含",
    "tail": "测试保障",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "质量保障",
    "relation": "包含",
    "tail": "线上质量",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "代码开发",
    "relation": "包含",
    "tail": "单元测试",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "代码开发",
    "relation": "包含",
    "tail": "代码Review",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "代码开发",
    "relation": "包含",
    "tail": "静态代码扫描",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "测试保障",
    "relation": "包含",
    "tail": "功能测试",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "测试保障",
    "relation": "包含",
    "tail": "性能测试",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "测试保障",
    "relation": "包含",
    "tail": "高可用测试",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "测试保障",
    "relation": "包含",
    "tail": "稳定性测试",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "测试保障",
    "relation": "包含",
    "tail": "兼容性测试",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "线上质量",
    "relation": "包含",
    "tail": "灰度发布",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "线上质量",
    "relation": "包含",
    "tail": "紧急回滚",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "线上质量",
    "relation": "包含",
    "tail": "故障演练",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "线上质量",
    "relation": "包含",
    "tail": "线上监控",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "线上质量",
    "relation": "包含",
    "tail": "巡检",
    "source_topic": "题目：假如给你一个新产品，你将从哪些方面来保障它的质量？"
  },
  {
    "head": "Redis同步机制",
    "relation": "包含",
    "tail": "主从同步",
    "source_topic": "题目：Redis的同步机制了解么？"
  },
  {
    "head": "主从同步",
    "relation": "包含",
    "tail": "bgsave",
    "source_topic": "题目：Redis的同步机制了解么？"
  },
  {
    "head": "主从同步",
    "relation": "包含",
    "tail": "内存buffer",
    "source_topic": "题目：Redis的同步机制了解么？"
  },
  {
    "head": "主从同步",
    "relation": "包含",
    "tail": "RDB文件全量同步",
    "source_topic": "题目：Redis的同步机制了解么？"
  },
  {
    "head": "主从同步",
    "relation": "包含",
    "tail": "RDB镜像加载到内存",
    "source_topic": "题目：Redis的同步机制了解么？"
  },
  {
    "head": "主从同步",
    "relation": "包含",
    "tail": "重放操作记录",
    "source_topic": "题目：Redis的同步机制了解么？"
  },
  {
    "head": "变量声明",
    "relation": "不分配",
    "tail": "存储空间",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量定义",
    "relation": "分配",
    "tail": "存储空间",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量声明",
    "relation": "允许",
    "tail": "多个地方",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量定义",
    "relation": "唯一",
    "tail": "一个地方",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "extern修饰符",
    "relation": "用于",
    "tail": "变量声明",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量声明",
    "relation": "可能延迟",
    "tail": "内存空间分配",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "外部变量",
    "relation": "属于",
    "tail": "变量声明",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "bool型数据",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句"
  },
  {
    "head": "int型数据",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句"
  },
  {
    "head": "指针变量",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句"
  },
  {
    "head": "float型数据",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句"
  },
  {
    "head": "int型数据",
    "relation": "最佳实践",
    "tail": "零值放在左边",
    "source_topic": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句"
  },
  {
    "head": "指针型数据",
    "relation": "最佳实践",
    "tail": "零值放在左边",
    "source_topic": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句"
  },
  {
    "head": "float型数据",
    "relation": "最佳实践",
    "tail": "使用范围比较",
    "source_topic": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "操作符",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "计算方式",
    "tail": "编译时计算",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "计算方式",
    "tail": "运行时计算",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "计算对象",
    "tail": "数据类型占内存的大小",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "计算对象",
    "tail": "字符串实际的长度",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "数组",
    "relation": "在sizeof中",
    "tail": "不退化",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "数组",
    "relation": "在strlen中",
    "tail": "退化为指针",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "参数类型",
    "tail": "数据类型或变量",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "参数类型",
    "tail": "以结尾为‘\\0’的字符串",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "容易混淆",
    "tail": "操作符",
    "source_topic": "sizeof 和 strlen 的区别"
  },
  {
    "head": "C语言",
    "relation": "使用",
    "tail": "static关键字",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "static关键字",
    "relation": "修饰",
    "tail": "局部静态变量",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "static关键字",
    "relation": "修饰",
    "tail": "外部静态变量",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "static关键字",
    "relation": "修饰",
    "tail": "静态函数",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "C++语言",
    "relation": "使用",
    "tail": "static关键字",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "static关键字",
    "relation": "定义",
    "tail": "静态成员变量",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "static关键字",
    "relation": "定义",
    "tail": "静态成员函数",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "static关键字",
    "relation": "具有",
    "tail": "记忆性",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "static关键字",
    "relation": "具有",
    "tail": "全局性",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "C语言static",
    "relation": "允许",
    "tail": "不同时期调用的函数通信",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "C++静态成员",
    "relation": "允许",
    "tail": "多个对象实例间通信",
    "source_topic": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++操作符",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++操作符",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C函数",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C函数",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "new",
    "relation": "可以重载",
    "tail": "C++",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "delete",
    "relation": "可以重载",
    "tail": "C++",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "malloc",
    "relation": "仅执行",
    "tail": "内存分配",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "free",
    "relation": "仅执行",
    "tail": "内存回收",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "new",
    "relation": "返回",
    "tail": "数据类型指针",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "malloc",
    "relation": "返回",
    "tail": "void指针",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "new",
    "relation": "需要释放",
    "tail": "delete",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "malloc",
    "relation": "需要释放",
    "tail": "free",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "new",
    "relation": "不能混用",
    "tail": "free",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "malloc",
    "relation": "不能混用",
    "tail": "delete",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "new",
    "relation": "实现机理不同",
    "tail": "malloc",
    "source_topic": "Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别"
  },
  {
    "head": "MIN宏",
    "relation": "定义实现",
    "tail": "三元表达式",
    "source_topic": "写一个“标准”宏 MIN"
  },
  {
    "head": "MIN宏",
    "relation": "潜在问题",
    "tail": "副作用",
    "source_topic": "写一个“标准”宏 MIN"
  },
  {
    "head": "副作用",
    "relation": "示例",
    "tail": "指针自加两次",
    "source_topic": "写一个“标准”宏 MIN"
  },
  {
    "head": "MIN宏",
    "relation": "使用注意事项",
    "tail": "避免表达式重复计算",
    "source_topic": "写一个“标准”宏 MIN"
  },
  {
    "head": "指针",
    "relation": "属于",
    "tail": "普通变量",
    "source_topic": "一个指针可以是 volatile 吗"
  },
  {
    "head": "指针",
    "relation": "保存数值类型",
    "tail": "整型数据",
    "source_topic": "一个指针可以是 volatile 吗"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "内存地址",
    "source_topic": "一个指针可以是 volatile 吗"
  },
  {
    "head": "volatile",
    "relation": "用于修饰",
    "tail": "指针",
    "source_topic": "一个指针可以是 volatile 吗"
  },
  {
    "head": "volatile",
    "relation": "解决",
    "tail": "程序不可控性变化",
    "source_topic": "一个指针可以是 volatile 吗"
  },
  {
    "head": "数组名a",
    "relation": "属于",
    "tail": "数组首地址",
    "source_topic": "a 和&a 有什么区别"
  },
  {
    "head": "&a",
    "relation": "属于",
    "tail": "数组指针",
    "source_topic": "a 和&a 有什么区别"
  },
  {
    "head": "*(a+1)",
    "relation": "访问",
    "tail": "数组a的第二个元素",
    "source_topic": "a 和&a 有什么区别"
  },
  {
    "head": "*(ptr-1)",
    "relation": "访问",
    "tail": "数组a的最后一个元素",
    "source_topic": "a 和&a 有什么区别"
  },
  {
    "head": "数组指针",
    "relation": "区别",
    "tail": "数组首地址",
    "source_topic": "a 和&a 有什么区别"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "静态存储区域分配",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "内存在程序编译时就已经分配好",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "内存在整个程序运行期间都存在",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "速度快",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "不容易出错",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "系统会善后",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "例子",
    "tail": "全局变量",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "例子",
    "tail": "static变量",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "栈上分配",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "效率很高",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "分配的内存容量有限",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "堆上分配",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "动态内存分配",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存的生存期由程序员决定",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "使用非常灵活",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "导致",
    "tail": "堆内碎块",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "栈区",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "全局区",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "文字常量区",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "C、C++程序编译",
    "relation": "包含",
    "tail": "程序代码区",
    "source_topic": "简述 C、C++程序编译的内存分配情况"
  },
  {
    "head": "strcpy",
    "relation": "操作对象",
    "tail": "字符串",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "sprintf",
    "relation": "操作对象",
    "tail": "多种数据类型",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "操作对象",
    "tail": "任意内存地址",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "strcpy",
    "relation": "实现功能",
    "tail": "字符串变量间的拷贝",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "sprintf",
    "relation": "实现功能",
    "tail": "其他数据类型格式到字符串的转化",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "实现功能",
    "tail": "内存块间的拷贝",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "strcpy",
    "relation": "执行效率",
    "tail": "次于memcpy",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "sprintf",
    "relation": "执行效率",
    "tail": "低于strcpy",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "执行效率",
    "tail": "最高",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "强制类型转换",
    "relation": "应用",
    "tail": "指针赋值",
    "source_topic": "设置地址为 0x67a9 的整型变量的值为 0xaa66"
  },
  {
    "head": "整型变量",
    "relation": "转换为",
    "tail": "指针类型",
    "source_topic": "设置地址为 0x67a9 的整型变量的值为 0xaa66"
  },
  {
    "head": "指针类型",
    "relation": "指向",
    "tail": "地址0x67a9",
    "source_topic": "设置地址为 0x67a9 的整型变量的值为 0xaa66"
  },
  {
    "head": "指针赋值",
    "relation": "操作",
    "tail": "设置内存地址值",
    "source_topic": "设置地址为 0x67a9 的整型变量的值为 0xaa66"
  },
  {
    "head": "设置内存地址值",
    "relation": "使用",
    "tail": "解引用操作符",
    "source_topic": "设置地址为 0x67a9 的整型变量的值为 0xaa66"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "封装性",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "继承性",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "多态性",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "封装性",
    "relation": "保护机制",
    "tail": "private",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "封装性",
    "relation": "保护机制",
    "tail": "protected",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "封装性",
    "relation": "保护机制",
    "tail": "public",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "继承性",
    "relation": "实现形式",
    "tail": "实现继承",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "继承性",
    "relation": "实现形式",
    "tail": "可视继承",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "继承性",
    "relation": "实现形式",
    "tail": "接口继承",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "多态性",
    "relation": "技术原理",
    "tail": "虚函数",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "多态性",
    "relation": "相关概念",
    "tail": "静态多态",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "多态性",
    "relation": "相关概念",
    "tail": "动态多态",
    "source_topic": "面向对象的三大特征"
  },
  {
    "head": "C++空类",
    "relation": "包含",
    "tail": "缺省构造函数",
    "source_topic": "C++的空类有哪些成员函数"
  },
  {
    "head": "C++空类",
    "relation": "包含",
    "tail": "缺省拷贝构造函数",
    "source_topic": "C++的空类有哪些成员函数"
  },
  {
    "head": "C++空类",
    "relation": "包含",
    "tail": "缺省析构函数",
    "source_topic": "C++的空类有哪些成员函数"
  },
  {
    "head": "C++空类",
    "relation": "包含",
    "tail": "缺省赋值运算符",
    "source_topic": "C++的空类有哪些成员函数"
  },
  {
    "head": "C++空类",
    "relation": "包含",
    "tail": "缺省取址运算符",
    "source_topic": "C++的空类有哪些成员函数"
  },
  {
    "head": "C++空类",
    "relation": "包含",
    "tail": "缺省取址运算符 const",
    "source_topic": "C++的空类有哪些成员函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "生成",
    "tail": "新的类对象",
    "source_topic": "谈谈你对拷贝构造函数和赋值运算符的认识"
  },
  {
    "head": "赋值运算符",
    "relation": "不能生成",
    "tail": "新的类对象",
    "source_topic": "谈谈你对拷贝构造函数和赋值运算符的认识"
  },
  {
    "head": "拷贝构造函数",
    "relation": "不需要检验",
    "tail": "源对象是否和新建对象相同",
    "source_topic": "谈谈你对拷贝构造函数和赋值运算符的认识"
  },
  {
    "head": "赋值运算符",
    "relation": "需要检验",
    "tail": "源对象是否和新建对象相同",
    "source_topic": "谈谈你对拷贝构造函数和赋值运算符的认识"
  },
  {
    "head": "赋值运算符",
    "relation": "需要释放",
    "tail": "原来的对象中的内存分配",
    "source_topic": "谈谈你对拷贝构造函数和赋值运算符的认识"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "私有构造函数",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "私有构造函数",
    "relation": "作用",
    "tail": "防止类被继承",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "构造函数调用",
    "relation": "顺序",
    "tail": "父类构造函数先于子类构造函数",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "虚拟继承",
    "relation": "实现方式",
    "tail": "避免菱形继承问题",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "友元",
    "relation": "作用",
    "tail": "允许模板参数访问类的私有成员",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "类B",
    "relation": "继承",
    "tail": "类A",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "类C",
    "relation": "继承",
    "tail": "类B",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "main函数",
    "relation": "执行",
    "tail": "创建类B对象",
    "source_topic": "用 C++设计一个不能被继承的类"
  },
  {
    "head": "虚函数表",
    "relation": "包含",
    "tail": "虚函数指针",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "虚函数表",
    "relation": "包含",
    "tail": "函数地址",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "B类对象",
    "relation": "继承",
    "tail": "A类",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "A类",
    "relation": "定义",
    "tail": "私有虚函数f",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "A类",
    "relation": "定义",
    "tail": "虚函数g",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "B类",
    "relation": "重写",
    "tail": "虚函数g",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "B类",
    "relation": "定义",
    "tail": "虚函数h",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "指针强制类型转换",
    "relation": "实现",
    "tail": "访问虚函数表",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "虚函数调用",
    "relation": "基于",
    "tail": "虚函数表",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "私有虚函数",
    "relation": "限制",
    "tail": "外部直接访问",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "虚函数表",
    "relation": "解决",
    "tail": "多态性实现",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "虚函数表",
    "relation": "属于",
    "tail": "C++面向对象机制",
    "source_topic": "访问基类的私有虚函数"
  },
  {
    "head": "类成员函数重写",
    "relation": "范围区别",
    "tail": "两个类中",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "类成员函数重载",
    "relation": "范围区别",
    "tail": "同一个类中",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "类成员函数重写",
    "relation": "参数区别",
    "tail": "参数列表一定相同",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "类成员函数重载",
    "relation": "参数区别",
    "tail": "参数列表一定不同",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "类成员函数隐藏",
    "relation": "范围区别",
    "tail": "不在同一个类中",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "类成员函数隐藏",
    "relation": "参数区别",
    "tail": "参数列表可以相同也可以不同",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "类成员函数隐藏",
    "relation": "函数名区别",
    "tail": "函数名相同",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "覆盖",
    "relation": "实现技术",
    "tail": "动态绑定的多态",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "重载",
    "relation": "实现技术",
    "tail": "静态绑定的多态",
    "source_topic": "简述类成员函数的重写、重载和隐藏的区别"
  },
  {
    "head": "C++多态",
    "relation": "实现原理",
    "tail": "动态联编",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "虚函数",
    "relation": "触发生成",
    "tail": "虚函数表(vtable)",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "虚函数表(vtable)",
    "relation": "包含",
    "tail": "指向对应虚函数的指针",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "编译器",
    "relation": "隐含插入",
    "tail": "vptr指针",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "vptr指针",
    "relation": "指向",
    "tail": "虚函数表(vtable)",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "vptr指针",
    "relation": "关联",
    "tail": "对应的vtable",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "this指针",
    "relation": "指向",
    "tail": "具体的类",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "this指针",
    "relation": "获取",
    "tail": "正确的vtable",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "虚函数",
    "relation": "区别",
    "tail": "纯虚函数",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "虚函数",
    "relation": "区别",
    "tail": "虚拟继承",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "虚函数",
    "relation": "属于",
    "tail": "多态实现的基础",
    "source_topic": "简述多态实现的原理"
  },
  {
    "head": "数组",
    "relation": "存储形式",
    "tail": "连续空间",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "链表",
    "relation": "存储形式",
    "tail": "不连续动态空间",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "数组",
    "relation": "需要确定",
    "tail": "长度",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "链表结点",
    "relation": "保存",
    "tail": "相邻结点指针",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "数组",
    "relation": "查找方式",
    "tail": "线性查找",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "链表",
    "relation": "查找方式",
    "tail": "顺序检索结点",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "链表",
    "relation": "插入删除操作",
    "tail": "快速",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "数组",
    "relation": "插入删除操作",
    "tail": "需要大量数据移动",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "数组",
    "relation": "存在",
    "tail": "越界问题",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "链表",
    "relation": "不存在",
    "tail": "越界问题",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "数组",
    "relation": "核心特性",
    "tail": "节省空间",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "长度可变",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "占用更多存储空间",
    "source_topic": "链表和数组有什么区别"
  },
  {
    "head": "单链表",
    "relation": "处理方式",
    "tail": "循环算法",
    "source_topic": "怎样把一个单链表反序"
  },
  {
    "head": "单链表",
    "relation": "处理方式",
    "tail": "递归算法",
    "source_topic": "怎样把一个单链表反序"
  },
  {
    "head": "循环算法",
    "relation": "属于",
    "tail": "链表反转算法",
    "source_topic": "怎样把一个单链表反序"
  },
  {
    "head": "递归算法",
    "relation": "属于",
    "tail": "链表反转算法",
    "source_topic": "怎样把一个单链表反序"
  },
  {
    "head": "循环算法",
    "relation": "设计特点",
    "tail": "移动过程",
    "source_topic": "怎样把一个单链表反序"
  },
  {
    "head": "递归算法",
    "relation": "设计特点",
    "tail": "递归处理剩余链表",
    "source_topic": "怎样把一个单链表反序"
  },
  {
    "head": "队列",
    "relation": "操作方式",
    "tail": "先进先出",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "栈区",
    "relation": "操作方式",
    "tail": "后进先出",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "堆区",
    "relation": "操作方式",
    "tail": "顺序随意",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "栈区",
    "relation": "分配释放方式",
    "tail": "编译器自动分配释放",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "堆区",
    "relation": "分配释放方式",
    "tail": "程序员分配释放",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "栈区",
    "relation": "存储内容",
    "tail": "函数的参数值",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "栈区",
    "relation": "存储内容",
    "tail": "局部变量的值",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "堆区",
    "relation": "回收机制",
    "tail": "程序结束时可能由OS回收",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "堆区",
    "relation": "分配方式",
    "tail": "类似于链表",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "队列",
    "relation": "属于",
    "tail": "线性存储结构",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "堆栈",
    "relation": "属于",
    "tail": "数据结构",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "堆区",
    "relation": "属于",
    "tail": "程序内存存储区域",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "栈区",
    "relation": "属于",
    "tail": "程序内存存储区域",
    "source_topic": "简述队列和栈的异同"
  },
  {
    "head": "双栈",
    "relation": "实现",
    "tail": "队列",
    "source_topic": "能否用两个栈实现一个队列的功能"
  },
  {
    "head": "队列",
    "relation": "核心特性",
    "tail": "先进先出",
    "source_topic": "能否用两个栈实现一个队列的功能"
  },
  {
    "head": "双栈实现队列",
    "relation": "技术原理",
    "tail": "先进后出与先进先出的组合",
    "source_topic": "能否用两个栈实现一个队列的功能"
  },
  {
    "head": "二叉树深度计算",
    "relation": "实现方式",
    "tail": "递归算法",
    "source_topic": "计算一颗二叉树的深度"
  },
  {
    "head": "递归算法",
    "relation": "适用场景",
    "tail": "二叉树结构",
    "source_topic": "计算一颗二叉树的深度"
  },
  {
    "head": "直接插入排序",
    "relation": "使用",
    "tail": "哨兵",
    "source_topic": "编码实现直接插入排序"
  },
  {
    "head": "哨兵",
    "relation": "作用",
    "tail": "简化边界条件",
    "source_topic": "编码实现直接插入排序"
  },
  {
    "head": "哨兵",
    "relation": "导致",
    "tail": "查找循环条件时间减少约一半",
    "source_topic": "编码实现直接插入排序"
  },
  {
    "head": "直接插入排序",
    "relation": "属于",
    "tail": "排序算法",
    "source_topic": "编码实现直接插入排序"
  },
  {
    "head": "哨兵",
    "relation": "属于",
    "tail": "附加结点",
    "source_topic": "编码实现直接插入排序"
  },
  {
    "head": "直接选择排序",
    "relation": "属于",
    "tail": "排序算法",
    "source_topic": "编码实现直接选择排序"
  },
  {
    "head": "直接选择排序",
    "relation": "核心特性",
    "tail": "不稳定性",
    "source_topic": "编码实现直接选择排序"
  },
  {
    "head": "直接选择排序",
    "relation": "导致",
    "tail": "相同关键码的对象颠倒次序",
    "source_topic": "编码实现直接选择排序"
  },
  {
    "head": "直接选择排序",
    "relation": "适用场景",
    "tail": "简单整形数组排序",
    "source_topic": "编码实现直接选择排序"
  },
  {
    "head": "直接选择排序",
    "relation": "弱点",
    "tail": "不保证稳定性",
    "source_topic": "编码实现直接选择排序"
  },
  {
    "head": "堆排序",
    "relation": "属于",
    "tail": "排序算法",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "堆排序",
    "relation": "包含",
    "tail": "创建大根堆",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "堆排序",
    "relation": "包含",
    "tail": "交换元素",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "堆排序",
    "relation": "包含",
    "tail": "重新调整大根堆",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "createHeep",
    "relation": "用于",
    "tail": "生成大根堆",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "heepSort",
    "relation": "用于",
    "tail": "堆排序",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "大根堆",
    "relation": "核心特性",
    "tail": "最大值位于根节点",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "堆排序",
    "relation": "解决",
    "tail": "数组排序问题",
    "source_topic": "编程实现堆排序"
  },
  {
    "head": "编程规范",
    "relation": "包含",
    "tail": "可行性",
    "source_topic": "谈谈你对编程规范的理解或认识"
  },
  {
    "head": "编程规范",
    "relation": "包含",
    "tail": "可读性",
    "source_topic": "谈谈你对编程规范的理解或认识"
  },
  {
    "head": "编程规范",
    "relation": "包含",
    "tail": "可移植性",
    "source_topic": "谈谈你对编程规范的理解或认识"
  },
  {
    "head": "编程规范",
    "relation": "包含",
    "tail": "可测试性",
    "source_topic": "谈谈你对编程规范的理解或认识"
  },
  {
    "head": "short",
    "relation": "转换要求",
    "tail": "强制类型转换",
    "source_topic": "short i = 0; i = i + 1L；这两句有错吗"
  },
  {
    "head": "long",
    "relation": "转换要求",
    "tail": "强制类型转换",
    "source_topic": "short i = 0; i = i + 1L；这两句有错吗"
  },
  {
    "head": "Java",
    "relation": "类型转换规则",
    "tail": "强制类型转换",
    "source_topic": "short i = 0; i = i + 1L；这两句有错吗"
  },
  {
    "head": "&&",
    "relation": "逻辑判断方式",
    "tail": "短路逻辑",
    "source_topic": "&&和&、||和|有什么区别"
  },
  {
    "head": "||",
    "relation": "逻辑判断方式",
    "tail": "短路逻辑",
    "source_topic": "&&和&、||和|有什么区别"
  },
  {
    "head": "&&",
    "relation": "与",
    "tail": "逻辑与运算符",
    "source_topic": "&&和&、||和|有什么区别"
  },
  {
    "head": "||",
    "relation": "与",
    "tail": "逻辑或运算符",
    "source_topic": "&&和&、||和|有什么区别"
  },
  {
    "head": "C++引用",
    "relation": "必须初始化",
    "tail": "C语言指针",
    "source_topic": "C++的引用和 C 语言的指针有什么区别"
  },
  {
    "head": "C++引用",
    "relation": "不分配存储空间",
    "tail": "C语言指针",
    "source_topic": "C++的引用和 C 语言的指针有什么区别"
  },
  {
    "head": "C语言指针",
    "relation": "可以改变所指对象",
    "tail": "C++引用",
    "source_topic": "C++的引用和 C 语言的指针有什么区别"
  },
  {
    "head": "C++引用",
    "relation": "不存在指向空值",
    "tail": "C语言指针",
    "source_topic": "C++的引用和 C 语言的指针有什么区别"
  },
  {
    "head": "C++引用",
    "relation": "作为函数参数",
    "tail": "可能引发错误",
    "source_topic": "C++的引用和 C 语言的指针有什么区别"
  },
  {
    "head": "C语言指针",
    "relation": "作为函数参数",
    "tail": "可能引发错误",
    "source_topic": "C++的引用和 C 语言的指针有什么区别"
  },
  {
    "head": "find_path",
    "relation": "调用",
    "tail": "push_path",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "find_path",
    "relation": "调用",
    "tail": "print_path",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "find_path",
    "relation": "调用",
    "tail": "pop_path",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "push_path",
    "relation": "操作",
    "tail": "PATH链表",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "pop_path",
    "relation": "操作",
    "tail": "PATH链表",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "IsLeaf",
    "relation": "判断",
    "tail": "二元树结点是否为叶子结点",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "PATH",
    "relation": "包含",
    "tail": "BiTNode* tree",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "find_path",
    "relation": "处理",
    "tail": "二元树路径查找",
    "source_topic": "在二元树中找出和为某一值的所有路径"
  },
  {
    "head": "MIN宏",
    "relation": "定义",
    "tail": "比较两个参数并返回较小的一个",
    "source_topic": "写一个“标准”宏 MIN"
  },
  {
    "head": "MIN宏",
    "relation": "潜在问题",
    "tail": "副作用",
    "source_topic": "写一个“标准”宏 MIN"
  },
  {
    "head": "typedef",
    "relation": "用法不同",
    "tail": "定义数据类型的别名",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "define",
    "relation": "用法不同",
    "tail": "定义常量和书写复杂使用频繁的宏",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "typedef",
    "relation": "执行时间不同",
    "tail": "编译过程的一部分，有类型检查",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "typedef",
    "relation": "作用域不同",
    "tail": "有作用域限定",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "define",
    "relation": "作用域不同",
    "tail": "不受作用域约束",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "typedef",
    "relation": "对指针的操作不同",
    "tail": "定义指针时有类型检查",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "typedef",
    "relation": "语法特性",
    "tail": "定义是语句，句尾需要加分号",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "define",
    "relation": "语法特性",
    "tail": "不是语句，句尾不能加分号",
    "source_topic": "typedef 和 define 有什么区别"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "只读变量或对象",
    "source_topic": "关键字 const 是什么"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "便于类型检查",
    "source_topic": "关键字 const 是什么"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "可方便地进行参数修改和调整",
    "source_topic": "关键字 const 是什么"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "节省空间，避免不必要的内存分配",
    "source_topic": "关键字 const 是什么"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "可为函数重载提供参考",
    "source_topic": "关键字 const 是什么"
  },
  {
    "head": "const",
    "relation": "编程规范",
    "tail": "函数参数不可被改变",
    "source_topic": "关键字 const 是什么"
  },
  {
    "head": "const",
    "relation": "编程规范",
    "tail": "成员函数不可修改成员变量",
    "source_topic": "关键字 const 是什么"
  },
  {
    "head": "static",
    "relation": "定义",
    "tail": "全局静态变量",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "static",
    "relation": "定义",
    "tail": "局部静态变量",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "static",
    "relation": "定义",
    "tail": "静态函数",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "static",
    "relation": "新增定义",
    "tail": "静态数据成员",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "static",
    "relation": "新增定义",
    "tail": "静态函数成员",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "静态区",
    "relation": "分配",
    "tail": "static定义的变量",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "普通变量",
    "relation": "默认值",
    "tail": "随机数",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "static定义的指针变量",
    "relation": "注意事项",
    "tail": "默认值为0",
    "source_topic": "static 有什么作用"
  },
  {
    "head": "extern",
    "relation": "声明作用",
    "tail": "变量或函数定义在别的文件中",
    "source_topic": "extern 有什么作用"
  },
  {
    "head": "extern",
    "relation": "提示编译器",
    "tail": "在其它模块中寻找其定义",
    "source_topic": "extern 有什么作用"
  },
  {
    "head": "流操作符重载",
    "relation": "返回引用原因",
    "tail": "支持连续使用流操作符",
    "source_topic": "流操作符重载为什么返回引用"
  },
  {
    "head": "流操作符重载",
    "relation": "返回引用原因",
    "tail": "返回流引用以保持操作连续性",
    "source_topic": "流操作符重载为什么返回引用"
  },
  {
    "head": "流操作符",
    "relation": "返回类型",
    "tail": "引用",
    "source_topic": "流操作符重载为什么返回引用"
  },
  {
    "head": "算术操作符",
    "relation": "不能返回引用原因",
    "tail": "操作符的对象是右值",
    "source_topic": "流操作符重载为什么返回引用"
  },
  {
    "head": "算术操作符",
    "relation": "不能返回引用原因",
    "tail": "必须构造一个对象作为返回值",
    "source_topic": "流操作符重载为什么返回引用"
  },
  {
    "head": "指针常量",
    "relation": "核心特性",
    "tail": "指针的值不可改变",
    "source_topic": "简述指针常量与常量指针区别"
  },
  {
    "head": "常量指针",
    "relation": "核心特性",
    "tail": "指针对其所指对象的值不可改变",
    "source_topic": "简述指针常量与常量指针区别"
  },
  {
    "head": "指针常量",
    "relation": "用途",
    "tail": "作为函数的形式参数",
    "source_topic": "简述指针常量与常量指针区别"
  },
  {
    "head": "常量指针",
    "relation": "用途",
    "tail": "作为函数的形式参数",
    "source_topic": "简述指针常量与常量指针区别"
  },
  {
    "head": "指针常量",
    "relation": "区别",
    "tail": "常量指针",
    "source_topic": "简述指针常量与常量指针区别"
  },
  {
    "head": "指针常量",
    "relation": "强调",
    "tail": "指针的不可改变性",
    "source_topic": "简述指针常量与常量指针区别"
  },
  {
    "head": "常量指针",
    "relation": "强调",
    "tail": "指针对其所指对象的不可改变性",
    "source_topic": "简述指针常量与常量指针区别"
  },
  {
    "head": "数组名",
    "relation": "区别",
    "tail": "指针",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "操作符",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "数组名",
    "relation": "失去含义",
    "tail": "函数参数传递",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "数组名",
    "relation": "变作",
    "tail": "普通指针",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "数组名",
    "relation": "内涵更丰富",
    "tail": "指针",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "char str[13]",
    "relation": "大小",
    "tail": "13",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "strlen(str)",
    "relation": "返回值",
    "tail": "12",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "strlen(pStr)",
    "relation": "返回值",
    "tail": "12",
    "source_topic": "数组名和指针的区别"
  },
  {
    "head": "野指针",
    "relation": "产生原因",
    "tail": "指针变量声明时没有被初始化",
    "source_topic": "如何避免“野指针”"
  },
  {
    "head": "野指针",
    "relation": "产生原因",
    "tail": "指针操作超越变量的作用范围",
    "source_topic": "如何避免“野指针”"
  },
  {
    "head": "指针变量声明时没有被初始化",
    "relation": "解决办法",
    "tail": "指针声明时初始化",
    "source_topic": "如何避免“野指针”"
  },
  {
    "head": "野指针",
    "relation": "解决方法",
    "tail": "编程规范基本原则",
    "source_topic": "如何避免“野指针”"
  },
  {
    "head": "野指针",
    "relation": "解决方法",
    "tail": "使用前检验指针合法性",
    "source_topic": "如何避免“野指针”"
  },
  {
    "head": "常引用",
    "relation": "作用",
    "tail": "避免变量的值被意外修改",
    "source_topic": "常引用有什么作用"
  },
  {
    "head": "常引用",
    "relation": "应用场景",
    "tail": "定义普通变量的只读属性的别名",
    "source_topic": "常引用有什么作用"
  },
  {
    "head": "常引用",
    "relation": "应用场景",
    "tail": "作为函数的传入形参",
    "source_topic": "常引用有什么作用"
  },
  {
    "head": "常引用",
    "relation": "特性",
    "tail": "被引用对象等效于常对象",
    "source_topic": "常引用有什么作用"
  },
  {
    "head": "常引用",
    "relation": "优势",
    "tail": "提高代码易读性",
    "source_topic": "常引用有什么作用"
  },
  {
    "head": "常引用",
    "relation": "优势",
    "tail": "降低出错率",
    "source_topic": "常引用有什么作用"
  },
  {
    "head": "myAtoi",
    "relation": "实现",
    "tail": "字符串转化为数字",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "属于",
    "tail": "C++函数",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "使用",
    "tail": "pow函数",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "处理",
    "tail": "十进制字符串",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "包含",
    "tail": "负号检测逻辑",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "包含",
    "tail": "字符到数值转换",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "包含",
    "tail": "非数字字符过滤",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "包含",
    "tail": "前导零过滤",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "myAtoi",
    "relation": "返回",
    "tail": "整型数值",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "pow函数",
    "relation": "属于",
    "tail": "C++标准库",
    "source_topic": "编码实现字符串转化为数字"
  },
  {
    "head": "strcpy",
    "relation": "操作对象",
    "tail": "字符串",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "sprintf",
    "relation": "操作对象",
    "tail": "多种数据类型",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "操作对象",
    "tail": "任意内存地址",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "strcpy",
    "relation": "实现功能",
    "tail": "字符串变量间的拷贝",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "sprintf",
    "relation": "实现功能",
    "tail": "其他数据类型格式到字符串的转化",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "实现功能",
    "tail": "内存块间的拷贝",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "strcpy",
    "relation": "执行效率",
    "tail": "次于memcpy",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "sprintf",
    "relation": "执行效率",
    "tail": "低于strcpy",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "执行效率",
    "tail": "最高",
    "source_topic": "简述 strcpy、sprintf 与 memcpy 的区别"
  },
  {
    "head": "死循环程序",
    "relation": "实现方式",
    "tail": "while(1)循环",
    "source_topic": "用 C 编写一个死循环程序"
  },
  {
    "head": "BIT3",
    "relation": "定义",
    "tail": "0x1 << 3",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "位操作",
    "relation": "实现方式",
    "tail": "按位或运算",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "位操作",
    "relation": "实现方式",
    "tail": "按位与非运算",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "按位或运算",
    "relation": "作用",
    "tail": "设置变量的某一位为1",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "按位与非运算",
    "relation": "作用",
    "tail": "清除变量的某一位为0",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "位操作",
    "relation": "注意事项",
    "tail": "保持其他位不变",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "按位或运算",
    "relation": "应用场景",
    "tail": "设置变量的bit3",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "按位与非运算",
    "relation": "应用场景",
    "tail": "清除变量的bit3",
    "source_topic": "编码实现某一变量某位清 0 或置 1"
  },
  {
    "head": "ISR",
    "relation": "不建议使用",
    "tail": "浮点运算",
    "source_topic": "评论下面这个中断函数"
  },
  {
    "head": "printf",
    "relation": "存在",
    "tail": "重入问题",
    "source_topic": "评论下面这个中断函数"
  },
  {
    "head": "printf",
    "relation": "存在",
    "tail": "性能问题",
    "source_topic": "评论下面这个中断函数"
  },
  {
    "head": "__interrupt",
    "relation": "用于定义",
    "tail": "中断服务子程序",
    "source_topic": "评论下面这个中断函数"
  },
  {
    "head": "中断服务子程序",
    "relation": "属于",
    "tail": "嵌入式系统",
    "source_topic": "评论下面这个中断函数"
  },
  {
    "head": "中断服务子程序",
    "relation": "包含",
    "tail": "计算逻辑",
    "source_topic": "评论下面这个中断函数"
  },
  {
    "head": "中断服务子程序",
    "relation": "包含",
    "tail": "输出操作",
    "source_topic": "评论下面这个中断函数"
  },
  {
    "head": "构造函数",
    "relation": "不能是",
    "tail": "虚函数",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "构造函数",
    "relation": "不能调用",
    "tail": "虚函数",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "析构函数",
    "relation": "可以是",
    "tail": "虚函数",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "析构函数",
    "relation": "可以是",
    "tail": "纯虚函数",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "纯虚析构函数",
    "relation": "必须有",
    "tail": "定义体",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "虚函数",
    "relation": "实现",
    "tail": "动态绑定特性",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "动态绑定",
    "relation": "基于",
    "tail": "虚函数表",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "虚函数",
    "relation": "核心特性",
    "tail": "重载",
    "source_topic": "构造函数能否为虚函数"
  },
  {
    "head": "面向对象编程技术",
    "relation": "属于",
    "tail": "面向对象技术",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象技术",
    "relation": "包含",
    "tail": "面向对象分析",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象技术",
    "relation": "包含",
    "tail": "面向对象设计",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象技术",
    "relation": "包含",
    "tail": "面向对象编程",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象分析",
    "relation": "解决",
    "tail": "程序复杂性问题",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象设计",
    "relation": "解决",
    "tail": "程序结构不清晰问题",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象编程",
    "relation": "解决",
    "tail": "程序冗余问题",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "传统程序设计",
    "relation": "基于",
    "tail": "功能思想",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象程序设计",
    "relation": "基于",
    "tail": "对象角度",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "面向对象程序设计",
    "relation": "导致",
    "tail": "程序简洁清晰",
    "source_topic": "谈谈你对面向对象的认识"
  },
  {
    "head": "构造",
    "relation": "属于",
    "tail": "C++性能优化技巧",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "析构",
    "relation": "属于",
    "tail": "C++性能优化技巧",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "返回值优化",
    "relation": "属于",
    "tail": "C++性能优化技巧",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "临时对象",
    "relation": "消除方式",
    "tail": "operator=()",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "内联",
    "relation": "属于",
    "tail": "C++性能优化技巧",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "内联技巧",
    "relation": "属于",
    "tail": "内联",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "条件内联",
    "relation": "属于",
    "tail": "内联",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "递归内联",
    "relation": "属于",
    "tail": "内联",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "静态局部变量内联",
    "relation": "属于",
    "tail": "内联",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "内存池",
    "relation": "属于",
    "tail": "C++性能优化技巧",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "函数对象",
    "relation": "优于",
    "tail": "函数指针",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "编译器优化",
    "relation": "属于",
    "tail": "编码优化",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "预先计算",
    "relation": "属于",
    "tail": "编码优化",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "延迟计算",
    "relation": "属于",
    "tail": "设计优化",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "高效数据结构",
    "relation": "属于",
    "tail": "设计优化",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "寄存器",
    "relation": "影响",
    "tail": "系统体系结构优化",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "缓存",
    "relation": "影响",
    "tail": "系统体系结构优化",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "上下文切换",
    "relation": "影响",
    "tail": "系统体系结构优化",
    "source_topic": "提高c++性能，你用过哪些方式去提升"
  },
  {
    "head": "引用",
    "relation": "属于",
    "tail": "变量的别名",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "指针",
    "relation": "属于",
    "tail": "实体",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "==NULL",
    "relation": "不支持",
    "tail": "引用",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "引用",
    "relation": "底层实现",
    "tail": "指针",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "引用",
    "relation": "访问方式",
    "tail": "直接访问",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "指针",
    "relation": "访问方式",
    "tail": "间接访问",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "指针",
    "relation": "自增运算",
    "tail": "指向下一个空间",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "引用",
    "relation": "自增运算",
    "tail": "引用的变量值加1",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "返回",
    "tail": "引用的变量大小",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "返回",
    "tail": "指针本身的大小",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "传指针",
    "relation": "实质",
    "tail": "传值",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "传引用",
    "relation": "实质",
    "tail": "传地址",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "传指针",
    "relation": "传递的值",
    "tail": "指针的地址",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "传引用",
    "relation": "传递的值",
    "tail": "变量的地址",
    "source_topic": "引用和指针的区别？"
  },
  {
    "head": "引用",
    "relation": "底层实现",
    "tail": "指针",
    "source_topic": "从汇编层去解释一下引用"
  },
  {
    "head": "lea eax,[ebp-4]",
    "relation": "作用",
    "tail": "将x的地址存入eax寄存器",
    "source_topic": "从汇编层去解释一下引用"
  },
  {
    "head": "变量b",
    "relation": "存储内容",
    "tail": "x的地址",
    "source_topic": "从汇编层去解释一下引用"
  },
  {
    "head": "栈内存分配",
    "relation": "方向",
    "tail": "从高往低",
    "source_topic": "从汇编层去解释一下引用"
  },
  {
    "head": "变量x",
    "relation": "内存地址",
    "tail": "ebp-4",
    "source_topic": "从汇编层去解释一下引用"
  },
  {
    "head": "变量b",
    "relation": "内存地址",
    "tail": "ebp-8",
    "source_topic": "从汇编层去解释一下引用"
  },
  {
    "head": "指针参数传递",
    "relation": "本质是",
    "tail": "值传递",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针参数传递",
    "relation": "传递",
    "tail": "地址值",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针参数传递",
    "relation": "形成",
    "tail": "实参副本",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针参数传递",
    "relation": "操作",
    "tail": "局部变量",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针参数传递",
    "relation": "不会影响",
    "tail": "主调函数实参变量",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "引用参数传递",
    "relation": "操作",
    "tail": "间接寻址",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "引用参数传递",
    "relation": "访问",
    "tail": "主调函数实参变量",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "引用参数传递",
    "relation": "影响",
    "tail": "主调函数实参变量",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "引用参数传递",
    "relation": "与",
    "tail": "指针传递不同",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "引用参数传递",
    "relation": "使用",
    "tail": "实参变量地址",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针参数传递",
    "relation": "改变",
    "tail": "指针地址",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针参数传递",
    "relation": "无法应用到",
    "tail": "主调函数相关变量",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针参数传递",
    "relation": "解决",
    "tail": "使用指向指针的指针或指针引用",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "引用",
    "relation": "在符号表中记录",
    "tail": "引用对象地址",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针变量",
    "relation": "在符号表中记录",
    "tail": "指针变量地址",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "引用对象",
    "relation": "不能修改",
    "tail": "引用对象地址",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "指针变量",
    "relation": "可以修改",
    "tail": "指针变量地址",
    "source_topic": "C++中的指针参数传递和引用参数传递"
  },
  {
    "head": "形参",
    "relation": "作用范围",
    "tail": "函数内部",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "可以是",
    "tail": "常量",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "可以是",
    "tail": "表达式",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "必须具有",
    "tail": "确定的值",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "形参",
    "relation": "数据传送方向",
    "tail": "单向",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "数据传送方向",
    "tail": "单向",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "形参",
    "relation": "内存分配时机",
    "tail": "被调用时分配",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "形参",
    "relation": "内存释放时机",
    "tail": "调用结束时释放",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "数据传递方式",
    "tail": "值传递",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "数据传递方式",
    "tail": "指针传递",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "数据传递方式",
    "tail": "引用传递",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "值传递",
    "relation": "特点",
    "tail": "拷贝数据",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "指针传递",
    "relation": "特点",
    "tail": "拷贝地址值",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "引用传递",
    "relation": "特点",
    "tail": "传递地址别名",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "指针传递",
    "relation": "效率",
    "tail": "比值传递高",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "引用传递",
    "relation": "效率",
    "tail": "比值传递高",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "引用传递",
    "relation": "优势",
    "tail": "代码逻辑紧凑",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "引用传递",
    "relation": "优势",
    "tail": "代码逻辑清晰",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "形参",
    "relation": "与实参区别",
    "tail": "内存位置不同",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "实参",
    "relation": "与形参区别",
    "tail": "内容不会改变",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "形参",
    "relation": "与实参区别",
    "tail": "调用结束后被释放",
    "source_topic": "形参与实参的区别？"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "隐藏",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static函数",
    "relation": "作用",
    "tail": "隐藏",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static变量",
    "relation": "作用",
    "tail": "隐藏",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static变量",
    "relation": "保持",
    "tail": "变量内容的持久",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static变量",
    "relation": "存储位置",
    "tail": "静态数据区",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "静态数据区",
    "relation": "初始化时机",
    "tail": "程序刚开始运行时",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "静态数据区",
    "relation": "初始化次数",
    "tail": "唯一的一次初始化",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "静态数据区",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static全局变量",
    "relation": "可见范围",
    "tail": "模块内",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static函数",
    "relation": "可见范围",
    "tail": "模块内",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static类成员变量",
    "relation": "归属",
    "tail": "整个类",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static类成员变量",
    "relation": "初始化位置",
    "tail": "类外",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static类成员函数",
    "relation": "归属",
    "tail": "整个类",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static类成员函数",
    "relation": "参数",
    "tail": "没有this指针",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static类成员函数",
    "relation": "访问限制",
    "tail": "只能访问static成员变量",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static类成员函数",
    "relation": "不能被修饰",
    "tail": "virtual",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "vptr指针",
    "relation": "调用方式",
    "tail": "通过this指针调用",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static类成员函数",
    "relation": "无法访问",
    "tail": "非static类成员",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static变量",
    "relation": "作用范围",
    "tail": "函数体内",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static变量",
    "relation": "内存分配次数",
    "tail": "一次",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "static变量",
    "relation": "值维持",
    "tail": "下次调用时仍维持上次的值",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "auto变量",
    "relation": "作用范围",
    "tail": "函数体内",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "auto变量",
    "relation": "内存分配次数",
    "tail": "每次调用都重新分配",
    "source_topic": "static的用法和作用？"
  },
  {
    "head": "静态变量",
    "relation": "初始化时机",
    "tail": "主程序之前",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "静态变量",
    "relation": "内存分配时机",
    "tail": "编译阶段",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "静态局部变量",
    "relation": "存储区域",
    "tail": "全局区域",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "静态变量",
    "relation": "初始化次数",
    "tail": "只有一次",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "静态变量",
    "relation": "赋值次数",
    "tail": "可以多次",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "C语言",
    "relation": "静态局部变量初始化时机",
    "tail": "代码执行之前",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "C语言",
    "relation": "静态局部变量初始化限制",
    "tail": "无法使用变量初始化",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "C++语言",
    "relation": "静态局部变量初始化时机",
    "tail": "首次用到时",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "C++语言",
    "relation": "静态局部变量初始化方式",
    "tail": "执行构造函数",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "C++语言",
    "relation": "静态局部变量析构顺序",
    "tail": "程序结束时按构造顺序反方向",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "C++语言",
    "relation": "静态局部变量析构管理",
    "tail": "atexit()",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "静态局部变量",
    "relation": "初始化支持",
    "tail": "允许使用变量初始化",
    "source_topic": "静态变量什么时候初始化"
  },
  {
    "head": "const",
    "relation": "阻止",
    "tail": "变量被改变",
    "source_topic": "const?"
  },
  {
    "head": "const变量",
    "relation": "需要",
    "tail": "初始化",
    "source_topic": "const?"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "指针本身",
    "source_topic": "const?"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "指针所指的数据",
    "source_topic": "const?"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数形参",
    "source_topic": "const?"
  },
  {
    "head": "const成员函数",
    "relation": "表明",
    "tail": "输入参数",
    "source_topic": "const?"
  },
  {
    "head": "const成员函数",
    "relation": "不能修改",
    "tail": "类的成员变量",
    "source_topic": "const?"
  },
  {
    "head": "const对象",
    "relation": "只能访问",
    "tail": "类的常成员函数",
    "source_topic": "const?"
  },
  {
    "head": "const成员函数",
    "relation": "可以访问",
    "tail": "const对象内的所有数据成员",
    "source_topic": "const?"
  },
  {
    "head": "非const成员函数",
    "relation": "不能访问",
    "tail": "const对象的任意数据成员",
    "source_topic": "const?"
  },
  {
    "head": "非const成员函数",
    "relation": "被看作是",
    "tail": "将要修改对象中数据成员的函数",
    "source_topic": "const?"
  },
  {
    "head": "const对象",
    "relation": "不允许调用",
    "tail": "非const成员函数",
    "source_topic": "const?"
  },
  {
    "head": "const类型变量",
    "relation": "必须",
    "tail": "定义时初始化",
    "source_topic": "const?"
  },
  {
    "head": "类的成员变量",
    "relation": "必须初始化",
    "tail": "在类的初始化列表中",
    "source_topic": "const?"
  },
  {
    "head": "引用传递",
    "relation": "可以使用",
    "tail": "const重载",
    "source_topic": "const?"
  },
  {
    "head": "指针传递",
    "relation": "可以使用",
    "tail": "const重载",
    "source_topic": "const?"
  },
  {
    "head": "值传递",
    "relation": "不影响",
    "tail": "实参",
    "source_topic": "const?"
  },
  {
    "head": "const成员函数",
    "relation": "保证",
    "tail": "不修改调用它的对象",
    "source_topic": "const成员函数的理解和应用？"
  },
  {
    "head": "const成员函数",
    "relation": "允许",
    "tail": "const对象调用",
    "source_topic": "const成员函数的理解和应用？"
  },
  {
    "head": "const参数",
    "relation": "保证",
    "tail": "不修改传递的参数",
    "source_topic": "const成员函数的理解和应用？"
  },
  {
    "head": "const返回类型",
    "relation": "确保",
    "tail": "返回的Stock对象不能被修改",
    "source_topic": "const成员函数的理解和应用？"
  },
  {
    "head": "const",
    "relation": "修饰对象",
    "tail": "指针",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "const",
    "relation": "修饰对象",
    "tail": "指针的值",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "int const p2",
    "relation": "表示",
    "tail": "顶层指针",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "顶层指针",
    "relation": "含义",
    "tail": "指针本身是一个常量",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "int const p2",
    "relation": "限制",
    "tail": "p2的值不可改变",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "int const p2",
    "relation": "允许",
    "tail": "通过p2读写变量的值",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "const int p1",
    "relation": "表示",
    "tail": "底层指针",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "底层指针",
    "relation": "含义",
    "tail": "指针所指向的变量是一个常量",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "const int p1",
    "relation": "限制",
    "tail": "不能通过*p1改变变量的值",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "const int p1",
    "relation": "允许",
    "tail": "改变指针的指向",
    "source_topic": "指针和const的用法"
  },
  {
    "head": "mutable",
    "relation": "属于",
    "tail": "C++关键字",
    "source_topic": "mutable"
  },
  {
    "head": "mutable",
    "relation": "特性",
    "tail": "不受const成员方法的限制",
    "source_topic": "mutable"
  },
  {
    "head": "mutable",
    "relation": "定义",
    "tail": "类的辅助状态",
    "source_topic": "mutable"
  },
  {
    "head": "mutable",
    "relation": "影响",
    "tail": "对象的状态本身未改变",
    "source_topic": "mutable"
  },
  {
    "head": "const_cast",
    "relation": "影响",
    "tail": "mutable概念的实用性降低",
    "source_topic": "mutable"
  },
  {
    "head": "extern",
    "relation": "修饰",
    "tail": "变量的声明",
    "source_topic": "extern用法？"
  },
  {
    "head": "extern",
    "relation": "修饰",
    "tail": "函数的声明",
    "source_topic": "extern用法？"
  },
  {
    "head": "extern",
    "relation": "用于",
    "tail": "跨文件引用变量",
    "source_topic": "extern用法？"
  },
  {
    "head": "extern",
    "relation": "用于",
    "tail": "跨文件引用函数",
    "source_topic": "extern用法？"
  },
  {
    "head": "extern \"C\"",
    "relation": "用于",
    "tail": "C++调用C库函数",
    "source_topic": "extern用法？"
  },
  {
    "head": "extern \"C\"",
    "relation": "解决",
    "tail": "C++与C命名规则不同问题",
    "source_topic": "extern用法？"
  },
  {
    "head": "std::to_string",
    "relation": "属于",
    "tail": "C++11标准",
    "source_topic": "int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？"
  },
  {
    "head": "std::stoi",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？"
  },
  {
    "head": "std::stol",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？"
  },
  {
    "head": "std::stoll",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？"
  },
  {
    "head": "strcpy",
    "relation": "包含",
    "tail": "返回值",
    "source_topic": "int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？"
  },
  {
    "head": "strcpy",
    "relation": "设计目的",
    "tail": "支持链式表达",
    "source_topic": "int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？"
  },
  {
    "head": "浅拷贝",
    "relation": "问题",
    "tail": "出现野指针和运行错误",
    "source_topic": "深拷贝与浅拷贝？"
  },
  {
    "head": "位拷贝",
    "relation": "等同于",
    "tail": "浅拷贝",
    "source_topic": "深拷贝与浅拷贝？"
  },
  {
    "head": "堆内存",
    "relation": "动态开辟",
    "tail": "类内成员变量",
    "source_topic": "深拷贝与浅拷贝？"
  },
  {
    "head": "析构",
    "relation": "导致",
    "tail": "释放堆内存",
    "source_topic": "深拷贝与浅拷贝？"
  },
  {
    "head": "野指针",
    "relation": "出现原因",
    "tail": "浅拷贝后原对象释放堆内存",
    "source_topic": "深拷贝与浅拷贝？"
  },
  {
    "head": "C++模板",
    "relation": "底层实现",
    "tail": "实例化",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "C++模板",
    "relation": "需要",
    "tail": "具体类型",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "C++模板",
    "relation": "编译过程",
    "tail": "两次编译",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "C++模板",
    "relation": "第一次编译",
    "tail": "声明处编译模板代码",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "C++模板",
    "relation": "第二次编译",
    "tail": "调用处编译参数替换后的代码",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "函数模板",
    "relation": "需要",
    "tail": "实例化后成为真正的函数",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "函数模板",
    "relation": "导致",
    "tail": "链接错误",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "函数模板",
    "relation": "解决方式",
    "tail": "在使用源文件中包含定义",
    "source_topic": "C++模板是什么，底层怎么实现的？"
  },
  {
    "head": "C语言struct",
    "relation": "属于",
    "tail": "用户自定义数据类型（UDT）",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C++struct",
    "relation": "属于",
    "tail": "抽象数据类型（ADT）",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C++struct",
    "relation": "支持",
    "tail": "成员函数的定义",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C语言struct",
    "relation": "不支持",
    "tail": "访问权限设置",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C语言struct",
    "relation": "仅包含",
    "tail": "变量的集合体",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C语言struct",
    "relation": "不支持",
    "tail": "封装数据并隐藏数据",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C语言struct",
    "relation": "不支持",
    "tail": "成员为函数",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C++struct",
    "relation": "默认访问说明符",
    "tail": "public",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C++class",
    "relation": "默认访问说明符",
    "tail": "private",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C++struct",
    "relation": "增加",
    "tail": "访问权限",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C++struct",
    "relation": "可以拥有",
    "tail": "成员函数",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C++struct",
    "relation": "作为类的特例",
    "tail": "自定义数据结构",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "C语言struct",
    "relation": "使用时需要",
    "tail": "结构标记前加上struct",
    "source_topic": "C语言struct和C++struct区别"
  },
  {
    "head": "虚函数",
    "relation": "用于实现",
    "tail": "运行时多态",
    "source_topic": "虚函数可以声明为inline吗?"
  },
  {
    "head": "虚函数",
    "relation": "要求",
    "tail": "运行时类型确定",
    "source_topic": "虚函数可以声明为inline吗?"
  },
  {
    "head": "内联函数",
    "relation": "要求",
    "tail": "编译期完成函数替换",
    "source_topic": "虚函数可以声明为inline吗?"
  },
  {
    "head": "类成员初始化",
    "relation": "分类",
    "tail": "赋值初始化",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "类成员初始化",
    "relation": "分类",
    "tail": "列表初始化",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "赋值初始化",
    "relation": "执行时机",
    "tail": "在构造函数体内进行初始化",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "列表初始化",
    "relation": "优势",
    "tail": "减少临时对象的创建",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "虚拟基类构造函数",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "基类构造函数",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "类类型成员对象构造函数",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "派生类自己的构造函数",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "赋值操作",
    "relation": "导致",
    "tail": "临时对象的创建",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "列表初始化",
    "relation": "解决",
    "tail": "临时对象的创建",
    "source_topic": "类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"
  },
  {
    "head": "成员列表初始化",
    "relation": "属于",
    "tail": "C++构造函数",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "成员列表初始化",
    "relation": "应用情况",
    "tail": "引用成员初始化",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "成员列表初始化",
    "relation": "应用情况",
    "tail": "常量成员初始化",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "成员列表初始化",
    "relation": "应用情况",
    "tail": "基类构造函数调用",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "成员列表初始化",
    "relation": "应用情况",
    "tail": "成员类构造函数调用",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "成员初始化列表",
    "relation": "执行操作",
    "tail": "编译器安插初始化操作",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "成员初始化列表",
    "relation": "执行顺序",
    "tail": "由类中成员声明顺序决定",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "成员初始化列表",
    "relation": "执行顺序",
    "tail": "不依赖初始化列表顺序",
    "source_topic": "成员列表初始化？"
  },
  {
    "head": "构造函数",
    "relation": "不能为",
    "tail": "虚函数",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "应为",
    "tail": "虚函数",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "原因",
    "tail": "防止内存泄漏",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "虚函数",
    "relation": "用于",
    "tail": "动态绑定",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "vtable",
    "relation": "存储",
    "tail": "对象内存空间",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "vtable",
    "relation": "建立",
    "tail": "构造函数调用后",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "构造函数",
    "relation": "初始化",
    "tail": "VPTR",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "VPTR",
    "relation": "指向",
    "tail": "VTABLE",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "属于",
    "tail": "C++语言特性",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "内存泄漏",
    "relation": "导致",
    "tail": "未释放派生类申请的内存空间",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "基类析构函数",
    "relation": "应为",
    "tail": "虚析构函数",
    "source_topic": "构造函数为什么不能为虚函数？析构函数为什么要虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "作用相反",
    "tail": "构造函数",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "析构函数",
    "relation": "用于",
    "tail": "撤销对象的一些特殊任务处理",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "析构函数",
    "relation": "可以是",
    "tail": "释放对象分配的内存空间",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "没有参数，也没有返回值",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "不能重载",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "在一个类中只能有一个",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "析构函数",
    "relation": "调用时机",
    "tail": "当撤销对象时，编译器自动调用",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "析构函数",
    "relation": "定义为",
    "tail": "类的公有成员",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "构造函数",
    "relation": "作用",
    "tail": "初始化值",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "构造函数",
    "relation": "调用时机",
    "tail": "实例化对象时，系统自动回调用",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "构造函数",
    "relation": "参数传递",
    "tail": "可以通过实例传递参数到其他函数",
    "source_topic": "析构函数的作用，如何起作用？"
  },
  {
    "head": "构造函数",
    "relation": "不使用",
    "tail": "动态联编",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "析构函数",
    "relation": "不使用",
    "tail": "动态联编",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "构造函数",
    "relation": "调用",
    "tail": "为自身类型定义的虚函数版本",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "析构函数",
    "relation": "调用",
    "tail": "为自身类型定义的虚函数版本",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "父类对象",
    "relation": "在子类之前构造",
    "tail": "构造函数",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "子类数据成员",
    "relation": "未初始化",
    "tail": "构造函数",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "析构函数",
    "relation": "先调用",
    "tail": "子类的析构函数",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "析构函数",
    "relation": "后调用",
    "tail": "基类的析构函数",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "子类数据成员",
    "relation": "已销毁",
    "tail": "基类析构函数调用时",
    "source_topic": "构造函数和析构函数可以调用虚函数吗，为什么？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "基类构造函数",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "成员类对象构造函数",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "派生类构造函数",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "析构函数",
    "relation": "执行顺序",
    "tail": "派生类析构函数",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "析构函数",
    "relation": "执行顺序",
    "tail": "成员类对象析构函数",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "析构函数",
    "relation": "执行顺序",
    "tail": "基类析构函数",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "构造函数",
    "relation": "内部功能",
    "tail": "初始化对象成员",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "功能",
    "tail": "复制已有对象的成员初始化新对象",
    "source_topic": "构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"
  },
  {
    "head": "虚析构函数",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "基类析构函数",
    "relation": "应设置为",
    "tail": "虚函数",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "非虚析构函数",
    "relation": "导致",
    "tail": "派生类析构函数未被调用",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "动态绑定",
    "relation": "未被触发",
    "tail": "基类指针删除派生类对象",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "纯虚析构函数",
    "relation": "必须定义",
    "tail": "链接失败",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "构造函数",
    "relation": "不建议调用",
    "tail": "虚函数",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "不建议调用",
    "tail": "虚函数",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "构造函数或析构函数调用虚函数",
    "relation": "导致",
    "tail": "不可控的运行结果",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "虚函数动态绑定",
    "relation": "不发挥",
    "tail": "构造函数或析构函数中调用虚函数",
    "source_topic": "虚析构函数的作用，父类的析构函数是否要设置为虚函数？"
  },
  {
    "head": "构造函数",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "构造函数析构函数可否抛出异常"
  },
  {
    "head": "析构函数",
    "relation": "执行不全",
    "tail": "未完成应执行的任务",
    "source_topic": "构造函数析构函数可否抛出异常"
  },
  {
    "head": "C++",
    "relation": "处理",
    "tail": "异常在析构函数中抛出",
    "source_topic": "构造函数析构函数可否抛出异常"
  },
  {
    "head": "C++",
    "relation": "调用",
    "tail": "terminate函数",
    "source_topic": "构造函数析构函数可否抛出异常"
  },
  {
    "head": "auto_ptr",
    "relation": "解决",
    "tail": "构造函数异常导致的资源泄漏",
    "source_topic": "构造函数析构函数可否抛出异常"
  },
  {
    "head": "析构函数",
    "relation": "不会被调用",
    "tail": "构造函数抛出异常",
    "source_topic": "构造函数析构函数可否抛出异常"
  },
  {
    "head": "new运算符",
    "relation": "限制",
    "tail": "堆空间分配",
    "source_topic": "类如何实现只能静态分配和只能动态分配"
  },
  {
    "head": "delete运算符",
    "relation": "限制",
    "tail": "堆空间分配",
    "source_topic": "类如何实现只能静态分配和只能动态分配"
  },
  {
    "head": "new运算符",
    "relation": "设置为",
    "tail": "private属性",
    "source_topic": "类如何实现只能静态分配和只能动态分配"
  },
  {
    "head": "构造函数",
    "relation": "设置为",
    "tail": "protected属性",
    "source_topic": "类如何实现只能静态分配和只能动态分配"
  },
  {
    "head": "析构函数",
    "relation": "设置为",
    "tail": "protected属性",
    "source_topic": "类如何实现只能静态分配和只能动态分配"
  },
  {
    "head": "动态建立",
    "relation": "包含",
    "tail": "类构造函数",
    "source_topic": "类如何实现只能静态分配和只能动态分配"
  },
  {
    "head": "类构造函数",
    "relation": "执行",
    "tail": "对象构造",
    "source_topic": "类如何实现只能静态分配和只能动态分配"
  },
  {
    "head": "派生类",
    "relation": "依赖",
    "tail": "基类成员定义",
    "source_topic": "如果想将某个类用作基类，为什么该类必须定义而非声明？"
  },
  {
    "head": "合成的默认构造函数",
    "relation": "初始化",
    "tail": "基类子对象",
    "source_topic": "什么情况会自动生成默认构造函数？"
  },
  {
    "head": "合成的默认构造函数",
    "relation": "初始化",
    "tail": "成员类对象",
    "source_topic": "什么情况会自动生成默认构造函数？"
  },
  {
    "head": "合成的默认构造函数",
    "relation": "不初始化",
    "tail": "非静态数据成员",
    "source_topic": "什么情况会自动生成默认构造函数？"
  },
  {
    "head": "类的继承",
    "relation": "属于",
    "tail": "类与类之间的关系",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "类的继承",
    "relation": "包含",
    "tail": "继承的相关概念",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "类的继承",
    "relation": "包含",
    "tail": "继承的特点",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "类的继承",
    "relation": "包含",
    "tail": "继承中的访问控制",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "类的继承",
    "relation": "包含",
    "tail": "继承中的构造和析构函数",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "类的继承",
    "relation": "包含",
    "tail": "继承中的兼容性原则",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "is-A",
    "relation": "属于",
    "tail": "类与类之间的关系",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "子类",
    "relation": "继承",
    "tail": "父类",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "子类",
    "relation": "拥有",
    "tail": "父类的所有属性和方法",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "子类",
    "relation": "可以拥有",
    "tail": "父类没有的属性和方法",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "子类对象",
    "relation": "可以当做",
    "tail": "父类对象",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "public",
    "relation": "属于",
    "tail": "继承中的访问控制",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "protected",
    "relation": "属于",
    "tail": "继承中的访问控制",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "private",
    "relation": "属于",
    "tail": "继承中的访问控制",
    "source_topic": "什么是类的继承？"
  },
  {
    "head": "组合类",
    "relation": "包含",
    "tail": "内嵌对象",
    "source_topic": "什么是组合？"
  },
  {
    "head": "组合类",
    "relation": "需要初始化",
    "tail": "内嵌对象",
    "source_topic": "什么是组合？"
  },
  {
    "head": "组合类构造函数",
    "relation": "执行顺序",
    "tail": "先调用内嵌对象的构造函数",
    "source_topic": "什么是组合？"
  },
  {
    "head": "组合类构造函数",
    "relation": "执行顺序",
    "tail": "与初始化列表顺序无关",
    "source_topic": "什么是组合？"
  },
  {
    "head": "组合类构造函数",
    "relation": "执行顺序",
    "tail": "执行组合类构造函数的函数体",
    "source_topic": "什么是组合？"
  },
  {
    "head": "组合类析构函数",
    "relation": "调用顺序",
    "tail": "与构造函数调用顺序相反",
    "source_topic": "什么是组合？"
  },
  {
    "head": "抽象基类",
    "relation": "不能定义对象的原因",
    "tail": "包含纯虚函数",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "纯虚函数",
    "relation": "作用",
    "tail": "为派生类提供操作接口的通用语义",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "抽象类",
    "relation": "定义",
    "tail": "带有纯虚函数的类",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "抽象类",
    "relation": "不能生成对象的原因",
    "tail": "包含未定义的纯虚函数",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "抽象类",
    "relation": "用途",
    "tail": "作为基类为派生类服务",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "派生类",
    "relation": "实现条件",
    "tail": "必须重载所有纯虚函数",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "纯虚函数",
    "relation": "实现位置",
    "tail": "由派生类给出",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "多态性",
    "relation": "实现方式",
    "tail": "通过虚函数实现",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "编译时多态性",
    "relation": "实现方式",
    "tail": "通过重载函数实现",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "虚函数",
    "relation": "定义方式",
    "tail": "在基类中被声明为virtual",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "虚函数",
    "relation": "功能",
    "tail": "实现成员函数的动态重载",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "抽象类",
    "relation": "分类",
    "tail": "不能生成对象",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "抽象类",
    "relation": "解决的问题",
    "tail": "基类本身生成对象不合情理",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "纯虚函数",
    "relation": "解决的问题",
    "tail": "基类无法提供具体实现",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "多态性",
    "relation": "分类",
    "tail": "编译时多态性",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "多态性",
    "relation": "分类",
    "tail": "运行时多态性",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "运行时多态性",
    "relation": "实现方式",
    "tail": "通过虚函数实现",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "抽象类",
    "relation": "解决的问题",
    "tail": "无法定义统一接口",
    "source_topic": "抽象基类为什么不能创建对象？"
  },
  {
    "head": "delete操作",
    "relation": "触发析构",
    "tail": "基类类型指针",
    "source_topic": "类什么时候会析构？"
  },
  {
    "head": "基类析构函数",
    "relation": "是虚函数",
    "tail": "delete操作",
    "source_topic": "类什么时候会析构？"
  },
  {
    "head": "成员对象",
    "relation": "被析构时",
    "tail": "外部对象析构函数被调用",
    "source_topic": "类什么时候会析构？"
  },
  {
    "head": "友元函数",
    "relation": "必须声明于",
    "tail": "类内部",
    "source_topic": "为什么友元函数必须在类内部声明？"
  },
  {
    "head": "C++多态",
    "relation": "分类",
    "tail": "静态多态",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "C++多态",
    "relation": "分类",
    "tail": "动态多态",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "静态多态",
    "relation": "实现方式",
    "tail": "函数重载",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "静态多态",
    "relation": "实现方式",
    "tail": "模板",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "静态多态",
    "relation": "确定时机",
    "tail": "编译时",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "动态多态",
    "relation": "实现方式",
    "tail": "虚函数",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "动态多态",
    "relation": "确定时机",
    "tail": "运行时",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "动态多态",
    "relation": "原理",
    "tail": "虚函数表",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "动态多态",
    "relation": "原理",
    "tail": "虚函数指针",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "动态绑定",
    "relation": "别称",
    "tail": "运行时绑定",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "动态绑定",
    "relation": "决定因素",
    "tail": "实参",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "模板",
    "relation": "代码生成时机",
    "tail": "实例化时",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "模板",
    "relation": "代码生成时机",
    "tail": "编译时",
    "source_topic": "介绍一下C++里面的多态？"
  },
  {
    "head": "C语言",
    "relation": "模拟",
    "tail": "C++继承",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "C语言",
    "relation": "模拟",
    "tail": "C++多态",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "强类型转换",
    "relation": "解决",
    "tail": "类型不匹配",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "子类对象",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "父类指针",
    "relation": "调用",
    "tail": "子类的同名函数",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "函数指针",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "函数指针",
    "relation": "实现",
    "tail": "动态绑定",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "C语言",
    "relation": "实现",
    "tail": "动态绑定",
    "source_topic": "用C语言实现C++的继承"
  },
  {
    "head": "向上类型转换",
    "relation": "属于",
    "tail": "继承机制",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "向下类型转换",
    "relation": "属于",
    "tail": "继承机制",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "向上类型转换",
    "relation": "核心特性",
    "tail": "自动进行",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "向上类型转换",
    "relation": "核心特性",
    "tail": "安全",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "向下类型转换",
    "relation": "核心特性",
    "tail": "需要动态类型识别技术",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "向下类型转换",
    "relation": "使用",
    "tail": "dynamic_cast",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "向下类型转换",
    "relation": "解决",
    "tail": "无法确定具体派生类的问题",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "dynamic_cast",
    "relation": "属于",
    "tail": "RTTI技术",
    "source_topic": "继承机制中对象之间如何转换？指针和引用之间如何转换？"
  },
  {
    "head": "Student",
    "relation": "继承",
    "tail": "Person",
    "source_topic": "组合与继承优缺点？"
  },
  {
    "head": "组合",
    "relation": "属于",
    "tail": "面向对象特性",
    "source_topic": "组合与继承优缺点？"
  },
  {
    "head": "组合",
    "relation": "核心特性",
    "tail": "Has a 关系",
    "source_topic": "组合与继承优缺点？"
  },
  {
    "head": "组合",
    "relation": "优点",
    "tail": "当前对象与包含对象是低耦合关系",
    "source_topic": "组合与继承优缺点？"
  },
  {
    "head": "组合",
    "relation": "缺点",
    "tail": "容易产生过多的对象",
    "source_topic": "组合与继承优缺点？"
  },
  {
    "head": "组合",
    "relation": "缺点",
    "tail": "需要仔细对接口进行定义",
    "source_topic": "组合与继承优缺点？"
  },
  {
    "head": "左值",
    "relation": "属于",
    "tail": "C++11值分类",
    "source_topic": "左值右值"
  },
  {
    "head": "右值",
    "relation": "属于",
    "tail": "C++11值分类",
    "source_topic": "左值右值"
  },
  {
    "head": "右值",
    "relation": "分类为",
    "tail": "纯右值",
    "source_topic": "左值右值"
  },
  {
    "head": "右值",
    "relation": "分类为",
    "tail": "将亡值",
    "source_topic": "左值右值"
  },
  {
    "head": "纯右值",
    "relation": "等同于",
    "tail": "C++98右值",
    "source_topic": "左值右值"
  },
  {
    "head": "纯右值",
    "relation": "包含",
    "tail": "临时变量",
    "source_topic": "左值右值"
  },
  {
    "head": "纯右值",
    "relation": "包含",
    "tail": "不跟对象关联的字面量值",
    "source_topic": "左值右值"
  },
  {
    "head": "将亡值",
    "relation": "属于",
    "tail": "C++11新增右值分类",
    "source_topic": "左值右值"
  },
  {
    "head": "将亡值",
    "relation": "关联",
    "tail": "右值引用",
    "source_topic": "左值右值"
  },
  {
    "head": "将亡值",
    "relation": "通常用于",
    "tail": "移动语义",
    "source_topic": "左值右值"
  },
  {
    "head": "将亡值",
    "relation": "获取方式",
    "tail": "std::move返回值",
    "source_topic": "左值右值"
  },
  {
    "head": "将亡值",
    "relation": "获取方式",
    "tail": "返回右值引用T&&的函数返回值",
    "source_topic": "左值右值"
  },
  {
    "head": "左值引用",
    "relation": "定义为",
    "tail": "对左值进行引用的类型",
    "source_topic": "左值右值"
  },
  {
    "head": "右值引用",
    "relation": "定义为",
    "tail": "对右值进行引用的类型",
    "source_topic": "左值右值"
  },
  {
    "head": "左值引用",
    "relation": "绑定对象",
    "tail": "具名变量",
    "source_topic": "左值右值"
  },
  {
    "head": "右值引用",
    "relation": "绑定对象",
    "tail": "不具名变量",
    "source_topic": "左值右值"
  },
  {
    "head": "左值引用",
    "relation": "不能绑定",
    "tail": "右值",
    "source_topic": "左值右值"
  },
  {
    "head": "常量左值引用",
    "relation": "可以绑定",
    "tail": "非常量左值",
    "source_topic": "左值右值"
  },
  {
    "head": "常量左值引用",
    "relation": "可以绑定",
    "tail": "常量左值",
    "source_topic": "左值右值"
  },
  {
    "head": "常量左值引用",
    "relation": "可以绑定",
    "tail": "右值",
    "source_topic": "左值右值"
  },
  {
    "head": "常量左值引用",
    "relation": "限制",
    "tail": "只读访问",
    "source_topic": "左值右值"
  },
  {
    "head": "右值引用",
    "relation": "不能绑定",
    "tail": "左值",
    "source_topic": "左值右值"
  },
  {
    "head": "std::move",
    "relation": "作用",
    "tail": "将左值强制转换为右值",
    "source_topic": "左值右值"
  },
  {
    "head": "移动构造函数",
    "relation": "设计初衷",
    "tail": "避免新的空间分配以降低构造成本",
    "source_topic": "移动构造函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "复制方式",
    "tail": "深层复制",
    "source_topic": "移动构造函数"
  },
  {
    "head": "移动构造函数",
    "relation": "复制方式",
    "tail": "浅层复制",
    "source_topic": "移动构造函数"
  },
  {
    "head": "移动构造函数",
    "relation": "参数类型",
    "tail": "右值引用",
    "source_topic": "移动构造函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "参数类型",
    "tail": "左值引用",
    "source_topic": "移动构造函数"
  },
  {
    "head": "移动构造函数",
    "relation": "调用条件",
    "tail": "用右值或将亡值初始化另一个对象",
    "source_topic": "移动构造函数"
  },
  {
    "head": "move语句",
    "relation": "作用",
    "tail": "将左值转换为将亡值",
    "source_topic": "移动构造函数"
  },
  {
    "head": "预处理",
    "relation": "处理内容",
    "tail": "宏定义替换",
    "source_topic": "移动构造函数"
  },
  {
    "head": "预处理",
    "relation": "处理内容",
    "tail": "条件编译指令",
    "source_topic": "移动构造函数"
  },
  {
    "head": "预处理",
    "relation": "处理内容",
    "tail": "头文件包含指令",
    "source_topic": "移动构造函数"
  },
  {
    "head": "预处理",
    "relation": "处理内容",
    "tail": "特殊符号",
    "source_topic": "移动构造函数"
  },
  {
    "head": "预处理",
    "relation": "输出文件",
    "tail": ".i预处理后的c文件",
    "source_topic": "移动构造函数"
  },
  {
    "head": "预处理",
    "relation": "输出文件",
    "tail": ".ii预处理后的C++文件",
    "source_topic": "移动构造函数"
  },
  {
    "head": "编译阶段",
    "relation": "处理内容",
    "tail": "词法分析",
    "source_topic": "移动构造函数"
  },
  {
    "head": "编译阶段",
    "relation": "处理内容",
    "tail": "语法分析",
    "source_topic": "移动构造函数"
  },
  {
    "head": "编译阶段",
    "relation": "处理内容",
    "tail": "翻译成中间代码表示",
    "source_topic": "移动构造函数"
  },
  {
    "head": "编译阶段",
    "relation": "处理内容",
    "tail": "翻译成汇编代码",
    "source_topic": "移动构造函数"
  },
  {
    "head": "编译阶段",
    "relation": "输出文件",
    "tail": ".s文件",
    "source_topic": "移动构造函数"
  },
  {
    "head": "汇编过程",
    "relation": "处理内容",
    "tail": "汇编语言代码",
    "source_topic": "移动构造函数"
  },
  {
    "head": "汇编过程",
    "relation": "处理内容",
    "tail": "翻译成目标机器指令",
    "source_topic": "移动构造函数"
  },
  {
    "head": "汇编过程",
    "relation": "输出文件",
    "tail": ".o目标文件",
    "source_topic": "移动构造函数"
  },
  {
    "head": "链接阶段",
    "relation": "处理内容",
    "tail": "连接目标文件",
    "source_topic": "移动构造函数"
  },
  {
    "head": "链接阶段",
    "relation": "处理内容",
    "tail": "引用符号与定义符号的连接",
    "source_topic": "移动构造函数"
  },
  {
    "head": "链接阶段",
    "relation": "输出结果",
    "tail": "可执行文件",
    "source_topic": "移动构造函数"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "连续内存空间",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "高效随机存取",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "时间复杂度",
    "tail": "O(1)",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "动态增长的对象数组",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "无需程序员手动扩容",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "时间复杂度",
    "tail": "O(n)（插入和删除）",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "双向链表",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "随机访问效率低",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "时间复杂度",
    "tail": "O(n)",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "高效插入和删除操作",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "支持双向遍历",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "区别",
    "tail": "list",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "区别",
    "tail": "随机访问效率高",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "区别",
    "tail": "随机访问效率低",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "区别",
    "tail": "插入和删除操作需要挪动数据",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "区别",
    "tail": "插入和删除操作方便",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "区别",
    "tail": "迭代器在使用后失效",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "区别",
    "tail": "迭代器在使用后仍可用",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "vector",
    "relation": "访问方式",
    "tail": "通过下标访问",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "访问方式",
    "tail": "通过反向迭代器遍历",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "list",
    "relation": "访问倒数第二个元素",
    "tail": "使用反向迭代器遍历",
    "source_topic": "vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"
  },
  {
    "head": "STL vector",
    "relation": "动态增长",
    "tail": "内存重新分配",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "STL vector",
    "relation": "动态增长",
    "tail": "元素拷贝",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "STL vector",
    "relation": "动态增长",
    "tail": "释放原内存空间",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "reserve(n)",
    "relation": "预先分配",
    "tail": "指定大小的内存空间",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "reserve(n)",
    "relation": "条件改变",
    "tail": "n > capacity()",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "resize()",
    "relation": "改变",
    "tail": "元素数目",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "resize()",
    "relation": "不改变",
    "tail": "容器容量",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "vector",
    "relation": "size()",
    "tail": "已用空间大小",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "vector",
    "relation": "capacity()",
    "tail": "总空间大小",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "vector",
    "relation": "扩容策略",
    "tail": "两倍扩容",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "两倍扩容",
    "relation": "优点",
    "tail": "常数时间复杂度",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "两倍扩容",
    "relation": "缺点",
    "tail": "内存浪费",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "扩容策略",
    "relation": "差异",
    "tail": "不同编译器",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "VS编译器",
    "relation": "扩容策略",
    "tail": "1.5倍",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "GCC编译器",
    "relation": "扩容策略",
    "tail": "2倍",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "vector",
    "relation": "内存释放",
    "tail": "析构时回收",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "clear()",
    "relation": "不释放",
    "tail": "内存空间",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "vector",
    "relation": "内存释放",
    "tail": "swap()",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "vector",
    "relation": "内存占用",
    "tail": "只增不减",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "deque",
    "relation": "优势",
    "tail": "支持动态缩小",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "vector",
    "relation": "扩容策略",
    "tail": "空间和时间的权衡",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "两倍扩容",
    "relation": "解决",
    "tail": "降低程序效率",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "两倍扩容",
    "relation": "导致",
    "tail": "内存无法被使用",
    "source_topic": "STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"
  },
  {
    "head": "顺序容器",
    "relation": "使用",
    "tail": "erase迭代器",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "erase迭代器",
    "relation": "导致",
    "tail": "迭代器失效",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "erase迭代器",
    "relation": "返回值",
    "tail": "下一个有效迭代器",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "关联容器",
    "relation": "使用",
    "tail": "erase迭代器",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "erase迭代器",
    "relation": "导致",
    "tail": "被删除元素的迭代器失效",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "erase迭代器",
    "relation": "返回值",
    "tail": "void",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "顺序容器",
    "relation": "排除",
    "tail": "list",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "关联容器",
    "relation": "包含",
    "tail": "list",
    "source_topic": "容器内部删除一个元素"
  },
  {
    "head": "STL迭代器",
    "relation": "作用",
    "tail": "容器与STL算法的粘合剂",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "*运算符",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "->运算符",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "++运算符",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "--运算符",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "difference type",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "pointer",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "reference",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "STL迭代器",
    "relation": "包含",
    "tail": "value type",
    "source_topic": "STL迭代器如何实现"
  },
  {
    "head": "set",
    "relation": "底层结构",
    "tail": "RB-Tree",
    "source_topic": "set与hash_set的区别"
  },
  {
    "head": "hash_set",
    "relation": "底层结构",
    "tail": "hash_table",
    "source_topic": "set与hash_set的区别"
  },
  {
    "head": "RB-Tree",
    "relation": "核心特性",
    "tail": "自动排序功能",
    "source_topic": "set与hash_set的区别"
  },
  {
    "head": "hash_table",
    "relation": "核心特性",
    "tail": "不具有自动排序功能",
    "source_topic": "set与hash_set的区别"
  },
  {
    "head": "set",
    "relation": "元素特性",
    "tail": "键值就是实值",
    "source_topic": "set与hash_set的区别"
  },
  {
    "head": "hash_set",
    "relation": "元素特性",
    "tail": "键值就是实值",
    "source_topic": "set与hash_set的区别"
  },
  {
    "head": "hash_table",
    "relation": "限制",
    "tail": "无法处理某些型别",
    "source_topic": "set与hash_set的区别"
  },
  {
    "head": "HashMap",
    "relation": "底层实现不同",
    "tail": "Map",
    "source_topic": "hashmap与map的区别"
  },
  {
    "head": "Map",
    "relation": "具有",
    "tail": "自动排序功能",
    "source_topic": "hashmap与map的区别"
  },
  {
    "head": "HashMap",
    "relation": "不具有",
    "tail": "自动排序功能",
    "source_topic": "hashmap与map的区别"
  },
  {
    "head": "Hashtable",
    "relation": "无法处理",
    "tail": "某些型别",
    "source_topic": "hashmap与map的区别"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "set",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "红黑树",
    "relation": "实现",
    "tail": "高效插入删除",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "红黑树",
    "relation": "核心特性",
    "tail": "自动排序",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "map",
    "relation": "节点数据类型",
    "tail": "key+value",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "set",
    "relation": "节点数据类型",
    "tail": "value",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "红黑树",
    "relation": "解决",
    "tail": "自动排序需求",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "红黑树",
    "relation": "保证",
    "tail": "O(logn)时间复杂度",
    "source_topic": "map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"
  },
  {
    "head": "STL容器",
    "relation": "包含",
    "tail": "内存管理方案",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "STL容器",
    "relation": "属于",
    "tail": "C++标准库",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "共享内存",
    "relation": "用于",
    "tail": "进程间通信（IPC）",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "共享内存",
    "relation": "限制",
    "tail": "容器内部分配内存",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "进程A",
    "relation": "放置",
    "tail": "STL容器",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "进程B",
    "relation": "获取",
    "tail": "STL容器",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "固定偏移地址",
    "relation": "解决",
    "tail": "进程B定位容器问题",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "map容器",
    "relation": "保存",
    "tail": "容器地址映射",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "进程A",
    "relation": "创建",
    "tail": "map容器",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "map容器",
    "relation": "属于",
    "tail": "STL容器",
    "source_topic": "如何在共享内存上使用stl标准库？"
  },
  {
    "head": "map插入方式",
    "relation": "包含",
    "tail": "数组方式插入数据",
    "source_topic": "map插入方式有几种？"
  },
  {
    "head": "数组方式插入数据",
    "relation": "属于",
    "tail": "C++ STL map操作",
    "source_topic": "map插入方式有几种？"
  },
  {
    "head": "mapStudent",
    "relation": "属于",
    "tail": "C++ STL map实例",
    "source_topic": "map插入方式有几种？"
  },
  {
    "head": "unordered_map",
    "relation": "属于",
    "tail": "STL",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "map",
    "relation": "属于",
    "tail": "STL",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "unordered_map",
    "relation": "存储结构",
    "tail": "hash_table",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "map",
    "relation": "存储结构",
    "tail": "二叉搜索树",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "unordered_map",
    "relation": "核心特性",
    "tail": "内部元素无序",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "内部元素有序",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "unordered_map",
    "relation": "需要定义",
    "tail": "hash_value函数",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "unordered_map",
    "relation": "需要重载",
    "tail": "operator==",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "map",
    "relation": "需要定义",
    "tail": "operator<",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "hash_table",
    "relation": "解决冲突方式",
    "tail": "开链法",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "unordered_map",
    "relation": "扩容条件",
    "tail": "元素个数大于等于阈值",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "阈值",
    "relation": "计算方式",
    "tail": "当前数组长度乘以加载因子",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "hash_map",
    "relation": "底层实现",
    "tail": "hash_table",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "hash_map",
    "relation": "解决冲突方式",
    "tail": "开链法",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "hash_map",
    "relation": "扩容条件",
    "tail": "元素个数大于等于阈值",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "hash_map",
    "relation": "扩容方式",
    "tail": "重新计算容量",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "hash_map",
    "relation": "扩容原因",
    "tail": "数组无法装载更多元素",
    "source_topic": "STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"
  },
  {
    "head": "vector",
    "relation": "不进行",
    "tail": "边界检查",
    "source_topic": "vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"
  },
  {
    "head": "vector",
    "relation": "支持",
    "tail": "at函数",
    "source_topic": "vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"
  },
  {
    "head": "at函数",
    "relation": "进行",
    "tail": "边界检查",
    "source_topic": "vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"
  },
  {
    "head": "map",
    "relation": "通过下标运算符[]",
    "tail": "查找并返回相应的值",
    "source_topic": "vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"
  },
  {
    "head": "erase()函数",
    "relation": "不能改变",
    "tail": "容量大小",
    "source_topic": "vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"
  },
  {
    "head": "erase()函数",
    "relation": "返回",
    "tail": "删除元素之后的迭代器",
    "source_topic": "vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"
  },
  {
    "head": "clear()函数",
    "relation": "不能改变",
    "tail": "容量大小",
    "source_topic": "vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "环状双向链表",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "节点存储空间不连续",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "存储空间连续",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "vector",
    "relation": "可能导致",
    "tail": "迭代器失效",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "deque",
    "relation": "底层结构",
    "tail": "分段连续空间",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "deque",
    "relation": "核心特性",
    "tail": "没有容量概念",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "deque",
    "relation": "核心特性",
    "tail": "支持头尾两端插入和删除操作",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "vector",
    "relation": "可能导致",
    "tail": "重新配置和数据移动",
    "source_topic": "STL中list与queue之间的区别"
  },
  {
    "head": "STL allocator",
    "relation": "属于",
    "tail": "第二级配置器",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "STL deallocator",
    "relation": "属于",
    "tail": "第二级配置器",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "第二级配置器",
    "relation": "采用",
    "tail": "malloc()",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "第二级配置器",
    "relation": "采用",
    "tail": "free()",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "第二级配置器",
    "relation": "采用",
    "tail": "realloc()",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "第二级配置器",
    "relation": "采用",
    "tail": "内存池整理方式",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "第二级配置器",
    "relation": "管理",
    "tail": "16个free-list",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "第二级配置器",
    "relation": "调整",
    "tail": "内存需求量至8的倍数",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "allocate()",
    "relation": "判断",
    "tail": "区块大小",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "allocate()",
    "relation": "调用",
    "tail": "第一级配置器",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "allocate()",
    "relation": "检查",
    "tail": "对应的free-list",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "allocate()",
    "relation": "调用",
    "tail": "refill()",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "deallocate()",
    "relation": "判断",
    "tail": "区块大小",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "deallocate()",
    "relation": "调用",
    "tail": "第一级配置器",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "deallocate()",
    "relation": "找到",
    "tail": "对应的free-list",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "free-list",
    "relation": "管理",
    "tail": "8~128bytes的小额区块",
    "source_topic": "STL中的allocator,deallocator"
  },
  {
    "head": "hash_map",
    "relation": "底层结构",
    "tail": "vector容器",
    "source_topic": "STL中hash_map扩容发生什么？"
  },
  {
    "head": "vector容器",
    "relation": "核心特性",
    "tail": "动态扩容能力",
    "source_topic": "STL中hash_map扩容发生什么？"
  },
  {
    "head": "hash_map",
    "relation": "扩容",
    "tail": "bucket数量增加",
    "source_topic": "STL中hash_map扩容发生什么？"
  },
  {
    "head": "bucket",
    "relation": "包含",
    "tail": "node",
    "source_topic": "STL中hash_map扩容发生什么？"
  },
  {
    "head": "node",
    "relation": "属于",
    "tail": "链表结构",
    "source_topic": "STL中hash_map扩容发生什么？"
  },
  {
    "head": "链表结构",
    "relation": "操作",
    "tail": "next指针",
    "source_topic": "STL中hash_map扩容发生什么？"
  },
  {
    "head": "hash_map",
    "relation": "操作",
    "tail": "跳至下一个bucket",
    "source_topic": "STL中hash_map扩容发生什么？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "数组",
    "source_topic": "map如何创建？"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "双向链表",
    "source_topic": "map如何创建？"
  },
  {
    "head": "deque",
    "relation": "底层结构",
    "tail": "中央控制器和多个缓冲区",
    "source_topic": "map如何创建？"
  },
  {
    "head": "deque",
    "relation": "属于",
    "tail": "双端队列",
    "source_topic": "map如何创建？"
  },
  {
    "head": "deque",
    "relation": "保存形式",
    "tail": "堆1",
    "source_topic": "map如何创建？"
  },
  {
    "head": "deque",
    "relation": "保存形式",
    "tail": "堆2",
    "source_topic": "map如何创建？"
  },
  {
    "head": "deque",
    "relation": "保存形式",
    "tail": "堆3",
    "source_topic": "map如何创建？"
  },
  {
    "head": "stack",
    "relation": "底层结构",
    "tail": "list",
    "source_topic": "map如何创建？"
  },
  {
    "head": "stack",
    "relation": "底层结构",
    "tail": "deque",
    "source_topic": "map如何创建？"
  },
  {
    "head": "queue",
    "relation": "底层结构",
    "tail": "list",
    "source_topic": "map如何创建？"
  },
  {
    "head": "queue",
    "relation": "底层结构",
    "tail": "deque",
    "source_topic": "map如何创建？"
  },
  {
    "head": "priority_queue",
    "relation": "底层结构",
    "tail": "vector",
    "source_topic": "map如何创建？"
  },
  {
    "head": "set",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "map如何创建？"
  },
  {
    "head": "set",
    "relation": "核心特性",
    "tail": "有序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "set",
    "relation": "核心特性",
    "tail": "不重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "multiset",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "map如何创建？"
  },
  {
    "head": "multiset",
    "relation": "核心特性",
    "tail": "有序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "multiset",
    "relation": "核心特性",
    "tail": "可重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "map如何创建？"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "有序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "不重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "multimap",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "map如何创建？"
  },
  {
    "head": "multimap",
    "relation": "核心特性",
    "tail": "有序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "multimap",
    "relation": "核心特性",
    "tail": "可重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_set",
    "relation": "底层结构",
    "tail": "hash表",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_set",
    "relation": "核心特性",
    "tail": "无序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_set",
    "relation": "核心特性",
    "tail": "不重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_multiset",
    "relation": "底层结构",
    "tail": "hash表",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_multiset",
    "relation": "核心特性",
    "tail": "无序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_multiset",
    "relation": "核心特性",
    "tail": "可重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_map",
    "relation": "底层结构",
    "tail": "hash表",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_map",
    "relation": "核心特性",
    "tail": "无序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_map",
    "relation": "核心特性",
    "tail": "不重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_multimap",
    "relation": "底层结构",
    "tail": "hash表",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_multimap",
    "relation": "核心特性",
    "tail": "无序",
    "source_topic": "map如何创建？"
  },
  {
    "head": "hash_multimap",
    "relation": "核心特性",
    "tail": "可重复",
    "source_topic": "map如何创建？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "连续数组",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "分配更大内存并复制数据",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "释放旧内存",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "1.5倍扩容",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "2倍扩容",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "VS2015",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "GCC",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "成倍增长",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "减少堆空间浪费",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "保证常数时间复杂度",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "操作",
    "tail": "pop_back()",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "操作",
    "tail": "erase()",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "操作",
    "tail": "remove()",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "pop_back()",
    "relation": "功能",
    "tail": "删除最后一个元素",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "erase()",
    "relation": "功能",
    "tail": "删除指定元素",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "erase()",
    "relation": "功能",
    "tail": "删除指定范围元素",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "remove()",
    "relation": "功能",
    "tail": "删除vector容器中的元素",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "remove()",
    "relation": "特性",
    "tail": "不改变容器大小",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "pop_back()",
    "relation": "特性",
    "tail": "改变容器大小",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "erase()",
    "relation": "特性",
    "tail": "改变容器大小",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "初始capacity为0",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "空间重新配置",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "导致",
    "tail": "迭代器失效",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "增长因子在(1,2)之间",
    "source_topic": "vector的增加删除都是怎么做的？为什么是1.5倍？"
  },
  {
    "head": "函数指针",
    "relation": "属于",
    "tail": "计算机编程概念",
    "source_topic": "函数指针？"
  },
  {
    "head": "函数指针",
    "relation": "定义依据",
    "tail": "函数的返回类型和参数列表",
    "source_topic": "函数指针？"
  },
  {
    "head": "函数指针",
    "relation": "调用方式",
    "tail": "通过函数名调用",
    "source_topic": "函数指针？"
  },
  {
    "head": "函数指针",
    "relation": "调用方式",
    "tail": "通过指向函数的指针调用",
    "source_topic": "函数指针？"
  },
  {
    "head": "函数指针",
    "relation": "赋值方法",
    "tail": "指针名 = 函数名",
    "source_topic": "函数指针？"
  },
  {
    "head": "函数指针",
    "relation": "赋值方法",
    "tail": "指针名 = &函数名",
    "source_topic": "函数指针？"
  },
  {
    "head": "函数指针",
    "relation": "技术原理",
    "tail": "函数也有地址，函数地址是进入点",
    "source_topic": "函数指针？"
  },
  {
    "head": "C语言",
    "relation": "属于",
    "tail": "面向过程的语言",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++语言",
    "relation": "属于",
    "tail": "面向对象的语言",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C语言",
    "relation": "动态内存管理方法",
    "tail": "malloc/free函数",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++语言",
    "relation": "动态内存管理方法",
    "tail": "new/delete关键字",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C语言",
    "relation": "结构体",
    "tail": "struct",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++语言",
    "relation": "类",
    "tail": "class",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++的struct",
    "relation": "默认访问修饰符",
    "tail": "public",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++的class",
    "relation": "默认访问修饰符",
    "tail": "private",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++语言",
    "relation": "支持",
    "tail": "函数重载",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "函数重载",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++语言",
    "relation": "支持",
    "tail": "引用",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "引用",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++语言",
    "relation": "变量默认链接属性",
    "tail": "外链接",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C语言",
    "relation": "变量默认链接属性",
    "tail": "内链接",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C语言",
    "relation": "const变量限制",
    "tail": "不可用于定义数组大小",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "C++语言",
    "relation": "特有特性",
    "tail": "输入输出流",
    "source_topic": "说说你对c和c++的看法，c和c++的区别？"
  },
  {
    "head": "栈区",
    "relation": "存储",
    "tail": "函数的参数值",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "栈区",
    "relation": "存储",
    "tail": "局部变量的值",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "栈区",
    "relation": "分配方式",
    "tail": "由编译器自动分配释放",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "堆区",
    "relation": "存储",
    "tail": "程序员分配释放的内存",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "堆区",
    "relation": "分配方式",
    "tail": "类似于链表",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "初始化的全局变量",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "初始化的静态变量",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "未初始化的全局变量",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "未初始化的静态变量",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "全局区",
    "relation": "释放方式",
    "tail": "程序结束后由系统释放",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "文字常量区",
    "relation": "存储",
    "tail": "常量字符串",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "文字常量区",
    "relation": "释放方式",
    "tail": "程序结束后由系统释放",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "程序代码区",
    "relation": "存储",
    "tail": "函数体的二进制代码",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "C/C++内存分配",
    "relation": "包含",
    "tail": "栈区",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "C/C++内存分配",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "C/C++内存分配",
    "relation": "包含",
    "tail": "全局区",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "C/C++内存分配",
    "relation": "包含",
    "tail": "文字常量区",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "C/C++内存分配",
    "relation": "包含",
    "tail": "程序代码区",
    "source_topic": "c/c++的内存分配，详细说一下栈、堆、静态存储区？"
  },
  {
    "head": "野指针",
    "relation": "成因",
    "tail": "指针变量没有被初始化",
    "source_topic": "野指针是什么？如何检测内存泄漏？"
  },
  {
    "head": "野指针",
    "relation": "成因",
    "tail": "指针操作超越了变量的作用范围",
    "source_topic": "野指针是什么？如何检测内存泄漏？"
  },
  {
    "head": "指针变量",
    "relation": "初始化方式",
    "tail": "设置为NULL",
    "source_topic": "野指针是什么？如何检测内存泄漏？"
  },
  {
    "head": "指针变量",
    "relation": "初始化方式",
    "tail": "用malloc分配内存",
    "source_topic": "野指针是什么？如何检测内存泄漏？"
  },
  {
    "head": "指针",
    "relation": "释放后处理",
    "tail": "将指针赋NULL",
    "source_topic": "野指针是什么？如何检测内存泄漏？"
  },
  {
    "head": "野指针",
    "relation": "避免方法",
    "tail": "对指针进行初始化",
    "source_topic": "野指针是什么？如何检测内存泄漏？"
  },
  {
    "head": "野指针",
    "relation": "特征",
    "tail": "指针没有初始化",
    "source_topic": "悬空指针和野指针有什么区别？"
  },
  {
    "head": "野指针",
    "relation": "特征",
    "tail": "释放后没有置空",
    "source_topic": "悬空指针和野指针有什么区别？"
  },
  {
    "head": "野指针",
    "relation": "特征",
    "tail": "越界",
    "source_topic": "悬空指针和野指针有什么区别？"
  },
  {
    "head": "悬空指针",
    "relation": "特征",
    "tail": "指针指向的对象已被删除",
    "source_topic": "悬空指针和野指针有什么区别？"
  },
  {
    "head": "野指针",
    "relation": "分类",
    "tail": "悬空指针",
    "source_topic": "悬空指针和野指针有什么区别？"
  },
  {
    "head": "悬空指针",
    "relation": "分类",
    "tail": "指针",
    "source_topic": "悬空指针和野指针有什么区别？"
  },
  {
    "head": "内存泄漏",
    "relation": "非物理现象",
    "tail": "内存在物理上并未消失",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏",
    "relation": "原因",
    "tail": "设计错误导致失去对内存的控制",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏",
    "relation": "后果",
    "tail": "性能下降",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏",
    "relation": "后果",
    "tail": "内存逐渐用完",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏",
    "relation": "后果",
    "tail": "导致其他程序失败",
    "source_topic": "内存泄漏"
  },
  {
    "head": "BoundsChecker",
    "relation": "功能",
    "tail": "定位程序运行时期发生的各种错误",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏排除",
    "relation": "技术",
    "tail": "运行时函数调用堆栈",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏排除",
    "relation": "技术",
    "tail": "内存泄漏时提示的内存分配序号",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏排除",
    "relation": "技术",
    "tail": "集成开发环境OUTPUT窗口",
    "source_topic": "内存泄漏"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏定位",
    "relation": "方法",
    "tail": "查看调用堆栈",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏定位",
    "relation": "方法",
    "tail": "查看输出信息",
    "source_topic": "内存泄漏"
  },
  {
    "head": "内存泄漏定位",
    "relation": "依赖",
    "tail": "包含头文件#include",
    "source_topic": "内存泄漏"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++关键字",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++关键字",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "需要编译器支持",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "malloc",
    "relation": "需要头文件支持",
    "tail": "C标准库",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "无需指定内存块大小",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "malloc",
    "relation": "需要显式指定内存尺寸",
    "tail": "C标准库",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "返回对象类型指针",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "malloc",
    "relation": "返回void指针",
    "tail": "C标准库",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "符合类型安全性",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "malloc",
    "relation": "需要强制类型转换",
    "tail": "C标准库",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "分配失败时抛出异常",
    "tail": "bac_alloc",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "malloc",
    "relation": "分配失败时返回NULL",
    "tail": "C标准库",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "调用operator new函数",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "调用构造函数",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "delete",
    "relation": "调用析构函数",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "delete",
    "relation": "调用operator delete函数",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "operator new",
    "relation": "底层实现使用",
    "tail": "malloc",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "operator delete",
    "relation": "底层实现使用",
    "tail": "free",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "malloc",
    "relation": "动态申请内存",
    "tail": "C标准库",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "free",
    "relation": "动态释放内存",
    "tail": "C标准库",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "new",
    "relation": "初始化成员变量",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "delete",
    "relation": "释放内存",
    "tail": "C++",
    "source_topic": "new和malloc的区别？"
  },
  {
    "head": "delete p",
    "relation": "导致",
    "tail": "未定义行为",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "delete[] p",
    "relation": "用于",
    "tail": "动态数组",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "new",
    "relation": "组合",
    "tail": "内存分配",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "new",
    "relation": "组合",
    "tail": "对象构造",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "delete",
    "relation": "组合",
    "tail": "对象析构",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "delete",
    "relation": "组合",
    "tail": "内存释放",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "allocator",
    "relation": "分离",
    "tail": "内存分配",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "allocator",
    "relation": "分离",
    "tail": "对象构造",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "delete[]",
    "relation": "按顺序",
    "tail": "逆序销毁数组元素",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "new",
    "relation": "返回",
    "tail": "元素类型指针",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "动态数组",
    "relation": "需要",
    "tail": "delete[]",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "new",
    "relation": "限制",
    "tail": "整数必须为常量",
    "source_topic": "delete p;与delete[]p，allocator"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "operator new",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "new",
    "relation": "分配内存",
    "tail": "原始内存空间",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "new",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "new[]",
    "relation": "调用",
    "tail": "operator new[]",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "new[]",
    "relation": "分配内存",
    "tail": "数组空间",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "new[]",
    "relation": "存储",
    "tail": "数组大小",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "free函数",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "delete",
    "relation": "释放",
    "tail": "p指向的内存",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "delete[]",
    "relation": "释放",
    "tail": "p-4指向的内存",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "delete[]",
    "relation": "读取",
    "tail": "数组大小",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "delete",
    "relation": "等同",
    "tail": "delete[]",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "delete",
    "relation": "导致",
    "tail": "系统崩溃",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "C++",
    "relation": "实现",
    "tail": "new[]存储数组大小",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "C++",
    "relation": "解决",
    "tail": "delete无法确定数组大小",
    "source_topic": "new和delete的实现原理， delete是如何知道释放内存的大小的额？"
  },
  {
    "head": "malloc",
    "relation": "操作对象",
    "tail": "明确大小的内存",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "free",
    "relation": "操作对象",
    "tail": "明确大小的内存",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "new",
    "relation": "可以取代",
    "tail": "malloc",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "delete",
    "relation": "可以取代",
    "tail": "free",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "malloc",
    "relation": "不能用于",
    "tail": "动态类",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "free",
    "relation": "不能用于",
    "tail": "动态类",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "new",
    "relation": "自动进行",
    "tail": "类型检查",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "new",
    "relation": "自动进行",
    "tail": "内存大小计算",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "delete",
    "relation": "自动进行",
    "tail": "析构函数调用",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "malloc",
    "relation": "不执行",
    "tail": "构造函数",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "free",
    "relation": "不执行",
    "tail": "析构函数",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "delete",
    "relation": "可以释放",
    "tail": "malloc申请的内存",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "delete",
    "relation": "不推荐使用",
    "tail": "释放malloc申请的内存",
    "source_topic": "malloc申请的存储空间能用delete释放吗"
  },
  {
    "head": "malloc",
    "relation": "底层实现",
    "tail": "brk",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "malloc",
    "relation": "底层实现",
    "tail": "mmap",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "free",
    "relation": "底层实现",
    "tail": "munmap",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "brk",
    "relation": "分配方式",
    "tail": "数据段",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "mmap",
    "relation": "分配区域",
    "tail": "文件映射区域",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "brk",
    "relation": "分配类型",
    "tail": "虚拟内存",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "mmap",
    "relation": "分配类型",
    "tail": "虚拟内存",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "brk",
    "relation": "释放条件",
    "tail": "高地址内存释放",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "mmap",
    "relation": "释放条件",
    "tail": "单独释放",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "malloc",
    "relation": "分配条件",
    "tail": "小于128k",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "malloc",
    "relation": "分配条件",
    "tail": "brk",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "malloc",
    "relation": "分配条件",
    "tail": "大于128k",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "malloc",
    "relation": "分配条件",
    "tail": "mmap",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "内存紧缩",
    "relation": "触发条件",
    "tail": "最高地址空闲内存超过128K",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "操作系统",
    "relation": "处理方式",
    "tail": "遍历空闲内存地址链表",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "缺页中断",
    "relation": "触发时机",
    "tail": "第一次访问已分配的虚拟地址空间",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "操作系统",
    "relation": "处理方式",
    "tail": "分配物理内存",
    "source_topic": "malloc与free的实现原理？"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "动态内存分配函数",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "calloc",
    "relation": "属于",
    "tail": "动态内存分配函数",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "realloc",
    "relation": "属于",
    "tail": "动态内存分配函数",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "malloc",
    "relation": "核心特性",
    "tail": "分配的内存空间未初始化",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "calloc",
    "relation": "核心特性",
    "tail": "分配的内存空间初始化为0",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "malloc",
    "relation": "参数",
    "tail": "num_size",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "calloc",
    "relation": "参数",
    "tail": "n, size",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "realloc",
    "relation": "参数",
    "tail": "p, new_size",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "malloc",
    "relation": "功能",
    "tail": "申请指定大小的内存空间",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "realloc",
    "relation": "功能",
    "tail": "调整已分配内存块的大小",
    "source_topic": "malloc、realloc、calloc的区别"
  },
  {
    "head": "__stdcall",
    "relation": "堆栈恢复方式",
    "tail": "函数恢复堆栈",
    "source_topic": "__stdcall和__cdecl的区别？"
  },
  {
    "head": "__stdcall",
    "relation": "参数个数限制",
    "tail": "编译时规定参数个数",
    "source_topic": "__stdcall和__cdecl的区别？"
  },
  {
    "head": "__stdcall",
    "relation": "不支持特性",
    "tail": "不定个数参数调用",
    "source_topic": "__stdcall和__cdecl的区别？"
  },
  {
    "head": "__cdecl",
    "relation": "堆栈恢复方式",
    "tail": "调用者恢复堆栈",
    "source_topic": "__stdcall和__cdecl的区别？"
  },
  {
    "head": "__cdecl",
    "relation": "支持特性",
    "tail": "不定参数个数",
    "source_topic": "__stdcall和__cdecl的区别？"
  },
  {
    "head": "__cdecl",
    "relation": "代码冗余",
    "tail": "每个调用函数包含清空堆栈代码",
    "source_topic": "__stdcall和__cdecl的区别？"
  },
  {
    "head": "__cdecl",
    "relation": "影响",
    "tail": "可执行文件体积较大",
    "source_topic": "__stdcall和__cdecl的区别？"
  },
  {
    "head": "RAII",
    "relation": "属于",
    "tail": "C++语言机制",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "RAII",
    "relation": "核心特性",
    "tail": "资源获取即初始化",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "RAII",
    "relation": "实现方式",
    "tail": "智能指针",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "智能指针",
    "relation": "分类",
    "tail": "std::shared_ptr",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "智能指针",
    "relation": "分类",
    "tail": "std::unique_ptr",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "智能指针",
    "relation": "核心特性",
    "tail": "自动内存管理",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "RAII",
    "relation": "绑定",
    "tail": "对象生命周期",
    "source_topic": "使用智能指针管理内存资源，RAII"
  },
  {
    "head": "智能指针",
    "relation": "属于",
    "tail": "数据类型",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "实现方式",
    "tail": "模板",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "提供",
    "tail": "自动垃圾回收机制",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "记录",
    "tail": "引用计数",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "引用计数",
    "relation": "触发",
    "tail": "释放T类型对象",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "拷贝构造函数",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "复制构造函数",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "析构函数",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "移走函数",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "析构函数",
    "relation": "负责",
    "tail": "引用计数减少",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "析构函数",
    "relation": "负责",
    "tail": "释放内存",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "赋值运算符",
    "relation": "覆写",
    "tail": "智能指针",
    "source_topic": "手写实现智能指针类"
  },
  {
    "head": "内存对齐",
    "relation": "包含",
    "tail": "变量偏移量整数倍规则",
    "source_topic": "内存对齐？位域？"
  },
  {
    "head": "内存对齐",
    "relation": "包含",
    "tail": "结构体大小整数倍规则",
    "source_topic": "内存对齐？位域？"
  },
  {
    "head": "内存对齐",
    "relation": "影响",
    "tail": "结构体内存布局",
    "source_topic": "内存对齐？位域？"
  },
  {
    "head": "#pragma pack(n)",
    "relation": "修改",
    "tail": "内存对齐规则",
    "source_topic": "内存对齐？位域？"
  },
  {
    "head": "#pragma pack(n)",
    "relation": "限制",
    "tail": "n值必须为1,2,4,8…",
    "source_topic": "内存对齐？位域？"
  },
  {
    "head": "#pragma pack(n)",
    "relation": "限制",
    "tail": "非指定值时按照默认分配规则",
    "source_topic": "内存对齐？位域？"
  },
  {
    "head": "结构体变量",
    "relation": "比较相等性",
    "tail": "重载操作符",
    "source_topic": "结构体变量比较是否相等"
  },
  {
    "head": "foo结构体",
    "relation": "重载操作符",
    "tail": "operator==",
    "source_topic": "结构体变量比较是否相等"
  },
  {
    "head": "operator==",
    "relation": "实现方式",
    "tail": "比较结构体成员a和b是否相等",
    "source_topic": "结构体变量比较是否相等"
  },
  {
    "head": "结构体变量",
    "relation": "比较相等性",
    "tail": "逐个元素比较",
    "source_topic": "结构体变量比较是否相等"
  },
  {
    "head": "指针",
    "relation": "比较相等性",
    "tail": "比较内存地址",
    "source_topic": "结构体变量比较是否相等"
  },
  {
    "head": "指针比较",
    "relation": "判断条件",
    "tail": "是否指向同一实例",
    "source_topic": "结构体变量比较是否相等"
  },
  {
    "head": "位运算",
    "relation": "应用",
    "tail": "模运算",
    "source_topic": "位运算"
  },
  {
    "head": "内存对齐",
    "relation": "解决",
    "tail": "处理器需要两次内存访问的问题",
    "source_topic": "为什么内存对齐"
  },
  {
    "head": "内存对齐",
    "relation": "属于",
    "tail": "性能优化原因",
    "source_topic": "为什么内存对齐"
  },
  {
    "head": "内存对齐",
    "relation": "属于",
    "tail": "平台兼容性原因",
    "source_topic": "为什么内存对齐"
  },
  {
    "head": "未对齐内存访问",
    "relation": "导致",
    "tail": "处理器需要两次内存访问",
    "source_topic": "为什么内存对齐"
  },
  {
    "head": "对齐内存访问",
    "relation": "仅需要",
    "tail": "一次内存访问",
    "source_topic": "为什么内存对齐"
  },
  {
    "head": "函数调用过程",
    "relation": "参数压栈顺序",
    "tail": "从右向左",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "调用者函数",
    "relation": "压入栈",
    "tail": "返回地址",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "调用者函数",
    "relation": "压入栈",
    "tail": "被调函数参数",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "被调函数",
    "relation": "保存",
    "tail": "调用者函数栈底地址",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "被调函数",
    "relation": "保存",
    "tail": "调用者函数栈顶地址",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "被调函数",
    "relation": "局部变量存储位置",
    "tail": "ebp位置",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "局部变量",
    "relation": "地址排列方式",
    "tail": "栈延伸方向",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "局部变量",
    "relation": "定义顺序",
    "tail": "先定义先入栈",
    "source_topic": "函数调用过程栈的变化，返回值和参数变量哪个先入栈？"
  },
  {
    "head": "浮点数",
    "relation": "导致",
    "tail": "比较误差",
    "source_topic": "怎样判断两个浮点数是否相等？"
  },
  {
    "head": "浮点数比较",
    "relation": "解决",
    "tail": "精度比较",
    "source_topic": "怎样判断两个浮点数是否相等？"
  },
  {
    "head": "浮点数比较",
    "relation": "包含",
    "tail": "取绝对值",
    "source_topic": "怎样判断两个浮点数是否相等？"
  },
  {
    "head": "浮点数",
    "relation": "与",
    "tail": "0的比较",
    "source_topic": "怎样判断两个浮点数是否相等？"
  },
  {
    "head": "浮点数",
    "relation": "与",
    "tail": "表示方式",
    "source_topic": "怎样判断两个浮点数是否相等？"
  },
  {
    "head": "const",
    "relation": "区别",
    "tail": "define",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "const",
    "relation": "区别",
    "tail": "预处理阶段",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "const",
    "relation": "区别",
    "tail": "编译阶段",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "const",
    "relation": "区别",
    "tail": "类型检查",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "const",
    "relation": "区别",
    "tail": "数据段空间",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "const",
    "relation": "区别",
    "tail": "不能重定义",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "属于",
    "tail": "预处理",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "区别",
    "tail": "const",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "区别",
    "tail": "文本替换",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "区别",
    "tail": "无类型检查",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "区别",
    "tail": "代码段空间",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "区别",
    "tail": "可重定义",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "区别",
    "tail": "无作用域限制",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "typedef",
    "relation": "区别",
    "tail": "define",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "typedef",
    "relation": "区别",
    "tail": "编译阶段",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "typedef",
    "relation": "区别",
    "tail": "类型检查",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "typedef",
    "relation": "区别",
    "tail": "有作用域限制",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "typedef",
    "relation": "功能",
    "tail": "定义类型的别名",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "typedef",
    "relation": "功能",
    "tail": "定义与平台无关的数据类型",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "typedef",
    "relation": "功能",
    "tail": "与struct结合使用",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "功能",
    "tail": "定义常量",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "功能",
    "tail": "定义变量",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "功能",
    "tail": "定义编译开关",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "define",
    "relation": "功能",
    "tail": "防止文件重复引用",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "inline",
    "relation": "区别",
    "tail": "define",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "inline",
    "relation": "区别",
    "tail": "编译阶段替换",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "inline",
    "relation": "区别",
    "tail": "有类型检查",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "inline",
    "relation": "区别",
    "tail": "更安全",
    "source_topic": "define、const、typedef、inline使用方法？"
  },
  {
    "head": "printf",
    "relation": "底层结构",
    "tail": "堆栈",
    "source_topic": "printf实现原理？"
  },
  {
    "head": "C/C++函数参数",
    "relation": "传递方式",
    "tail": "压入堆栈",
    "source_topic": "printf实现原理？"
  },
  {
    "head": "堆栈",
    "relation": "数据结构",
    "tail": "先进后出",
    "source_topic": "printf实现原理？"
  },
  {
    "head": "堆栈指针",
    "relation": "控制",
    "tail": "栈的生长",
    "source_topic": "printf实现原理？"
  },
  {
    "head": "printf",
    "relation": "参数扫描顺序",
    "tail": "从后向前",
    "source_topic": "printf实现原理？"
  },
  {
    "head": "printf",
    "relation": "第一个参数",
    "tail": "字符指针",
    "source_topic": "printf实现原理？"
  },
  {
    "head": "printf",
    "relation": "计算偏移量",
    "tail": "基于参数个数及数据类型",
    "source_topic": "printf实现原理？"
  },
  {
    "head": "尖括号",
    "relation": "用于",
    "tail": "包含标准库文件",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "双引号",
    "relation": "用于",
    "tail": "包含用户自己编写的头文件",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "尖括号",
    "relation": "搜索路径",
    "tail": "系统默认目录或工作目录",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "lambda表达式",
    "relation": "属于",
    "tail": "匿名函数",
    "source_topic": "lambda函数"
  },
  {
    "head": "lambda表达式",
    "relation": "生成",
    "tail": "闭包类型",
    "source_topic": "lambda函数"
  },
  {
    "head": "闭包类型",
    "relation": "重载",
    "tail": "()运算符",
    "source_topic": "lambda函数"
  },
  {
    "head": "lambda表达式",
    "relation": "返回",
    "tail": "闭包实例",
    "source_topic": "lambda函数"
  },
  {
    "head": "lambda表达式",
    "relation": "必须使用",
    "tail": "尾置返回",
    "source_topic": "lambda函数"
  },
  {
    "head": "lambda表达式",
    "relation": "包含",
    "tail": "捕获列表",
    "source_topic": "lambda函数"
  },
  {
    "head": "lambda表达式",
    "relation": "包含",
    "tail": "函数体",
    "source_topic": "lambda函数"
  },
  {
    "head": "lambda捕捉块",
    "relation": "定义",
    "tail": "捕捉模式",
    "source_topic": "lambda函数"
  },
  {
    "head": "HelloWorld程序",
    "relation": "包含",
    "tail": "程序首部信息",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "程序首部信息",
    "relation": "确定",
    "tail": "代码和数据在可执行文件中的位置",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "计算",
    "tail": "磁盘块地址",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "创建",
    "tail": "新进程",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "新进程",
    "relation": "映射",
    "tail": "HelloWorld可执行文件",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "设置",
    "tail": "CPU上下文环境",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "跳转",
    "tail": "程序开始处",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "HelloWorld程序",
    "relation": "触发",
    "tail": "缺页异常",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "分配",
    "tail": "一页物理内存",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "读取",
    "tail": "代码从磁盘到内存",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "HelloWorld程序",
    "relation": "调用",
    "tail": "puts函数",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "puts函数",
    "relation": "属于",
    "tail": "系统调用",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "定位",
    "tail": "显示设备",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "操作系统",
    "relation": "传递",
    "tail": "字符串到控制显示设备的进程",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "控制显示设备的进程",
    "relation": "通知",
    "tail": "窗口系统",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "窗口系统",
    "relation": "验证",
    "tail": "操作合法性",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "窗口系统",
    "relation": "转换",
    "tail": "字符串为像素",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "窗口系统",
    "relation": "写入",
    "tail": "设备的存储映像区",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "视频硬件",
    "relation": "转换",
    "tail": "像素为显示器信号",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "显示器",
    "relation": "解释",
    "tail": "控制数据信号",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "显示器",
    "relation": "激发",
    "tail": "液晶屏",
    "source_topic": "hello world 程序开始到打印到屏幕上的全过程?"
  },
  {
    "head": "函数模板",
    "relation": "允许",
    "tail": "隐式调用",
    "source_topic": "模板类和模板函数的区别是什么？"
  },
  {
    "head": "函数模板",
    "relation": "允许",
    "tail": "显式调用",
    "source_topic": "模板类和模板函数的区别是什么？"
  },
  {
    "head": "类模板",
    "relation": "必须",
    "tail": "显式调用",
    "source_topic": "模板类和模板函数的区别是什么？"
  },
  {
    "head": "类模板",
    "relation": "使用时",
    "tail": "必须加模板参数",
    "source_topic": "模板类和模板函数的区别是什么？"
  },
  {
    "head": "模板类",
    "relation": "定义特殊性",
    "tail": "编译器不分配存储空间",
    "source_topic": "为什么模板类一般都是放在一个h文件中"
  },
  {
    "head": "模板类",
    "relation": "实例化时机",
    "tail": "直到被模板实例告知",
    "source_topic": "为什么模板类一般都是放在一个h文件中"
  },
  {
    "head": "模板类",
    "relation": "解决机制",
    "tail": "连接器去掉多重定义",
    "source_topic": "为什么模板类一般都是放在一个h文件中"
  },
  {
    "head": "分离式编译",
    "relation": "限制",
    "tail": "模板实例化",
    "source_topic": "为什么模板类一般都是放在一个h文件中"
  },
  {
    "head": "编译器",
    "relation": "无法实例化",
    "tail": "未看到模板实例",
    "source_topic": "为什么模板类一般都是放在一个h文件中"
  },
  {
    "head": "模板类",
    "relation": "依赖",
    "tail": "头文件中声明和定义",
    "source_topic": "为什么模板类一般都是放在一个h文件中"
  },
  {
    "head": "连接器",
    "relation": "无法解决",
    "tail": "未找到模板实例的二进制代码",
    "source_topic": "为什么模板类一般都是放在一个h文件中"
  },
  {
    "head": "C++类成员",
    "relation": "具有",
    "tail": "public访问权限",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "C++类成员",
    "relation": "具有",
    "tail": "private访问权限",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "C++类成员",
    "relation": "具有",
    "tail": "protected访问权限",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "public访问权限",
    "relation": "允许访问",
    "tail": "类内",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "public访问权限",
    "relation": "允许访问",
    "tail": "类外",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "private访问权限",
    "relation": "仅允许访问",
    "tail": "类内",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "protected访问权限",
    "relation": "仅允许访问",
    "tail": "类内",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "protected访问权限",
    "relation": "允许访问",
    "tail": "派生类",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "C++继承方式",
    "relation": "包含",
    "tail": "public继承",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "C++继承方式",
    "relation": "包含",
    "tail": "private继承",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "C++继承方式",
    "relation": "包含",
    "tail": "protected继承",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "public继承",
    "relation": "保持",
    "tail": "基类成员访问权限",
    "source_topic": "C++中类成员的访问权限和继承权限问题。"
  },
  {
    "head": "cout",
    "relation": "属于",
    "tail": "缓冲输出",
    "source_topic": "cout和printf有什么区别？"
  },
  {
    "head": "endl",
    "relation": "导致",
    "tail": "缓冲输出",
    "source_topic": "cout和printf有什么区别？"
  },
  {
    "head": "flush",
    "relation": "导致",
    "tail": "缓冲输出",
    "source_topic": "cout和printf有什么区别？"
  },
  {
    "head": "printf",
    "relation": "属于",
    "tail": "无缓冲输出",
    "source_topic": "cout和printf有什么区别？"
  },
  {
    "head": "重载运算符",
    "relation": "限制",
    "tail": "不能发明新的运算符",
    "source_topic": "重载运算符？"
  },
  {
    "head": "重载运算符",
    "relation": "限制",
    "tail": "不能改变运算符操作数个数",
    "source_topic": "重载运算符？"
  },
  {
    "head": "重载运算符",
    "relation": "限制",
    "tail": "优先级和结合律与内置类型一致",
    "source_topic": "重载运算符？"
  },
  {
    "head": "重载运算符",
    "relation": "分类",
    "tail": "成员运算符",
    "source_topic": "重载运算符？"
  },
  {
    "head": "重载运算符",
    "relation": "分类",
    "tail": "非成员运算符",
    "source_topic": "重载运算符？"
  },
  {
    "head": "成员运算符",
    "relation": "特性",
    "tail": "比非成员运算符少一个参数",
    "source_topic": "重载运算符？"
  },
  {
    "head": "下标运算符",
    "relation": "必须",
    "tail": "成员运算符",
    "source_topic": "重载运算符？"
  },
  {
    "head": "箭头运算符",
    "relation": "必须",
    "tail": "类的成员",
    "source_topic": "重载运算符？"
  },
  {
    "head": "重载运算符",
    "relation": "目的",
    "tail": "实现类的多态性",
    "source_topic": "重载运算符？"
  },
  {
    "head": "成员运算符函数",
    "relation": "特性",
    "tail": "this绑定到左侧运算符对象",
    "source_topic": "重载运算符？"
  },
  {
    "head": "成员运算符函数",
    "relation": "特性",
    "tail": "至少含有一个类类型的参数",
    "source_topic": "重载运算符？"
  },
  {
    "head": "运算符重载",
    "relation": "如何推断",
    "tail": "从参数的个数推断运算符类型",
    "source_topic": "重载运算符？"
  },
  {
    "head": "下标运算符",
    "relation": "返回值",
    "tail": "所访问元素的引用",
    "source_topic": "重载运算符？"
  },
  {
    "head": "下标运算符",
    "relation": "建议",
    "tail": "定义常量版本和非常量版本",
    "source_topic": "重载运算符？"
  },
  {
    "head": "箭头运算符",
    "relation": "返回值",
    "tail": "类的指针",
    "source_topic": "重载运算符？"
  },
  {
    "head": "运算符重载",
    "relation": "适用",
    "tail": "一元运算符",
    "source_topic": "重载运算符？"
  },
  {
    "head": "运算符重载",
    "relation": "适用",
    "tail": "二元运算符",
    "source_topic": "重载运算符？"
  },
  {
    "head": "函数重载",
    "relation": "匹配原则",
    "tail": "名字查找",
    "source_topic": "函数重载函数匹配原则"
  },
  {
    "head": "函数重载",
    "relation": "匹配原则",
    "tail": "确定候选函数",
    "source_topic": "函数重载函数匹配原则"
  },
  {
    "head": "函数重载",
    "relation": "匹配原则",
    "tail": "寻找最佳匹配",
    "source_topic": "函数重载函数匹配原则"
  },
  {
    "head": "变量声明",
    "relation": "区别",
    "tail": "变量定义",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "变量声明",
    "relation": "不分配内存",
    "tail": "变量定义",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "函数声明",
    "relation": "区别",
    "tail": "函数定义",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "函数声明",
    "relation": "告知编译器存在",
    "tail": "函数定义",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "函数定义",
    "relation": "实现过程",
    "tail": "函数体",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "C++类型转换",
    "relation": "分类",
    "tail": "static_cast",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "C++类型转换",
    "relation": "分类",
    "tail": "const_cast",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "C++类型转换",
    "relation": "分类",
    "tail": "dynamic_cast",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "static_cast",
    "relation": "用于",
    "tail": "基本数据类型之间的转换",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "static_cast",
    "relation": "特性",
    "tail": "上行转换是安全的",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "dynamic_cast",
    "relation": "用于",
    "tail": "继承体系中的安全向下转型",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "dynamic_cast",
    "relation": "依赖",
    "tail": "运行时类型信息（RTTI）",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "dynamic_cast",
    "relation": "要求",
    "tail": "类型必须包含虚函数",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "RTTI",
    "relation": "实现方式",
    "tail": "VTABLE",
    "source_topic": "C++类型转换有四种"
  },
  {
    "head": "静态全局变量",
    "relation": "作用域限制",
    "tail": "定义该变量的源文件内",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "非静态全局变量",
    "relation": "作用域",
    "tail": "整个源程序",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "静态全局变量",
    "relation": "存储方式",
    "tail": "静态存储方式",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "非静态全局变量",
    "relation": "存储方式",
    "tail": "静态存储方式",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "静态全局变量",
    "relation": "初始化次数",
    "tail": "只初始化一次",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "static函数",
    "relation": "作用域",
    "tail": "当前源文件",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "普通函数",
    "relation": "作用域",
    "tail": "整个程序",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "static函数",
    "relation": "内存存储",
    "tail": "只有一份",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "普通函数",
    "relation": "内存存储",
    "tail": "每个被调用中维持一份拷贝",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "局部变量",
    "relation": "存储位置",
    "tail": "堆栈",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "静态区",
    "source_topic": "全局变量和static变量的区别"
  },
  {
    "head": "静态成员变量",
    "relation": "生命周期",
    "tail": "从类被加载开始到类被卸载",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "普通成员变量",
    "relation": "生命周期",
    "tail": "从对象创建到对象结束",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "静态成员变量",
    "relation": "共享方式",
    "tail": "全类共享",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "普通成员变量",
    "relation": "共享方式",
    "tail": "每个对象单独享用",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "普通成员变量",
    "relation": "存储位置",
    "tail": "栈或堆",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "静态成员变量",
    "relation": "存储位置",
    "tail": "静态全局区",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "普通成员变量",
    "relation": "初始化位置",
    "tail": "类中初始化",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "静态成员变量",
    "relation": "初始化位置",
    "tail": "类外初始化",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "静态成员变量",
    "relation": "核心特性",
    "tail": "可以作为默认实参",
    "source_topic": "静态成员与普通成员的区别"
  },
  {
    "head": "ifdef",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "说一下理解 ifdef endif"
  },
  {
    "head": "endif",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "说一下理解 ifdef endif"
  },
  {
    "head": "条件编译",
    "relation": "解决",
    "tail": "源程序中所有行都参加编译的问题",
    "source_topic": "说一下理解 ifdef endif"
  },
  {
    "head": "条件编译",
    "relation": "实现",
    "tail": "对一部分内容指定编译条件",
    "source_topic": "说一下理解 ifdef endif"
  },
  {
    "head": "条件编译",
    "relation": "包含",
    "tail": "ifdef",
    "source_topic": "说一下理解 ifdef endif"
  },
  {
    "head": "条件编译",
    "relation": "包含",
    "tail": "endif",
    "source_topic": "说一下理解 ifdef endif"
  },
  {
    "head": "头文件",
    "relation": "导致",
    "tail": "重定义错误",
    "source_topic": "denif"
  },
  {
    "head": "头文件",
    "relation": "使用",
    "tail": "#define",
    "source_topic": "denif"
  },
  {
    "head": "头文件",
    "relation": "使用",
    "tail": "#ifndef",
    "source_topic": "denif"
  },
  {
    "head": "头文件",
    "relation": "使用",
    "tail": "#ifdef",
    "source_topic": "denif"
  },
  {
    "head": "头文件",
    "relation": "使用",
    "tail": "#endif",
    "source_topic": "denif"
  },
  {
    "head": "隐式转换",
    "relation": "属于",
    "tail": "C++类型转换",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "隐式转换",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "C++",
    "relation": "提供",
    "tail": "explicit关键字",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "explicit关键字",
    "relation": "作用",
    "tail": "禁止隐式转换",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "构造函数",
    "relation": "定义",
    "tail": "隐式转换机制",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "构造函数",
    "relation": "限制",
    "tail": "一个实参",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "explicit关键字",
    "relation": "适用",
    "tail": "一个实参的构造函数",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "隐式转换",
    "relation": "发生于",
    "tail": "基本数据类型之间",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "隐式转换",
    "relation": "发生于",
    "tail": "自定义对象之间",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "基本数据类型转换",
    "relation": "基于",
    "tail": "取值范围",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "隐式转换",
    "relation": "方向",
    "tail": "从小到大",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "子类对象",
    "relation": "隐式转换为",
    "tail": "父类对象",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "C++",
    "relation": "特性",
    "tail": "强类型语言",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "隐式转换",
    "relation": "带来",
    "tail": "便捷性",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "隐式转换",
    "relation": "解决",
    "tail": "类型转换的隐式行为",
    "source_topic": "隐式转换，如何消除隐式转换？"
  },
  {
    "head": "C++",
    "relation": "允许",
    "tail": "多重继承",
    "source_topic": "多继承的优缺点，作为一个开发者怎么看待多继承"
  },
  {
    "head": "多重继承",
    "relation": "属于",
    "tail": "继承结构",
    "source_topic": "多继承的优缺点，作为一个开发者怎么看待多继承"
  },
  {
    "head": "多重继承",
    "relation": "优点",
    "tail": "对象可以调用多个基类中的接口",
    "source_topic": "多继承的优缺点，作为一个开发者怎么看待多继承"
  },
  {
    "head": "多重继承",
    "relation": "缺点",
    "tail": "可能出现二义性",
    "source_topic": "多继承的优缺点，作为一个开发者怎么看待多继承"
  },
  {
    "head": "二义性",
    "relation": "解决方式",
    "tail": "使用全局符确定调用哪一份拷贝",
    "source_topic": "多继承的优缺点，作为一个开发者怎么看待多继承"
  },
  {
    "head": "虚拟继承",
    "relation": "解决",
    "tail": "多重继承中的二义性",
    "source_topic": "多继承的优缺点，作为一个开发者怎么看待多继承"
  },
  {
    "head": "前置++it",
    "relation": "返回类型",
    "tail": "引用",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "后置it++",
    "relation": "导致",
    "tail": "临时对象产生",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "临时对象产生",
    "relation": "导致",
    "tail": "效率降低",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "C++异常处理机制",
    "relation": "包含",
    "tail": "try",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "C++异常处理机制",
    "relation": "包含",
    "tail": "throw",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "C++异常处理机制",
    "relation": "包含",
    "tail": "catch",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "try",
    "relation": "功能",
    "tail": "检查异常",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "throw",
    "relation": "功能",
    "tail": "抛出异常",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "catch",
    "relation": "功能",
    "tail": "捕获异常",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "运行时错误",
    "relation": "解决",
    "tail": "C++异常处理机制",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "语法错误",
    "relation": "属于",
    "tail": "编译错误",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "运行时错误",
    "relation": "属于",
    "tail": "异常情况",
    "source_topic": "迭代器++it,it++哪个好，为什么"
  },
  {
    "head": "C++模板",
    "relation": "导致",
    "tail": "链接程序找不到地址",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "C++模板",
    "relation": "需要",
    "tail": "在头文件中放置全部的声明和定义",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "模板类或函数",
    "relation": "实现时机",
    "tail": "编译调用模板的CPP文件时",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "编译器",
    "relation": "不分配存储空间",
    "tail": "模板定义",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "模板实例",
    "relation": "触发",
    "tail": "编译器生成二进制代码",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "模板定义",
    "relation": "处于等待状态",
    "tail": "直到被模板实例触发",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "链接程序",
    "relation": "无法处理",
    "tail": "模板的多重定义",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "C++模板",
    "relation": "解决",
    "tail": "链接程序找不到地址",
    "source_topic": "模板和实现可不可以不写在一个文件里面？为什么？"
  },
  {
    "head": "delete this",
    "relation": "导致",
    "tail": "不可预期的问题",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "delete this",
    "relation": "释放",
    "tail": "类对象的内存空间",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "类对象的内存空间",
    "relation": "包含",
    "tail": "数据成员",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "类对象的内存空间",
    "relation": "包含",
    "tail": "虚函数表指针",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "成员函数",
    "relation": "包含",
    "tail": "代码段",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "调用成员函数",
    "relation": "隐含传递",
    "tail": "this指针",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "delete this",
    "relation": "导致",
    "tail": "堆栈溢出",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "析构函数",
    "relation": "调用",
    "tail": "delete this",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "delete this",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "delete this",
    "relation": "导致",
    "tail": "无限递归",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "操作系统",
    "relation": "管理",
    "tail": "内存回收",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "delete this",
    "relation": "导致",
    "tail": "系统崩溃",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "内存空间",
    "relation": "暂时未被",
    "tail": "系统回收",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "访问虚函数表",
    "relation": "导致",
    "tail": "指针无效",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "访问数据成员",
    "relation": "导致",
    "tail": "随机数",
    "source_topic": "在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "堆内存泄露",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "二次释放",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "异常导致内存泄露",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "智能指针",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "shared_ptr",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "unique_ptr",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "weak_ptr",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "使用",
    "tail": "引用计数",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "特性",
    "tail": "引用计数增加1",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "特性",
    "tail": "引用计数减少1",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "特性",
    "tail": "引用计数为0时自动释放内存",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "引用计数",
    "tail": "线程安全",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "限制",
    "tail": "对象读取需要加锁",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "初始化方式",
    "tail": "构造函数",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "初始化方式",
    "tail": "make_shared函数",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "shared_ptr",
    "relation": "禁止",
    "tail": "直接赋值指针",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "特性",
    "tail": "唯一拥有其所指对象",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "实现方式",
    "tail": "禁止拷贝语义",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "实现方式",
    "tail": "移动语义",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "特性",
    "tail": "RAII特性",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "特性",
    "tail": "异常时释放动态资源",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "生命周期",
    "tail": "从创建到离开作用域",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "操作",
    "tail": "reset方法",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "操作",
    "tail": "release方法",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "unique_ptr",
    "relation": "操作",
    "tail": "移动语义转移所有权",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "智能指针",
    "relation": "底层结构",
    "tail": "引用计数",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "智能指针",
    "relation": "核心特性",
    "tail": "自动管理堆内存",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "weak_ptr",
    "relation": "特性",
    "tail": "不控制对象生命周期",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "weak_ptr",
    "relation": "指向",
    "tail": "shared_ptr管理的对象",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "weak_ptr",
    "relation": "构造来源",
    "tail": "shared_ptr",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "weak_ptr",
    "relation": "特性",
    "tail": "不增加引用计数",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "weak_ptr",
    "relation": "特性",
    "tail": "不减少引用计数",
    "source_topic": "智能指针的作用；"
  },
  {
    "head": "auto_ptr",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "auto_ptr作用"
  },
  {
    "head": "auto_ptr",
    "relation": "导致",
    "tail": "指针p所指向的空间得不到释放",
    "source_topic": "auto_ptr作用"
  },
  {
    "head": "auto_ptr",
    "relation": "不能管理",
    "tail": "数组",
    "source_topic": "auto_ptr作用"
  },
  {
    "head": "auto_ptr",
    "relation": "支持",
    "tail": "指针类型之间的隐式类型转换",
    "source_topic": "auto_ptr作用"
  },
  {
    "head": "auto_ptr",
    "relation": "提领操作",
    "tail": "->运算符",
    "source_topic": "auto_ptr作用"
  },
  {
    "head": "auto_ptr",
    "relation": "提供方法",
    "tail": "get()",
    "source_topic": "auto_ptr作用"
  },
  {
    "head": "auto_ptr",
    "relation": "提供方法",
    "tail": "release()",
    "source_topic": "auto_ptr作用"
  },
  {
    "head": "struct",
    "relation": "属于",
    "tail": "聚合数据类型",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "struct",
    "relation": "包含",
    "tail": "默认public权限",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "struct",
    "relation": "包含",
    "tail": "成员函数",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "struct",
    "relation": "实现",
    "tail": "面向对象编程（在C++中）",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "class",
    "relation": "实现",
    "tail": "面向对象编程",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "属于",
    "tail": "数据格式",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "限制",
    "tail": "只能同时存储一种数据类型",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "包含",
    "tail": "访问权限",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "包含",
    "tail": "成员变量",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "包含",
    "tail": "成员函数",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "限制",
    "tail": "不能包含虚函数",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "限制",
    "tail": "不能包含静态数据变量",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "限制",
    "tail": "不能作为其他类的基类",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "限制",
    "tail": "不能从其他基类派生",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "默认访问权限",
    "tail": "public",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "内存特性",
    "tail": "共享内存",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "内存大小",
    "tail": "以最大成员的大小为准",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "应用场景",
    "tail": "n选1的数据存储",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "union",
    "relation": "用法",
    "tail": "测试CPU大端或小端模式",
    "source_topic": "class、union、struct的区别"
  },
  {
    "head": "联编",
    "relation": "分类",
    "tail": "静态联编",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "联编",
    "relation": "分类",
    "tail": "动态联编",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "静态联编",
    "relation": "定义",
    "tail": "联编工作在编译阶段完成",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "静态联编",
    "relation": "别称",
    "tail": "早期联编",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "静态联编",
    "relation": "束定阶段",
    "tail": "编译时",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "静态联编",
    "relation": "优点",
    "tail": "效率高",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "静态联编",
    "relation": "缺点",
    "tail": "灵活性差",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "定义",
    "tail": "联编在程序运行时动态地进行",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "别称",
    "tail": "晚期联编",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "别称",
    "tail": "动态束定",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "实现方式",
    "tail": "虚函数",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "优点",
    "tail": "灵活性强",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "缺点",
    "tail": "效率低",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "静态联编",
    "relation": "函数选择依据",
    "tail": "指向对象的指针或者引用的类型",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "函数选择依据",
    "tail": "对象的类型",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "实现条件",
    "tail": "动态联编的行为定义为类的虚函数",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "实现条件",
    "tail": "类之间应满足子类型关系",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "动态联编",
    "relation": "实现条件",
    "tail": "使用基类指针指向子类型的对象",
    "source_topic": "动态联编与静态联编"
  },
  {
    "head": "静态编译",
    "relation": "包含",
    "tail": "动态链接库中的函数代码",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "静态编译",
    "relation": "导致",
    "tail": "可执行文件体积增大",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "静态编译",
    "relation": "解决",
    "tail": "运行时不需要依赖动态链接库",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态编译",
    "relation": "需要附带",
    "tail": "动态链接库",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态编译",
    "relation": "优点",
    "tail": "缩小可执行文件体积",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态编译",
    "relation": "优点",
    "tail": "加快编译速度",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态编译",
    "relation": "缺点",
    "tail": "需要附带庞大的动态链接库",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态编译",
    "relation": "缺点",
    "tail": "依赖其他计算机上的运行库",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "静态连接库",
    "relation": "包含",
    "tail": "函数代码",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态链接库",
    "relation": "包含",
    "tail": "函数所在文件模块",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态链接库",
    "relation": "包含",
    "tail": "函数位置信息",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态链接库",
    "relation": "允许包含",
    "tail": "其他动态或静态链接库",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "静态连接库",
    "relation": "不允许包含",
    "tail": "其他动态或静态链接库",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态链接库",
    "relation": "执行时调用",
    "tail": "函数映射表",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态链接库",
    "relation": "执行时调入",
    "tail": "堆栈",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "静态连接库",
    "relation": "执行时留下",
    "tail": "多份函数拷贝",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "动态链接库",
    "relation": "执行时留下",
    "tail": "一份函数拷贝",
    "source_topic": "动态编译与静态编译"
  },
  {
    "head": "交换两个数",
    "relation": "实现方式",
    "tail": "算术运算",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "算术运算",
    "relation": "具体操作",
    "tail": "x = x + y",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "算术运算",
    "relation": "具体操作",
    "tail": "y = x - y",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "算术运算",
    "relation": "具体操作",
    "tail": "x = x - y",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "交换两个数",
    "relation": "实现方式",
    "tail": "异或运算",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "异或运算",
    "relation": "具体操作",
    "tail": "x = x^y",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "异或运算",
    "relation": "具体操作",
    "tail": "y = x^y",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "异或运算",
    "relation": "具体操作",
    "tail": "x = x^y",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "异或运算",
    "relation": "简写形式",
    "tail": "x ^= y ^= x",
    "source_topic": "在不使用额外空间的情况下，交换两个数？"
  },
  {
    "head": "strcpy",
    "relation": "复制内容限制",
    "tail": "字符串",
    "source_topic": "strcpy和memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "复制内容限制",
    "tail": "任意内容",
    "source_topic": "strcpy和memcpy的区别"
  },
  {
    "head": "strcpy",
    "relation": "复制方法",
    "tail": "遇到结束符\\0停止",
    "source_topic": "strcpy和memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "复制方法",
    "tail": "根据指定长度复制",
    "source_topic": "strcpy和memcpy的区别"
  },
  {
    "head": "strcpy",
    "relation": "用途",
    "tail": "复制字符串",
    "source_topic": "strcpy和memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "用途",
    "tail": "复制其他类型数据",
    "source_topic": "strcpy和memcpy的区别"
  },
  {
    "head": "argv",
    "relation": "属于",
    "tail": "char指针数组",
    "source_topic": "执行int main(int argc, char *argv[])时的内存结构"
  },
  {
    "head": "argc",
    "relation": "表示",
    "tail": "命令行参数个数",
    "source_topic": "执行int main(int argc, char *argv[])时的内存结构"
  },
  {
    "head": "argv",
    "relation": "存储",
    "tail": "命令行参数",
    "source_topic": "执行int main(int argc, char *argv[])时的内存结构"
  },
  {
    "head": "argv",
    "relation": "第一个元素",
    "tail": "程序名称",
    "source_topic": "执行int main(int argc, char *argv[])时的内存结构"
  },
  {
    "head": "volatile",
    "relation": "属于",
    "tail": "类型修饰符",
    "source_topic": "volatile关键字的作用？"
  },
  {
    "head": "volatile",
    "relation": "作用",
    "tail": "防止编译器优化变量访问",
    "source_topic": "volatile关键字的作用？"
  },
  {
    "head": "volatile",
    "relation": "应用",
    "tail": "中断服务程序中修改的变量",
    "source_topic": "volatile关键字的作用？"
  },
  {
    "head": "volatile",
    "relation": "应用",
    "tail": "多任务环境下共享的标志",
    "source_topic": "volatile关键字的作用？"
  },
  {
    "head": "volatile",
    "relation": "应用",
    "tail": "存储器映射的硬件寄存器",
    "source_topic": "volatile关键字的作用？"
  },
  {
    "head": "共同体",
    "relation": "特性",
    "tail": "所有数据成员共享一段内存",
    "source_topic": "讲讲大端小端，如何检测（三种方法）"
  },
  {
    "head": "共同体",
    "relation": "特性",
    "tail": "成员数据都有相同的首地址",
    "source_topic": "讲讲大端小端，如何检测（三种方法）"
  },
  {
    "head": "共同体",
    "relation": "大小计算",
    "tail": "大小为最大数据成员的大小",
    "source_topic": "讲讲大端小端，如何检测（三种方法）"
  },
  {
    "head": "大端模式",
    "relation": "检测方法",
    "tail": "用共同体进行判断",
    "source_topic": "讲讲大端小端，如何检测（三种方法）"
  },
  {
    "head": "小端模式",
    "relation": "检测方法",
    "tail": "用共同体进行判断",
    "source_topic": "讲讲大端小端，如何检测（三种方法）"
  },
  {
    "head": "大端模式",
    "relation": "存储方式",
    "tail": "将1放在最高位",
    "source_topic": "讲讲大端小端，如何检测（三种方法）"
  },
  {
    "head": "小端模式",
    "relation": "存储方式",
    "tail": "将1放在最低位",
    "source_topic": "讲讲大端小端，如何检测（三种方法）"
  },
  {
    "head": "VS编译器",
    "relation": "支持",
    "tail": "调试功能",
    "source_topic": "查看内存的方法"
  },
  {
    "head": "调试功能",
    "relation": "包含",
    "tail": "断点设置",
    "source_topic": "查看内存的方法"
  },
  {
    "head": "调试功能",
    "relation": "包含",
    "tail": "内存窗口查看",
    "source_topic": "查看内存的方法"
  },
  {
    "head": "内存窗口查看",
    "relation": "属于",
    "tail": "调试工具",
    "source_topic": "查看内存的方法"
  },
  {
    "head": "C++标准库",
    "relation": "分为",
    "tail": "标准函数库",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "C++标准库",
    "relation": "分为",
    "tail": "面向对象类库",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "标准函数库",
    "relation": "继承自",
    "tail": "C语言",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "输入/输出 I/O",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "字符串和字符处理",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "数学",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "日期和本地化",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "动态分配",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "其他",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "宽字符函数",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "标准的 C++ I/O 类",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "String 类",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "数值类",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "STL容器类",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "STL算法",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "STL函数对象",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "STL迭代器",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "STL分配器",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "本地化库",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "异常处理类",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "面向对象类库",
    "relation": "包含",
    "tail": "杂项支持库",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "string",
    "relation": "属于",
    "tail": "C++标准库",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "string",
    "relation": "可以初始化",
    "tail": "const char*",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "string",
    "relation": "转换为",
    "tail": "const char*",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "string",
    "relation": "转换为",
    "tail": "char*",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "const char*",
    "relation": "转换为",
    "tail": "string",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "const char*",
    "relation": "转换为",
    "tail": "char*",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "char*",
    "relation": "转换为",
    "tail": "const char*",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "char*",
    "relation": "转换为",
    "tail": "string",
    "source_topic": "标准库是什么？"
  },
  {
    "head": "new operator",
    "relation": "包含",
    "tail": "operator new",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "new operator",
    "relation": "包含",
    "tail": "placement new",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "operator new",
    "relation": "功能相似",
    "tail": "malloc",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "operator delete",
    "relation": "功能相似",
    "tail": "free",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "delete operator",
    "relation": "对应",
    "tail": "new operator",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "delete operator",
    "relation": "包含",
    "tail": "operator delete",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "placement new",
    "relation": "用于",
    "tail": "在给定内存中初始化对象",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "operator new",
    "relation": "用于",
    "tail": "申请内存",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "delete operator",
    "relation": "用于",
    "tail": "析构对象和释放内存",
    "source_topic": "new、delete、operator new、operator delete、placement new、placement delete"
  },
  {
    "head": "拷贝构造函数",
    "relation": "作用",
    "tail": "复制对象",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "导致",
    "tail": "无限递归调用",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "导致",
    "tail": "内存溢出",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "值传递",
    "relation": "触发",
    "tail": "拷贝构造函数调用",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "引用传递",
    "relation": "避免",
    "tail": "拷贝构造函数调用",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "类类型",
    "relation": "传递方式",
    "tail": "值传递",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "类类型",
    "relation": "传递方式",
    "tail": "引用传递",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "参数传递",
    "relation": "本质",
    "tail": "传递值",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "引用传递",
    "relation": "传递方式",
    "tail": "地址值",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "指针类型",
    "relation": "属于",
    "tail": "简单类型",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "简单类型",
    "relation": "传递方式",
    "tail": "赋值拷贝",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "参数传递方式",
    "tail": "引用传递",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "初始化对象",
    "tail": "非引用类类型对象",
    "source_topic": "为什么拷贝构造函数必须传引用不能传值？"
  },
  {
    "head": "C++标准",
    "relation": "规定",
    "tail": "不允许对象大小为0",
    "source_topic": "空类的大小是多少？为什么？"
  },
  {
    "head": "C++空类",
    "relation": "保证",
    "tail": "每个实例有独一无二的地址",
    "source_topic": "空类的大小是多少？为什么？"
  },
  {
    "head": "C++空类",
    "relation": "分配",
    "tail": "一个字节大小",
    "source_topic": "空类的大小是多少？为什么？"
  },
  {
    "head": "C++类带有虚函数",
    "relation": "包含",
    "tail": "vptr",
    "source_topic": "空类的大小是多少？为什么？"
  },
  {
    "head": "vptr",
    "relation": "指向",
    "tail": "虚函数表",
    "source_topic": "空类的大小是多少？为什么？"
  },
  {
    "head": "C++类带有虚函数",
    "relation": "大小取决于",
    "tail": "指针大小",
    "source_topic": "空类的大小是多少？为什么？"
  },
  {
    "head": "Visual Studio",
    "relation": "设置",
    "tail": "C++空类大小为1",
    "source_topic": "空类的大小是多少？为什么？"
  },
  {
    "head": "引用参数",
    "relation": "提高",
    "tail": "程序运行速度",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "引用参数",
    "relation": "允许修改",
    "tail": "调用函数中的数据对象",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "内置数据类型",
    "relation": "传递方式",
    "tail": "值传递",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "数组",
    "relation": "传递方式",
    "tail": "指针",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "数组",
    "relation": "指针类型",
    "tail": "const指针",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "较大的结构",
    "relation": "传递方式",
    "tail": "const指针或引用",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "类对象",
    "relation": "传递方式",
    "tail": "const引用",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "修改数据的函数",
    "relation": "传递方式",
    "tail": "指针",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "数组",
    "relation": "传递方式",
    "tail": "指针（唯一选择）",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "结构",
    "relation": "传递方式",
    "tail": "引用或指针",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "类对象",
    "relation": "传递方式",
    "tail": "引用",
    "source_topic": "你什么情况用指针当参数，什么时候用引用，为什么？"
  },
  {
    "head": "大内存申请",
    "relation": "采用",
    "tail": "堆申请空间",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "堆申请空间",
    "relation": "实现方式",
    "tail": "new",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "局部变量",
    "relation": "存储位置",
    "tail": "栈区",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "全局存储区",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "静态变量",
    "relation": "存储位置",
    "tail": "静态存储区",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "C++变量名",
    "relation": "不存储于",
    "tail": "汇编代码",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "变量名",
    "relation": "作用",
    "tail": "方便编译器生成汇编代码",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "变量名",
    "relation": "作用",
    "tail": "方便人阅读",
    "source_topic": "大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"
  },
  {
    "head": "X86结构",
    "relation": "采用",
    "tail": "小端模式",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "KEIL C51",
    "relation": "采用",
    "tail": "大端模式",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "ARM",
    "relation": "可能采用",
    "tail": "小端模式",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "DSP",
    "relation": "可能采用",
    "tail": "小端模式",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "部分ARM处理器",
    "relation": "支持",
    "tail": "硬件选择大端或小端模式",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "网络字节序",
    "relation": "定义",
    "tail": "大端模式",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "主机字节序",
    "relation": "可能为",
    "tail": "小端模式",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "htonl函数",
    "relation": "解决",
    "tail": "不同系统间字节序不一致的问题",
    "source_topic": "为什么会有大端小端，htol这一类函数的作用"
  },
  {
    "head": "静态函数",
    "relation": "无法成为",
    "tail": "虚函数",
    "source_topic": "静态函数能定义为虚函数吗？常函数?"
  },
  {
    "head": "静态函数",
    "relation": "不包含",
    "tail": "this指针",
    "source_topic": "静态函数能定义为虚函数吗？常函数?"
  },
  {
    "head": "虚函数",
    "relation": "依赖",
    "tail": "vptr",
    "source_topic": "静态函数能定义为虚函数吗？常函数?"
  },
  {
    "head": "vptr",
    "relation": "指向",
    "tail": "vtable",
    "source_topic": "静态函数能定义为虚函数吗？常函数?"
  },
  {
    "head": "vtable",
    "relation": "保存",
    "tail": "虚函数地址",
    "source_topic": "静态函数能定义为虚函数吗？常函数?"
  },
  {
    "head": "静态函数",
    "relation": "无法访问",
    "tail": "vptr",
    "source_topic": "静态函数能定义为虚函数吗？常函数?"
  },
  {
    "head": "静态函数",
    "relation": "无法成为",
    "tail": "常函数",
    "source_topic": "静态函数能定义为虚函数吗？常函数?"
  },
  {
    "head": "this指针",
    "relation": "属于",
    "tail": "隐含参数",
    "source_topic": "this指针调用成员变量时，堆栈会发生什么变化？"
  },
  {
    "head": "this指针",
    "relation": "传递方式",
    "tail": "对象地址",
    "source_topic": "this指针调用成员变量时，堆栈会发生什么变化？"
  },
  {
    "head": "非静态成员函数",
    "relation": "隐含参数传递",
    "tail": "this指针",
    "source_topic": "this指针调用成员变量时，堆栈会发生什么变化？"
  },
  {
    "head": "this指针",
    "relation": "作用",
    "tail": "访问非静态成员变量",
    "source_topic": "this指针调用成员变量时，堆栈会发生什么变化？"
  },
  {
    "head": "this指针",
    "relation": "入栈顺序",
    "tail": "首先入栈",
    "source_topic": "this指针调用成员变量时，堆栈会发生什么变化？"
  },
  {
    "head": "成员函数参数",
    "relation": "入栈顺序",
    "tail": "从右向左入栈",
    "source_topic": "this指针调用成员变量时，堆栈会发生什么变化？"
  },
  {
    "head": "函数返回地址",
    "relation": "入栈顺序",
    "tail": "最后入栈",
    "source_topic": "this指针调用成员变量时，堆栈会发生什么变化？"
  },
  {
    "head": "静态绑定",
    "relation": "绑定的是",
    "tail": "对象的静态类型",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态绑定",
    "relation": "发生在",
    "tail": "编译期",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态类型",
    "relation": "是在",
    "tail": "编译期确定的",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态绑定",
    "relation": "绑定的是",
    "tail": "对象的动态类型",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态绑定",
    "relation": "发生在",
    "tail": "运行期",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态类型",
    "relation": "是在",
    "tail": "运行期决定的",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态类型",
    "relation": "可以更改",
    "tail": "对象的动态类型",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态类型",
    "relation": "无法更改",
    "tail": "对象的静态类型",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态变量",
    "relation": "用于",
    "tail": "计数器",
    "source_topic": "设计一个类计算子类的个数"
  },
  {
    "head": "构造函数",
    "relation": "触发",
    "tail": "count +1",
    "source_topic": "设计一个类计算子类的个数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "触发",
    "tail": "count +1",
    "source_topic": "设计一个类计算子类的个数"
  },
  {
    "head": "复制构造函数",
    "relation": "触发",
    "tail": "count +1",
    "source_topic": "设计一个类计算子类的个数"
  },
  {
    "head": "析构函数",
    "relation": "触发",
    "tail": "count -1",
    "source_topic": "设计一个类计算子类的个数"
  },
  {
    "head": "错误列表",
    "relation": "定位方式",
    "tail": "编辑窗口",
    "source_topic": "怎么快速定位错误出现的地方"
  },
  {
    "head": "错误信息",
    "relation": "包含",
    "tail": "行号",
    "source_topic": "怎么快速定位错误出现的地方"
  },
  {
    "head": "复杂模板错误",
    "relation": "解决方式",
    "tail": "生成输出窗口",
    "source_topic": "怎么快速定位错误出现的地方"
  },
  {
    "head": "错误位置",
    "relation": "确定方式",
    "tail": "最靠后的引用位置",
    "source_topic": "怎么快速定位错误出现的地方"
  },
  {
    "head": "虚函数",
    "relation": "导致",
    "tail": "虚函数表",
    "source_topic": "虚函数的代价？"
  },
  {
    "head": "带有虚函数的类",
    "relation": "包含",
    "tail": "虚函数表",
    "source_topic": "虚函数的代价？"
  },
  {
    "head": "带有虚函数的类",
    "relation": "导致",
    "tail": "对象包含指向虚表的指针",
    "source_topic": "虚函数的代价？"
  },
  {
    "head": "虚函数",
    "relation": "限制",
    "tail": "内敛函数",
    "source_topic": "虚函数的代价？"
  },
  {
    "head": "类对象",
    "relation": "包含",
    "tail": "非静态成员变量大小",
    "source_topic": "类对象的大小"
  },
  {
    "head": "类对象",
    "relation": "不包含",
    "tail": "静态成员",
    "source_topic": "类对象的大小"
  },
  {
    "head": "类对象",
    "relation": "不包含",
    "tail": "成员函数",
    "source_topic": "类对象的大小"
  },
  {
    "head": "类对象",
    "relation": "需要进行",
    "tail": "内存对齐操作",
    "source_topic": "类对象的大小"
  },
  {
    "head": "类对象",
    "relation": "包含",
    "tail": "vptr指针",
    "source_topic": "类对象的大小"
  },
  {
    "head": "vptr指针",
    "relation": "增加",
    "tail": "指针大小",
    "source_topic": "类对象的大小"
  },
  {
    "head": "派生类",
    "relation": "包含",
    "tail": "基类部分的数据成员",
    "source_topic": "类对象的大小"
  },
  {
    "head": "派生类",
    "relation": "进行",
    "tail": "空间扩展",
    "source_topic": "类对象的大小"
  },
  {
    "head": "移动构造函数",
    "relation": "设计初衷",
    "tail": "避免新空间分配以降低构造成本",
    "source_topic": "移动构造函数"
  },
  {
    "head": "移动构造函数",
    "relation": "与拷贝构造函数的区别",
    "tail": "采用浅层复制处理指针",
    "source_topic": "移动构造函数"
  },
  {
    "head": "移动构造函数",
    "relation": "处理场景",
    "tail": "用a初始化b后，a将被析构",
    "source_topic": "移动构造函数"
  },
  {
    "head": "移动构造函数",
    "relation": "功能",
    "tail": "实现对象值的真实转移",
    "source_topic": "移动构造函数"
  },
  {
    "head": "移动赋值操作",
    "relation": "功能",
    "tail": "实现对象值的真实转移",
    "source_topic": "移动构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "导致",
    "tail": "成员对象的默认构造函数被调用",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "解决",
    "tail": "成员对象无法被初始化",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "导致",
    "tail": "基类的默认构造函数被调用",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "解决",
    "tail": "基类构造函数无法被调用",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "导致",
    "tail": "虚函数指针被初始化",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "解决",
    "tail": "虚函数指针无法被初始化",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "导致",
    "tail": "虚基类的构造函数被调用",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成构造函数",
    "relation": "解决",
    "tail": "虚基类构造函数无法被调用",
    "source_topic": "何时需要合成构造函数"
  },
  {
    "head": "合成复制构造函数",
    "relation": "触发条件",
    "tail": "类没有拷贝构造函数但含有虚基类",
    "source_topic": "何时需要合成复制构造函数"
  },
  {
    "head": "对象初始化",
    "relation": "场景",
    "tail": "对象作为参数传递给函数",
    "source_topic": "何时需要合成复制构造函数"
  },
  {
    "head": "对象初始化",
    "relation": "场景",
    "tail": "函数返回类对象",
    "source_topic": "何时需要合成复制构造函数"
  },
  {
    "head": "成员初始化列表",
    "relation": "用于",
    "tail": "初始化引用成员变量",
    "source_topic": "何时需要成员初始化列表？过程是什么？"
  },
  {
    "head": "成员初始化列表",
    "relation": "用于",
    "tail": "初始化const成员变量",
    "source_topic": "何时需要成员初始化列表？过程是什么？"
  },
  {
    "head": "成员初始化列表",
    "relation": "用于",
    "tail": "调用基类构造函数",
    "source_topic": "何时需要成员初始化列表？过程是什么？"
  },
  {
    "head": "成员初始化列表",
    "relation": "用于",
    "tail": "调用成员类构造函数",
    "source_topic": "何时需要成员初始化列表？过程是什么？"
  },
  {
    "head": "编译器",
    "relation": "执行",
    "tail": "初始化列表中的初始化操作",
    "source_topic": "何时需要成员初始化列表？过程是什么？"
  },
  {
    "head": "初始化列表中的项目顺序",
    "relation": "由",
    "tail": "类中成员声明顺序决定",
    "source_topic": "何时需要成员初始化列表？过程是什么？"
  },
  {
    "head": "初始化列表中的项目顺序",
    "relation": "不由",
    "tail": "初始化列表中的排列顺序决定",
    "source_topic": "何时需要成员初始化列表？过程是什么？"
  },
  {
    "head": "析构函数",
    "relation": "执行过程",
    "tail": "析构函数函数体被执行",
    "source_topic": "程序员定义的析构函数被扩展的过程？"
  },
  {
    "head": "析构函数",
    "relation": "涉及",
    "tail": "vptr被重新定义",
    "source_topic": "程序员定义的析构函数被扩展的过程？"
  },
  {
    "head": "析构函数",
    "relation": "涉及",
    "tail": "虚基类析构函数",
    "source_topic": "程序员定义的析构函数被扩展的过程？"
  },
  {
    "head": "派生类构造函数",
    "relation": "调用",
    "tail": "虚基类构造函数",
    "source_topic": "构造函数的执行算法？"
  },
  {
    "head": "派生类构造函数",
    "relation": "调用",
    "tail": "上一层基类构造函数",
    "source_topic": "构造函数的执行算法？"
  },
  {
    "head": "成员初始化列表",
    "relation": "展开",
    "tail": "构造函数体内",
    "source_topic": "构造函数的执行算法？"
  },
  {
    "head": "成员初始化列表",
    "relation": "依赖",
    "tail": "vptr设定",
    "source_topic": "构造函数的执行算法？"
  },
  {
    "head": "构造函数",
    "relation": "执行",
    "tail": "数据成员初始化操作",
    "source_topic": "构造函数的扩展过程？"
  },
  {
    "head": "数据成员初始化操作",
    "relation": "顺序",
    "tail": "成员声明顺序",
    "source_topic": "构造函数的扩展过程？"
  },
  {
    "head": "构造函数",
    "relation": "调用",
    "tail": "默认构造函数",
    "source_topic": "构造函数的扩展过程？"
  },
  {
    "head": "默认构造函数",
    "relation": "条件",
    "tail": "成员未出现在成员初始化列表",
    "source_topic": "构造函数的扩展过程？"
  },
  {
    "head": "构造函数",
    "relation": "调用",
    "tail": "上一层的基类构造函数",
    "source_topic": "构造函数的扩展过程？"
  },
  {
    "head": "构造函数",
    "relation": "调用",
    "tail": "虚基类的构造函数",
    "source_topic": "构造函数的扩展过程？"
  },
  {
    "head": "构造函数",
    "relation": "不能是",
    "tail": "虚函数",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "内联函数",
    "relation": "不能是",
    "tail": "虚函数",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "静态函数",
    "relation": "不能是",
    "tail": "虚函数",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "友元函数",
    "relation": "不能是",
    "tail": "虚函数",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "普通函数",
    "relation": "不能是",
    "tail": "虚函数",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "构造函数",
    "relation": "初始化",
    "tail": "虚表指针",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "虚函数",
    "relation": "需要",
    "tail": "虚表",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "内联函数",
    "relation": "替换操作",
    "tail": "编译阶段",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "虚函数",
    "relation": "确定类型",
    "tail": "运行期间",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "静态函数",
    "relation": "没有",
    "tail": "this指针",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "友元函数",
    "relation": "不属于",
    "tail": "类的成员函数",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "普通函数",
    "relation": "不属于",
    "tail": "类的成员函数",
    "source_topic": "哪些函数不能是虚函数"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "取字节运算符",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "计算",
    "tail": "声明后所占的内存数",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "计算",
    "tail": "字符串的具体长度",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "限制",
    "tail": "必须以‘\\0’结尾",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "支持",
    "tail": "类型作为参数",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "支持",
    "tail": "函数作为参数",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "限制",
    "tail": "只能用char作为参数",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "返回值",
    "tail": "字符个数乘以字符所占的字节数",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "返回值",
    "tail": "字符个数",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "字符串数组",
    "relation": "内存大小",
    "tail": "实际字符个数+1",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "整型数组",
    "relation": "内存大小",
    "tail": "实际字符个数",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "sizeof",
    "relation": "处理方式",
    "tail": "数组不退化",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "strlen",
    "relation": "处理方式",
    "tail": "数组退化为指针",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "字符",
    "relation": "占用字节数",
    "tail": "1个字节",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "整型数据",
    "relation": "占用字节数",
    "tail": "根据系统位数确定",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "32位系统",
    "relation": "整型数据占用字节数",
    "tail": "4个字节",
    "source_topic": "sizeof 和strlen 的区别"
  },
  {
    "head": "strcpy",
    "relation": "操作对象",
    "tail": "字符串",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "sprintf",
    "relation": "操作对象",
    "tail": "多种数据类型",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "操作对象",
    "tail": "任意可操作的内存地址",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "strcpy",
    "relation": "实现功能",
    "tail": "字符串变量间的拷贝",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "sprintf",
    "relation": "实现功能",
    "tail": "其他数据类型格式到字符串的转化",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "实现功能",
    "tail": "内存块间的拷贝",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "strcpy",
    "relation": "执行效率",
    "tail": "次之",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "执行效率",
    "tail": "最高",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "sprintf",
    "relation": "执行效率",
    "tail": "最低",
    "source_topic": "简述strcpy、sprintf与memcpy的区别"
  },
  {
    "head": "BIT3",
    "relation": "定义",
    "tail": "0x1 << 3",
    "source_topic": "编码实现某一变量某位清0或置1"
  },
  {
    "head": "位操作",
    "relation": "实现方式",
    "tail": "按位或运算",
    "source_topic": "编码实现某一变量某位清0或置1"
  },
  {
    "head": "位操作",
    "relation": "实现方式",
    "tail": "按位与非运算",
    "source_topic": "编码实现某一变量某位清0或置1"
  },
  {
    "head": "按位或运算",
    "relation": "作用",
    "tail": "将变量的某位置1",
    "source_topic": "编码实现某一变量某位清0或置1"
  },
  {
    "head": "按位与非运算",
    "relation": "作用",
    "tail": "将变量的某位清0",
    "source_topic": "编码实现某一变量某位清0或置1"
  },
  {
    "head": "引用",
    "relation": "传递效果相同于",
    "tail": "指针",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "避免产生",
    "tail": "实参副本",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "直接操作",
    "tail": "实参",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "一般变量传递",
    "relation": "产生",
    "tail": "形参副本",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "一般变量传递",
    "relation": "需要分配存储单元",
    "tail": "形参变量",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "对象传递",
    "relation": "调用",
    "tail": "拷贝构造函数",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "优于",
    "tail": "一般变量传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "减少",
    "tail": "空间占用",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "指针传递",
    "relation": "需要重复使用",
    "tail": "*指针变量名",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "指针传递",
    "relation": "导致",
    "tail": "程序阅读性较差",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用",
    "relation": "更清晰",
    "tail": "指针传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "避免",
    "tail": "地址传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "BOOL",
    "relation": "比较方式",
    "tail": "if ( !a )",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "BOOL",
    "relation": "比较方式",
    "tail": "if (a)",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "int",
    "relation": "比较方式",
    "tail": "if ( a == 0)",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "float",
    "relation": "比较方式",
    "tail": "if ( a - EXP)",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "pointer",
    "relation": "比较方式",
    "tail": "if ( a != NULL)",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "pointer",
    "relation": "比较方式",
    "tail": "if ( a == NULL)",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "float",
    "relation": "避免操作",
    "tail": "==",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "float",
    "relation": "避免操作",
    "tail": "!=",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "float",
    "relation": "推荐操作",
    "tail": ">=",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "float",
    "relation": "推荐操作",
    "tail": "<=",
    "source_topic": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "局部变量",
    "relation": "屏蔽",
    "tail": "全局变量",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "局部变量",
    "relation": "作用域限制",
    "tail": "循环体内",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "extern关键字",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "头文件包含",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "头文件包含",
    "relation": "错误检测阶段",
    "tail": "编译期间",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "extern关键字",
    "relation": "错误检测阶段",
    "tail": "连接期间",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "全局变量",
    "relation": "定义方式",
    "tail": "static形式",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "全局变量",
    "relation": "定义位置",
    "tail": "头文件中",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "多个.C文件",
    "relation": "允许",
    "tail": "声明同名全局变量",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "同名全局变量",
    "relation": "限制",
    "tail": "仅一个文件赋初值",
    "source_topic": "局部变量全局变量的问题？"
  },
  {
    "head": "数组",
    "relation": "内存存储方式",
    "tail": "连续存放",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组",
    "relation": "存储空间计算",
    "tail": "sizeof（数组名）",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算对象",
    "tail": "数组容量",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算对象",
    "tail": "指针变量字节数",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组",
    "relation": "底层实现",
    "tail": "指针",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组元素引用",
    "relation": "转换方式",
    "tail": "指针加偏移量",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组传递参数",
    "relation": "传递方式",
    "tail": "传递首地址",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组传递参数",
    "relation": "传递优势",
    "tail": "提高效率",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组首地址",
    "relation": "特性",
    "tail": "固定",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "指针原地址",
    "relation": "特性",
    "tail": "不固定",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "C++",
    "relation": "阻止",
    "tail": "类被实例化",
    "source_topic": "C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"
  },
  {
    "head": "构造函数",
    "relation": "声明为",
    "tail": "private",
    "source_topic": "C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"
  },
  {
    "head": "构造函数",
    "relation": "用于",
    "tail": "阻止类被实例化",
    "source_topic": "C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"
  },
  {
    "head": "抽象基类",
    "relation": "属于",
    "tail": "C++类",
    "source_topic": "C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "阻止生成",
    "tail": "编译器",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "拷贝赋值函数",
    "relation": "阻止生成",
    "tail": "编译器",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "设置为",
    "tail": "private",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "拷贝赋值函数",
    "relation": "设置为",
    "tail": "private",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "private函数",
    "relation": "导致",
    "tail": "连接错误",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "base类",
    "relation": "包含",
    "tail": "拷贝构造函数",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "base类",
    "relation": "包含",
    "tail": "拷贝赋值函数",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "派生类",
    "relation": "阻止生成",
    "tail": "拷贝构造函数",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "派生类",
    "relation": "阻止生成",
    "tail": "拷贝赋值函数",
    "source_topic": "如何禁止自动生成拷贝构造函数？"
  },
  {
    "head": "assert",
    "relation": "作用",
    "tail": "计算表达式并判断其真假",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "assert",
    "relation": "导致",
    "tail": "程序终止",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "assert",
    "relation": "调用",
    "tail": "abort",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "assert",
    "relation": "打印错误信息",
    "tail": "stderr",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "NDEBUG",
    "relation": "控制",
    "tail": "assert()行为",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "NDEBUG",
    "relation": "定义",
    "tail": "Standard C",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "assert",
    "relation": "属于",
    "tail": "Standard C",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "assert",
    "relation": "避免运行时开销",
    "tail": "定义NDEBUG",
    "source_topic": "include <assert.h>"
  },
  {
    "head": "Debug",
    "relation": "包含",
    "tail": "调试信息",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "不进行",
    "tail": "优化",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "生成文件",
    "tail": ".exe",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "生成文件",
    "tail": ".dll",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "生成文件",
    "tail": ".pdb",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Release",
    "relation": "不包含",
    "tail": "调试信息",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Release",
    "relation": "进行",
    "tail": "优化",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Release",
    "relation": "生成文件",
    "tail": ".exe",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Release",
    "relation": "生成文件",
    "tail": ".dll",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "属于",
    "tail": "编译选项集合",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Release",
    "relation": "属于",
    "tail": "编译选项集合",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "区别",
    "tail": "Release",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "优化",
    "tail": "复杂化调试",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Release",
    "relation": "优化",
    "tail": "提升速度",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "Debug",
    "relation": "核心特性",
    "tail": "便于调试",
    "source_topic": "Denug和release的区别"
  },
  {
    "head": "main函数",
    "relation": "返回值类型必须是",
    "tail": "int",
    "source_topic": "main函数有没有返回值"
  },
  {
    "head": "main函数",
    "relation": "传递返回值给",
    "tail": "程序激活者",
    "source_topic": "main函数有没有返回值"
  },
  {
    "head": "程序激活者",
    "relation": "表示程序正常退出",
    "tail": "main函数",
    "source_topic": "main函数有没有返回值"
  },
  {
    "head": "模板函数",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "写一个比较大小的模板函数"
  },
  {
    "head": "全局对象",
    "relation": "导致",
    "tail": "构造函数在main之前执行",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "全局对象",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "静态对象",
    "relation": "导致",
    "tail": "构造函数在main之前执行",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "全局对象",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "main函数",
    "relation": "执行之后",
    "tail": "全局对象析构函数",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "全局对象",
    "relation": "包含",
    "tail": "析构函数",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "_onexit",
    "relation": "注册",
    "tail": "函数在main之后执行",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "系统初始化",
    "relation": "包含",
    "tail": "设置栈指针",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "系统初始化",
    "relation": "包含",
    "tail": "将未初始化部分的全局变量赋初值",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "系统初始化",
    "relation": "包含",
    "tail": "全局对象初始化",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "main函数",
    "relation": "接收",
    "tail": "argc和argv参数",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "全局对象",
    "relation": "执行顺序",
    "tail": "先于main函数",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "静态对象",
    "relation": "执行顺序",
    "tail": "先于main函数",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "main函数",
    "relation": "执行之后",
    "tail": "全局对象析构函数执行",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "main函数",
    "relation": "执行之后",
    "tail": "_onexit注册的函数执行",
    "source_topic": "c++怎么实现一个函数先于main函数运行"
  },
  {
    "head": "纯虚函数",
    "relation": "定义特性",
    "tail": "只有定义没有实现",
    "source_topic": "虚函数与纯虚函数的区别在于"
  },
  {
    "head": "虚函数",
    "relation": "定义特性",
    "tail": "既有定义又有实现",
    "source_topic": "虚函数与纯虚函数的区别在于"
  },
  {
    "head": "纯虚函数",
    "relation": "类对象限制",
    "tail": "不能定义对象",
    "source_topic": "虚函数与纯虚函数的区别在于"
  },
  {
    "head": "虚函数",
    "relation": "类对象限制",
    "tail": "能定义对象",
    "source_topic": "虚函数与纯虚函数的区别在于"
  },
  {
    "head": "shared_ptr",
    "relation": "核心特性",
    "tail": "引用计数",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "shared_ptr",
    "relation": "核心特性",
    "tail": "自动释放对象",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "shared_ptr",
    "relation": "核心特性",
    "tail": "析构函数递减引用计数",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "shared_ptr",
    "relation": "核心特性",
    "tail": "引用计数为0时销毁对象",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "unique_ptr",
    "relation": "核心特性",
    "tail": "独占对象所有权",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "unique_ptr",
    "relation": "核心特性",
    "tail": "销毁时释放对象",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "weak_ptr",
    "relation": "核心特性",
    "tail": "不控制对象生存期",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "weak_ptr",
    "relation": "核心特性",
    "tail": "不修改引用计数",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "循环引用",
    "relation": "解决",
    "tail": "weak_ptr",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "weak_ptr",
    "relation": "功能类似",
    "tail": "普通指针",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "weak_ptr",
    "relation": "区别",
    "tail": "能检测对象是否已被释放",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "shared_ptr",
    "relation": "组成",
    "tail": "引用计数器",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "shared_ptr",
    "relation": "组成",
    "tail": "析构函数",
    "source_topic": "智能指针怎么用？智能指针出现循环引用怎么解决？"
  },
  {
    "head": "strcpy",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "strncpy",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "strcpy",
    "relation": "可能导致",
    "tail": "缓冲溢出",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "strncpy",
    "relation": "解决",
    "tail": "缓冲溢出",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "strcpy",
    "relation": "参数",
    "tail": "char* strDest",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "strncpy",
    "relation": "参数",
    "tail": "char* strDest",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "strncpy",
    "relation": "参数",
    "tail": "int pos",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "strcpy",
    "relation": "功能",
    "tail": "复制源字符串到目标字符串",
    "source_topic": "strcpy函数和strncpy函数的区别？哪个函数更安全？"
  },
  {
    "head": "static_cast",
    "relation": "更直接明显",
    "tail": "C语言中的转换",
    "source_topic": "为什么要用static_cast转换而不用c语言中的转换？"
  },
  {
    "head": "static_cast",
    "relation": "更安全",
    "tail": "C语言中的转换",
    "source_topic": "为什么要用static_cast转换而不用c语言中的转换？"
  },
  {
    "head": "static_cast",
    "relation": "提升可读性",
    "tail": "程序错误排查",
    "source_topic": "为什么要用static_cast转换而不用c语言中的转换？"
  },
  {
    "head": "static_cast",
    "relation": "体现程序员意图",
    "tail": "类型转换",
    "source_topic": "为什么要用static_cast转换而不用c语言中的转换？"
  },
  {
    "head": "虚函数表",
    "relation": "属于",
    "tail": "C++类对象",
    "source_topic": "成员函数里memset(this,0,sizeof(*this))会发生什么"
  },
  {
    "head": "类对象",
    "relation": "包含",
    "tail": "虚函数表指针",
    "source_topic": "成员函数里memset(this,0,sizeof(*this))会发生什么"
  },
  {
    "head": "C++类型对象",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "成员函数里memset(this,0,sizeof(*this))会发生什么"
  },
  {
    "head": "构造函数",
    "relation": "执行",
    "tail": "对象初始化",
    "source_topic": "成员函数里memset(this,0,sizeof(*this))会发生什么"
  },
  {
    "head": "对象初始化",
    "relation": "依赖",
    "tail": "构造函数体",
    "source_topic": "成员函数里memset(this,0,sizeof(*this))会发生什么"
  },
  {
    "head": "内存分配",
    "relation": "属于",
    "tail": "C++对象构造",
    "source_topic": "成员函数里memset(this,0,sizeof(*this))会发生什么"
  },
  {
    "head": "帧栈",
    "relation": "属于",
    "tail": "程序栈",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "帧栈",
    "relation": "包含",
    "tail": "起始地址",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "帧栈",
    "relation": "包含",
    "tail": "结束地址",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "esp",
    "relation": "标识",
    "tail": "结束地址",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "ebp",
    "relation": "标识",
    "tail": "起始地址",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "栈帧",
    "relation": "包含",
    "tail": "函数返回地址",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "栈帧",
    "relation": "建立在",
    "tail": "调用者的下方",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "栈帧",
    "relation": "分配空间",
    "tail": "栈指针减去一定的值",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "栈帧",
    "relation": "释放空间",
    "tail": "栈指针加上一定的值",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "备份原来的帧指针",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "调整当前的栈帧指针到栈指针位置",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "为被调用者准备栈帧",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "给临时变量分配预留内存",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "使用mov指令",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "使用push指令",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "使用pop指令",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "过程实现",
    "relation": "包含",
    "tail": "恢复被调用者寄存器的值",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "恢复寄存器值",
    "relation": "从",
    "tail": "栈帧",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "恢复寄存器值",
    "relation": "可能不在",
    "tail": "栈顶",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "释放栈帧",
    "relation": "通过",
    "tail": "将栈指针指向帧指针",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "释放栈帧",
    "relation": "采用",
    "tail": "汇编代码",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "恢复调用者栈帧",
    "relation": "通过",
    "tail": "调整栈帧两端",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "弹出返回地址",
    "relation": "用于",
    "tail": "跳出当前过程",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "call指令",
    "relation": "属于",
    "tail": "过程调用和返回指令",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "leave指令",
    "relation": "属于",
    "tail": "过程调用和返回指令",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "ret指令",
    "relation": "属于",
    "tail": "过程调用和返回指令",
    "source_topic": "方法调用的原理（栈，汇编）"
  },
  {
    "head": "回调函数",
    "relation": "属于",
    "tail": "函数指针机制",
    "source_topic": "回调函数的作用"
  },
  {
    "head": "回调函数",
    "relation": "实现方式",
    "tail": "函数指针调用",
    "source_topic": "回调函数的作用"
  },
  {
    "head": "回调函数",
    "relation": "触发条件",
    "tail": "系统事件",
    "source_topic": "回调函数的作用"
  },
  {
    "head": "回调函数",
    "relation": "设置方式",
    "tail": "将函数指针作为参数传递",
    "source_topic": "回调函数的作用"
  },
  {
    "head": "回调函数",
    "relation": "分离特性",
    "tail": "调用者与被调用者分离",
    "source_topic": "回调函数的作用"
  },
  {
    "head": "回调函数",
    "relation": "依赖条件",
    "tail": "特定原型和限制条件",
    "source_topic": "回调函数的作用"
  },
  {
    "head": "srand",
    "relation": "初始化",
    "tail": "随机数生成器",
    "source_topic": "随机数的生成"
  },
  {
    "head": "time(NULL)",
    "relation": "提供",
    "tail": "种子值",
    "source_topic": "随机数的生成"
  },
  {
    "head": "rand()",
    "relation": "生成",
    "tail": "伪随机数",
    "source_topic": "随机数的生成"
  },
  {
    "head": "伪随机数",
    "relation": "基于",
    "tail": "线性同余法",
    "source_topic": "随机数的生成"
  },
  {
    "head": "线性同余法",
    "relation": "实现",
    "tail": "rand()",
    "source_topic": "随机数的生成"
  },
  {
    "head": "系统时间",
    "relation": "改变",
    "tail": "数字序列",
    "source_topic": "随机数的生成"
  },
  {
    "head": "种子",
    "relation": "设置为",
    "tail": "time(0)",
    "source_topic": "随机数的生成"
  },
  {
    "head": "伪随机数",
    "relation": "属于",
    "tail": "随机数",
    "source_topic": "随机数的生成"
  },
  {
    "head": "变量定义",
    "relation": "分配",
    "tail": "存储空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量声明",
    "relation": "不分配",
    "tail": "存储空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量声明",
    "relation": "允许",
    "tail": "多个地方",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量定义",
    "relation": "唯一",
    "tail": "一个地方",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "extern关键字",
    "relation": "修饰",
    "tail": "变量声明",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "#ifdef",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "#endif",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "#else",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "#ifndef",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "#ifdef",
    "relation": "用于",
    "tail": "包含特定功能模块",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "#endif",
    "relation": "用于",
    "tail": "结束条件编译块",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "#ifdef",
    "relation": "用于",
    "tail": "调试信息的追踪",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "#ifdef",
    "relation": "用于",
    "tail": "应对硬件限制",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "条件编译命令",
    "relation": "减少",
    "tail": "目标程序长度",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "条件编译命令",
    "relation": "减少",
    "tail": "程序运行时间",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "条件编译",
    "relation": "解决",
    "tail": "if语句编译冗余问题",
    "source_topic": "请简述#ifdef、#else、#endif、和#ifndef的作用是？"
  },
  {
    "head": "int类型",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "bool类型",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "float类型",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "指针变量",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "int类型",
    "relation": "比较操作",
    "tail": "等于零",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "int类型",
    "relation": "比较操作",
    "tail": "不等于零",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "bool类型",
    "relation": "比较操作",
    "tail": "为真",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "bool类型",
    "relation": "比较操作",
    "tail": "为假",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "float类型",
    "relation": "比较操作",
    "tail": "在误差范围内等于零",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "指针变量",
    "relation": "比较操作",
    "tail": "等于NULL",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "指针变量",
    "relation": "比较操作",
    "tail": "不等于NULL",
    "source_topic": "请写出int、bool、float、指针变量与\"零值\"比较的if语句？"
  },
  {
    "head": "结构体",
    "relation": "允许",
    "tail": "直接初始化",
    "source_topic": "结构体是否可以直接赋值？"
  },
  {
    "head": "结构体",
    "relation": "允许",
    "tail": "直接赋值",
    "source_topic": "结构体是否可以直接赋值？"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "指针成员",
    "source_topic": "结构体是否可以直接赋值？"
  },
  {
    "head": "指针成员",
    "relation": "导致",
    "tail": "内存释放冲突",
    "source_topic": "结构体是否可以直接赋值？"
  },
  {
    "head": "内存释放冲突",
    "relation": "解决",
    "tail": "确保其他指针不再使用内存空间",
    "source_topic": "结构体是否可以直接赋值？"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "操作符",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "参数类型",
    "tail": "数据类型或变量",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "参数类型",
    "tail": "以结尾为\\0的字符串",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算时机",
    "tail": "编译时",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "计算时机",
    "tail": "运行时",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算内容",
    "tail": "数据类型占内存的大小",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "计算内容",
    "tail": "字符串实际占用的内存大小",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "数组",
    "relation": "在sizeof中",
    "tail": "不退化",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "数组",
    "relation": "在strlen中",
    "tail": "退化为指针",
    "source_topic": "sizeof和strlen的区别？"
  },
  {
    "head": "static",
    "relation": "功能差异",
    "tail": "C语言",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "static",
    "relation": "功能差异",
    "tail": "C++语言",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "static",
    "relation": "修饰",
    "tail": "局部静态变量",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "static",
    "relation": "修饰",
    "tail": "外部静态变量",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "static",
    "relation": "扩展功能",
    "tail": "类的成员变量",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "static",
    "relation": "扩展功能",
    "tail": "类的成员函数",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "static",
    "relation": "特性",
    "tail": "记忆性",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "static",
    "relation": "特性",
    "tail": "全局性",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "C++静态成员",
    "relation": "通信能力",
    "tail": "多个对象实例",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "C语言静态变量",
    "relation": "通信能力",
    "tail": "不同时期调用的函数",
    "source_topic": "C语言和C++语言中的关键字static有什么区别？"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++操作符",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++操作符",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C函数",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C函数",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "可以重载",
    "tail": "C++操作符",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "delete",
    "relation": "可以重载",
    "tail": "C++操作符",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "可以覆盖",
    "tail": "C函数",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "free",
    "relation": "可以覆盖",
    "tail": "C函数",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "返回",
    "tail": "数据类型指针",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "delete",
    "relation": "返回",
    "tail": "数据类型指针",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "返回",
    "tail": "void指针",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "free",
    "relation": "返回",
    "tail": "void指针",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "必须搭配",
    "tail": "free",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "必须搭配",
    "tail": "delete",
    "source_topic": "C语言的malloc和C++中的new有什么区别？"
  },
  {
    "head": "++i",
    "relation": "操作顺序",
    "tail": "先自增1，再返回",
    "source_topic": "++i和i++的区别？"
  },
  {
    "head": "i++",
    "relation": "操作顺序",
    "tail": "先返回i，再自增1",
    "source_topic": "++i和i++的区别？"
  },
  {
    "head": "volatile",
    "relation": "修饰",
    "tail": "状态寄存器",
    "source_topic": "关键字volatile有什么作用？"
  },
  {
    "head": "volatile",
    "relation": "修饰",
    "tail": "并行设备硬件寄存器",
    "source_topic": "关键字volatile有什么作用？"
  },
  {
    "head": "volatile",
    "relation": "修饰",
    "tail": "中断服务子程序访问的非自动变量",
    "source_topic": "关键字volatile有什么作用？"
  },
  {
    "head": "volatile",
    "relation": "修饰",
    "tail": "多线程间被几个任务访问共享变量",
    "source_topic": "关键字volatile有什么作用？"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "不允许程序中的代码改变变量",
    "source_topic": "一个参数可以既是const又是volatile吗？"
  },
  {
    "head": "*a",
    "relation": "代表",
    "tail": "指针a指向的内存地址存放的数据",
    "source_topic": "*a和&a有什么区别？"
  },
  {
    "head": "&a",
    "relation": "含义",
    "tail": "取变量a的地址",
    "source_topic": "*a和&a有什么区别？"
  },
  {
    "head": "*a",
    "relation": "说明",
    "tail": "指针变量",
    "source_topic": "*a和&a有什么区别？"
  },
  {
    "head": "int *a",
    "relation": "声明",
    "tail": "指针变量a",
    "source_topic": "*a和&a有什么区别？"
  },
  {
    "head": "*a",
    "relation": "代表",
    "tail": "乘以a",
    "source_topic": "*a和&a有什么区别？"
  },
  {
    "head": "指针",
    "relation": "操作",
    "tail": "取地址符(&)",
    "source_topic": "*a和&a有什么区别？"
  },
  {
    "head": "指针",
    "relation": "操作",
    "tail": "解引用操作符(*)",
    "source_topic": "*a和&a有什么区别？"
  },
  {
    "head": "死循环程序",
    "relation": "实现方式",
    "tail": "while循环",
    "source_topic": "用C语言编写一个死循环程序？"
  },
  {
    "head": "死循环程序",
    "relation": "实现方式",
    "tail": "for循环",
    "source_topic": "用C语言编写一个死循环程序？"
  },
  {
    "head": "C语言",
    "relation": "支持",
    "tail": "while循环",
    "source_topic": "用C语言编写一个死循环程序？"
  },
  {
    "head": "C语言",
    "relation": "支持",
    "tail": "for循环",
    "source_topic": "用C语言编写一个死循环程序？"
  },
  {
    "head": "全局变量",
    "relation": "生存期",
    "tail": "整个程序运行到结束",
    "source_topic": "全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "生存期",
    "tail": "模块结束（函数调用完成）",
    "source_topic": "全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "内存分配位置",
    "tail": "全局数据段",
    "source_topic": "全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "内存分配位置",
    "tail": "堆栈",
    "source_topic": "全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "操作系统和编译器",
    "relation": "识别方式",
    "tail": "内存分配的位置",
    "source_topic": "全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "静态存储区域",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "静态存储区域",
    "relation": "分配时机",
    "tail": "程序编译时",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "静态存储区域",
    "relation": "存在期间",
    "tail": "程序的整个运行期间",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "静态存储区域",
    "relation": "特点",
    "tail": "速度快",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "静态存储区域",
    "relation": "特点",
    "tail": "不容易出错",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "静态存储区域",
    "relation": "包含",
    "tail": "全局变量",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "静态存储区域",
    "relation": "包含",
    "tail": "static变量",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "静态存储区域",
    "relation": "包含",
    "tail": "常量字符串",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "栈区",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "栈区",
    "relation": "分配时机",
    "tail": "执行函数时",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "栈区",
    "relation": "包含",
    "tail": "局部变量的存储单元",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "栈区",
    "relation": "释放时机",
    "tail": "函数执行结束时",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "栈区",
    "relation": "特点",
    "tail": "效率很高",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "栈区",
    "relation": "特点",
    "tail": "分配的内存容量有限",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "分配方式",
    "tail": "动态内存分配",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "申请方法",
    "tail": "malloc",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "申请方法",
    "tail": "new",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "释放方法",
    "tail": "free",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "释放方法",
    "tail": "delete",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "特点",
    "tail": "动态内存的生存期由程序员决定",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "特点",
    "tail": "使用非常灵活",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "堆区",
    "relation": "导致",
    "tail": "堆内碎块",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "全局区",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "文字常量区",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "程序代码区",
    "source_topic": "请简述C/C++程序编译的内存分配情况？"
  },
  {
    "head": "strcpy",
    "relation": "操作对象",
    "tail": "字符串",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "sprintf",
    "relation": "操作对象",
    "tail": "多种数据类型",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "memcpy",
    "relation": "操作对象",
    "tail": "任意可操作的内存地址",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "strcpy",
    "relation": "实现功能",
    "tail": "字符串变量间的拷贝",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "sprintf",
    "relation": "实现功能",
    "tail": "其他数据类型格式化到字符串",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "memcpy",
    "relation": "实现功能",
    "tail": "内存块间的拷贝",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "strcpy",
    "relation": "执行效率",
    "tail": "次之",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "sprintf",
    "relation": "执行效率",
    "tail": "最低",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "memcpy",
    "relation": "执行效率",
    "tail": "最高",
    "source_topic": "请简述strcpy、sprintf和memcpy的区别？"
  },
  {
    "head": "(void (*)())0",
    "relation": "转换",
    "tail": "将整数0转换为函数指针类型",
    "source_topic": "请解释(*(void (*)())0)()的含义？"
  },
  {
    "head": "*(void (*)())0",
    "relation": "表示",
    "tail": "指向起始地址为0的函数的名称",
    "source_topic": "请解释(*(void (*)())0)()的含义？"
  },
  {
    "head": "C语言指针",
    "relation": "区别",
    "tail": "C++引用",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "存储空间",
    "tail": "独立空间",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "存储空间",
    "tail": "别名",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "sizeof大小",
    "tail": "4字节",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "sizeof大小",
    "tail": "被引用对象的大小",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "参数传递操作",
    "tail": "需要解引用",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "参数传递操作",
    "tail": "直接修改对象",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "可定义属性",
    "tail": "const指针",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "可定义属性",
    "tail": "无const引用",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "指向能力",
    "tail": "可指向其他对象",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "指向能力",
    "tail": "只能绑定一个对象",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "多级指针",
    "tail": "支持多级指针",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "多级指针",
    "tail": "只支持一级",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "运算符意义",
    "tail": "指向地址的递增",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "运算符意义",
    "tail": "引用对象的递增",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "内存管理",
    "tail": "必须返回动态内存分配对象",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "内存管理",
    "tail": "可能引起内存泄漏",
    "source_topic": "C语言的指针和引用和C++的有什么区别？"
  },
  {
    "head": "typedef",
    "relation": "用法不同",
    "tail": "定义数据类型的别名",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "typedef",
    "relation": "执行时间不同",
    "tail": "编译过程的一部分",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "define",
    "relation": "执行时间不同",
    "tail": "预编译的部分",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "typedef",
    "relation": "作用域不同",
    "tail": "有作用域限定",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "define",
    "relation": "作用域不同",
    "tail": "不受作用域限定",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "typedef",
    "relation": "对指针的操作不同",
    "tail": "定义指针时有区别",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "typedef",
    "relation": "语法要求",
    "tail": "语句，句尾需要加上分号",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "define",
    "relation": "语法要求",
    "tail": "不是语句，不能在句尾加上分号",
    "source_topic": "typedef和define有什么区别？"
  },
  {
    "head": "指针常量",
    "relation": "核心特性",
    "tail": "指针的值不可变",
    "source_topic": "指针常量和常量指针有什么区别？"
  },
  {
    "head": "常量指针",
    "relation": "核心特性",
    "tail": "指向的对象不可变",
    "source_topic": "指针常量和常量指针有什么区别？"
  },
  {
    "head": "指针常量",
    "relation": "用途",
    "tail": "函数形式参数",
    "source_topic": "指针常量和常量指针有什么区别？"
  },
  {
    "head": "常量指针",
    "relation": "用途",
    "tail": "函数形式参数",
    "source_topic": "指针常量和常量指针有什么区别？"
  },
  {
    "head": "指针常量",
    "relation": "区别",
    "tail": "常量指针",
    "source_topic": "指针常量和常量指针有什么区别？"
  },
  {
    "head": "指针常量",
    "relation": "强调",
    "tail": "指针的不可变性",
    "source_topic": "指针常量和常量指针有什么区别？"
  },
  {
    "head": "常量指针",
    "relation": "强调",
    "tail": "指针对其所指对象的不可变性",
    "source_topic": "指针常量和常量指针有什么区别？"
  },
  {
    "head": "队列",
    "relation": "属于",
    "tail": "线性存储结构",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "队列",
    "relation": "核心特性",
    "tail": "先进先出",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "堆区",
    "relation": "核心特性",
    "tail": "顺序随意",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "栈区",
    "relation": "核心特性",
    "tail": "先进后出",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "栈区",
    "relation": "操作方式",
    "tail": "类似于数据结构中的栈",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "栈区",
    "relation": "分配释放方式",
    "tail": "由编译器自动分配释放",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "堆区",
    "relation": "分配释放方式",
    "tail": "由程序员分配释放",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "堆区",
    "relation": "回收方式",
    "tail": "程序结束时可能由OS回收",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "堆区",
    "relation": "分配方式",
    "tail": "类似于链表",
    "source_topic": "请简述队列和栈的异同？"
  },
  {
    "head": "强制类型转换",
    "relation": "应用",
    "tail": "整型变量赋值到特定地址",
    "source_topic": "如何设置地址为0x67a9的整型变量的值为0xaa66？"
  },
  {
    "head": "指针",
    "relation": "类型转换",
    "tail": "整型",
    "source_topic": "如何设置地址为0x67a9的整型变量的值为0xaa66？"
  },
  {
    "head": "整型变量",
    "relation": "存储位置",
    "tail": "内存地址",
    "source_topic": "如何设置地址为0x67a9的整型变量的值为0xaa66？"
  },
  {
    "head": "内存地址",
    "relation": "赋值",
    "tail": "0x67a9",
    "source_topic": "如何设置地址为0x67a9的整型变量的值为0xaa66？"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "0x67a9",
    "source_topic": "如何设置地址为0x67a9的整型变量的值为0xaa66？"
  },
  {
    "head": "指针解引用",
    "relation": "操作",
    "tail": "赋值操作",
    "source_topic": "如何设置地址为0x67a9的整型变量的值为0xaa66？"
  },
  {
    "head": "赋值操作",
    "relation": "目标值",
    "tail": "0xaa66",
    "source_topic": "如何设置地址为0x67a9的整型变量的值为0xaa66？"
  },
  {
    "head": "myatoi",
    "relation": "实现",
    "tail": "字符串转换为整型数值",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "使用",
    "tail": "C++",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "处理",
    "tail": "字符指针",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "指针合法性检查",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "字符串长度计算",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "负号判断",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "非数字字符滤除",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "前导零滤除",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "字符到数值转换",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "数值计算",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "myatoi",
    "relation": "包含",
    "tail": "负号处理",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "pow",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "字符指针",
    "relation": "指向",
    "tail": "字符串",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "字符串",
    "relation": "包含",
    "tail": "字符",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "整型数值",
    "relation": "属于",
    "tail": "整数类型",
    "source_topic": "请编程实现字符串转换为数字？"
  },
  {
    "head": "C语言结构体",
    "relation": "不包含",
    "tail": "函数成员",
    "source_topic": "C语言的结构体和C++的有什么区别？"
  },
  {
    "head": "C++类",
    "relation": "可以包含",
    "tail": "函数成员",
    "source_topic": "C语言的结构体和C++的有什么区别？"
  },
  {
    "head": "C语言结构体",
    "relation": "不支持",
    "tail": "继承关系",
    "source_topic": "C语言的结构体和C++的有什么区别？"
  },
  {
    "head": "C++类",
    "relation": "支持",
    "tail": "继承关系",
    "source_topic": "C语言的结构体和C++的有什么区别？"
  },
  {
    "head": "C++类",
    "relation": "属于",
    "tail": "面向对象编程的基础",
    "source_topic": "C语言的结构体和C++的有什么区别？"
  },
  {
    "head": "C语言结构体",
    "relation": "可以理解为",
    "tail": "C++类的前身",
    "source_topic": "C语言的结构体和C++的有什么区别？"
  },
  {
    "head": "指针常量",
    "relation": "强调",
    "tail": "指针的不可变性",
    "source_topic": "简述指针常量与常量指针的区别？"
  },
  {
    "head": "常量指针",
    "relation": "强调",
    "tail": "指针对其所指对象的不可改变性",
    "source_topic": "简述指针常量与常量指针的区别？"
  },
  {
    "head": "指针常量",
    "relation": "用途",
    "tail": "作为函数的形式参数",
    "source_topic": "简述指针常量与常量指针的区别？"
  },
  {
    "head": "常量指针",
    "relation": "用途",
    "tail": "作为函数的形式参数",
    "source_topic": "简述指针常量与常量指针的区别？"
  },
  {
    "head": "野指针",
    "relation": "导致",
    "tail": "未初始化指针",
    "source_topic": "如何避免\"野指针\"？"
  },
  {
    "head": "野指针",
    "relation": "导致",
    "tail": "未设置为NULL的指针",
    "source_topic": "如何避免\"野指针\"？"
  },
  {
    "head": "野指针",
    "relation": "导致",
    "tail": "超越作用范围的指针",
    "source_topic": "如何避免\"野指针\"？"
  },
  {
    "head": "未初始化指针",
    "relation": "解决办法",
    "tail": "指针初始化",
    "source_topic": "如何避免\"野指针\"？"
  },
  {
    "head": "未设置为NULL的指针",
    "relation": "解决办法",
    "tail": "释放内存后设置指针为NULL",
    "source_topic": "如何避免\"野指针\"？"
  },
  {
    "head": "句柄",
    "relation": "属于",
    "tail": "Windows系统资源标记机制",
    "source_topic": "句柄和指针的区别和联系是什么？"
  },
  {
    "head": "句柄",
    "relation": "数据类型",
    "tail": "32bit的uint",
    "source_topic": "句柄和指针的区别和联系是什么？"
  },
  {
    "head": "指针",
    "relation": "属于",
    "tail": "内存地址标记机制",
    "source_topic": "句柄和指针的区别和联系是什么？"
  },
  {
    "head": "句柄",
    "relation": "区别",
    "tail": "指针",
    "source_topic": "句柄和指针的区别和联系是什么？"
  },
  {
    "head": "句柄",
    "relation": "隐藏信息",
    "tail": "系统内部信息",
    "source_topic": "句柄和指针的区别和联系是什么？"
  },
  {
    "head": "指针",
    "relation": "暴露信息",
    "tail": "内存地址",
    "source_topic": "句柄和指针的区别和联系是什么？"
  },
  {
    "head": "new",
    "relation": "自动计算内存空间",
    "tail": "malloc",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new",
    "relation": "返回具体类型指针",
    "tail": "malloc",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new",
    "relation": "类型安全",
    "tail": "malloc",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new",
    "relation": "包含",
    "tail": "new操作",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new操作",
    "relation": "对应",
    "tail": "malloc",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new操作",
    "relation": "可重载",
    "tail": "自定义内存分配策略",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new操作",
    "relation": "可分配到",
    "tail": "非内存设备",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "free",
    "relation": "不调用",
    "tail": "析构函数",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "malloc",
    "relation": "不调用",
    "tail": "构造函数",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "new/delete",
    "relation": "不需要库文件支持",
    "tail": "malloc/free",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "malloc/free",
    "relation": "需要库文件支持",
    "tail": "stdlib.h",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "delete",
    "relation": "释放内存",
    "tail": "操作系统",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "free",
    "relation": "释放内存",
    "tail": "操作系统",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "delete/free",
    "relation": "不使指针指向空",
    "tail": "指针",
    "source_topic": "new/delete与malloc/free的区别是什么？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "函数重载",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "函数重载",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "C++编译器",
    "relation": "添加",
    "tail": "函数参数类型到编译后的函数名",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "C编译器",
    "relation": "不添加",
    "tail": "函数参数类型到编译后的函数名",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "extern \"C\"",
    "relation": "作用",
    "tail": "指示编译器按C语言方式编译代码",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "extern \"C\"",
    "relation": "应用",
    "tail": "C++调用C语言库",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "extern \"C\"",
    "relation": "使用场景",
    "tail": "C++头文件中",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "extern \"C\"",
    "relation": "使用场景",
    "tail": "多语言协同开发",
    "source_topic": "请说一说extern \"C\"？"
  },
  {
    "head": "C++ struct",
    "relation": "默认继承权限",
    "tail": "private",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ class",
    "relation": "默认继承权限",
    "tail": "private",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ struct",
    "relation": "默认继承权限区别",
    "tail": "C++ class",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ struct",
    "relation": "默认继承权限",
    "tail": "public",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ class",
    "relation": "默认继承权限区别",
    "tail": "C++ struct",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ class",
    "relation": "可用于定义",
    "tail": "模板参数",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ struct",
    "relation": "不可用于定义",
    "tail": "模板参数",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++",
    "relation": "保留关键字原因",
    "tail": "向下兼容性",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ struct",
    "relation": "保证兼容性",
    "tail": "C语言 struct",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ class",
    "relation": "避免兼容性限制",
    "tail": "C语言 struct",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "C++ struct",
    "relation": "拓展性",
    "tail": "C语言代码移植到C++",
    "source_topic": "请说一说C++中struct和class的区别是什么？"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C/C++标准库函数",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C/C++标准库函数",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "free",
    "relation": "不调用",
    "tail": "析构函数",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "对应",
    "tail": "delete",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "对应",
    "tail": "free",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "用于",
    "tail": "动态内存分配",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "用于",
    "tail": "动态内存释放",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "用于",
    "tail": "动态内存分配",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "free",
    "relation": "用于",
    "tail": "动态内存释放",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "解决",
    "tail": "无法自动执行构造函数的问题",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "解决",
    "tail": "无法自动执行析构函数的问题",
    "source_topic": "264.new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "配套",
    "tail": "new",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "配套",
    "tail": "new[]",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "功能区别",
    "tail": "调用一次析构函数",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "功能区别",
    "tail": "调用每个成员的析构函数",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "功能区别",
    "tail": "释放数组内存",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "功能区别",
    "tail": "释放单个对象内存",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "适用场景",
    "tail": "用于释放用new[]分配的内存",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "适用场景",
    "tail": "用于释放用new分配的内存",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "调用",
    "tail": "operator delete",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "operator delete",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "调用",
    "tail": "析构函数（每个数组元素）",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数（单个对象）",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "new[]",
    "relation": "分配",
    "tail": "数组内存",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "new",
    "relation": "分配",
    "tail": "单个对象内存",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "导致",
    "tail": "内存释放错误（若用于非数组）",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "导致",
    "tail": "内存释放错误（若用于数组）",
    "source_topic": "265.delete与 delete []区别"
  },
  {
    "head": "C++",
    "relation": "具有",
    "tail": "封装",
    "source_topic": "266.C++有哪些性质（面向对象特点）"
  },
  {
    "head": "子类析构",
    "relation": "调用次序",
    "tail": "父类析构",
    "source_topic": "267.子类析构时要调用父类的析构函数吗？"
  },
  {
    "head": "对象定义",
    "relation": "调用次序",
    "tail": "基类构造函数",
    "source_topic": "267.子类析构时要调用父类的析构函数吗？"
  },
  {
    "head": "对象定义",
    "relation": "调用次序",
    "tail": "派生类构造函数",
    "source_topic": "267.子类析构时要调用父类的析构函数吗？"
  },
  {
    "head": "析构函数调用",
    "relation": "顺序",
    "tail": "先派生类后基类",
    "source_topic": "267.子类析构时要调用父类的析构函数吗？"
  },
  {
    "head": "基类析构函数",
    "relation": "调用时机",
    "tail": "派生类信息已全部销毁",
    "source_topic": "267.子类析构时要调用父类的析构函数吗？"
  },
  {
    "head": "虚函数",
    "relation": "定义方式",
    "tail": "virtual关键字",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "虚函数",
    "relation": "作用",
    "tail": "提供接口界面",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "虚函数",
    "relation": "允许",
    "tail": "派生类重新定义",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "作用",
    "tail": "为派生类保留函数名字",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "功能",
    "tail": "不能直接调用",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "继承后状态",
    "tail": "仍为虚函数",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "定义条件",
    "tail": "至少有一个纯虚函数",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "包含",
    "tail": "纯虚函数",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "包含",
    "tail": "虚函数",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "用途",
    "tail": "派生其他类的基类",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "限制",
    "tail": "不能直接创建对象实例",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "支持",
    "tail": "运行时多态性",
    "source_topic": "268.多态，虚函数，纯虚函数"
  },
  {
    "head": "func",
    "relation": "计算",
    "tail": "二进制中1的个数",
    "source_topic": "269.求下面函数的返回值（微软）"
  },
  {
    "head": "x&(x-1)",
    "relation": "作用",
    "tail": "清除二进制中最右边的1",
    "source_topic": "269.求下面函数的返回值（微软）"
  },
  {
    "head": "while循环",
    "relation": "执行",
    "tail": "直到x变为0",
    "source_topic": "269.求下面函数的返回值（微软）"
  },
  {
    "head": "countx",
    "relation": "递增",
    "tail": "每次循环",
    "source_topic": "269.求下面函数的返回值（微软）"
  },
  {
    "head": "引用",
    "relation": "属于",
    "tail": "计算机编程概念",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "定义",
    "tail": "目标变量的别名",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "操作效果",
    "tail": "与对变量直接操作效果完全相同",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用声明",
    "relation": "必须",
    "tail": "初始化",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用声明",
    "relation": "导致",
    "tail": "目标变量名有两个名称",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "不占",
    "tail": "存储单元",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "不分配",
    "tail": "存储单元",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "不能建立",
    "tail": "数组的引用",
    "source_topic": "270.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用传递",
    "relation": "效果相同",
    "tail": "指针传递",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "避免副本",
    "tail": "一般变量传递",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "直接操作",
    "tail": "实参变量或对象",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "一般变量传递",
    "relation": "产生副本",
    "tail": "实参变量",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "一般变量传递",
    "relation": "分配存储单元",
    "tail": "形参变量",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "一般变量传递",
    "relation": "调用拷贝构造函数",
    "tail": "对象传递",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "指针传递",
    "relation": "需要重复使用",
    "tail": "解引用操作",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "指针传递",
    "relation": "产生错误",
    "tail": "程序阅读性较差",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "更清晰",
    "tail": "指针传递",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "更高效",
    "tail": "一般变量传递",
    "source_topic": "271.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "常引用",
    "relation": "使用场景",
    "tail": "保护传递给函数的数据不被修改",
    "source_topic": "272.在什么时候需要使用“常引用”？"
  },
  {
    "head": "常引用",
    "relation": "使用场景",
    "tail": "利用引用提高程序效率",
    "source_topic": "272.在什么时候需要使用“常引用”？"
  },
  {
    "head": "临时对象",
    "relation": "类型特性",
    "tail": "const类型",
    "source_topic": "272.在什么时候需要使用“常引用”？"
  },
  {
    "head": "函数参数",
    "relation": "推荐类型",
    "tail": "const引用",
    "source_topic": "272.在什么时候需要使用“常引用”？"
  },
  {
    "head": "函数调用",
    "relation": "导致",
    "tail": "临时对象创建",
    "source_topic": "272.在什么时候需要使用“常引用”？"
  },
  {
    "head": "非const引用参数",
    "relation": "限制",
    "tail": "不能绑定到临时对象",
    "source_topic": "272.在什么时候需要使用“常引用”？"
  },
  {
    "head": "结构",
    "relation": "成员存储方式",
    "tail": "所有成员都存在",
    "source_topic": "273.结构与联合有和区别？"
  },
  {
    "head": "联合",
    "relation": "成员存储方式",
    "tail": "只存放一个被选中的成员",
    "source_topic": "273.结构与联合有和区别？"
  },
  {
    "head": "结构",
    "relation": "成员地址空间",
    "tail": "不同成员的存放地址不同",
    "source_topic": "273.结构与联合有和区别？"
  },
  {
    "head": "联合",
    "relation": "成员地址空间",
    "tail": "所有成员共用一块地址空间",
    "source_topic": "273.结构与联合有和区别？"
  },
  {
    "head": "联合",
    "relation": "赋值影响",
    "tail": "对其他成员重写",
    "source_topic": "273.结构与联合有和区别？"
  },
  {
    "head": "结构",
    "relation": "赋值影响",
    "tail": "不同成员赋值互不影响",
    "source_topic": "273.结构与联合有和区别？"
  },
  {
    "head": "重载",
    "relation": "属于",
    "tail": "函数多态性",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "属于",
    "tail": "函数多态性",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "定义",
    "tail": "子类重新定义父类虚函数的方法",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "实现原理",
    "tail": "父类指针动态调用子类的虚函数",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重载",
    "relation": "绑定时机",
    "tail": "早绑定",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "绑定时机",
    "tail": "晚绑定",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重载",
    "relation": "关联特性",
    "tail": "与多态无关",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "关联特性",
    "tail": "与多态相关",
    "source_topic": "275.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "const成员变量",
    "relation": "需要",
    "tail": "初始化列表",
    "source_topic": "276.有哪几种情况只能用intialization list 而不能用assignment?"
  },
  {
    "head": "引用成员变量",
    "relation": "需要",
    "tail": "初始化列表",
    "source_topic": "276.有哪几种情况只能用intialization list 而不能用assignment?"
  },
  {
    "head": "基类构造函数",
    "relation": "需要",
    "tail": "初始化列表",
    "source_topic": "276.有哪几种情况只能用intialization list 而不能用assignment?"
  },
  {
    "head": "C++",
    "relation": "不是",
    "tail": "类型安全",
    "source_topic": "277. C++是不是类型安全的？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "指针强制转换",
    "source_topic": "277. C++是不是类型安全的？"
  },
  {
    "head": "C#",
    "relation": "是",
    "tail": "类型安全",
    "source_topic": "277. C++是不是类型安全的？"
  },
  {
    "head": "全局对象",
    "relation": "构造函数执行于",
    "tail": "main函数之前",
    "source_topic": "278. main 函数执行以前，还会执行什么代码？"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "全局变量",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "static变量",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "栈上创建",
    "relation": "包含",
    "tail": "函数内局部变量的存储单元",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "栈上创建",
    "relation": "特点",
    "tail": "函数执行结束时自动释放",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "栈上创建",
    "relation": "实现方式",
    "tail": "内置于处理器的指令集",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "别称",
    "tail": "动态内存分配",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "申请方式",
    "tail": "malloc",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "申请方式",
    "tail": "new",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "释放方式",
    "tail": "free",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "释放方式",
    "tail": "delete",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存生存期由程序员决定",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "使用非常灵活",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "问题",
    "tail": "内存管理问题最多",
    "source_topic": "279. 描述内存分配方式以及它们的区别?"
  },
  {
    "head": "BOOL",
    "relation": "比较方式",
    "tail": "if ( !a )",
    "source_topic": "280.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "BOOL",
    "relation": "比较方式",
    "tail": "if ( a )",
    "source_topic": "280.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "int",
    "relation": "比较方式",
    "tail": "if ( a == 0)",
    "source_topic": "280.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "float",
    "relation": "比较方式",
    "tail": "if ( a - EXP)",
    "source_topic": "280.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "指针类型",
    "relation": "比较方式",
    "tail": "if ( a != NULL)",
    "source_topic": "280.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "指针类型",
    "relation": "比较方式",
    "tail": "if ( a == NULL)",
    "source_topic": "280.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "常量",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数参数",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数返回值",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "提供",
    "tail": "类型安全检查",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "受到保护",
    "tail": "强制保护",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "预防",
    "tail": "意外的变动",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "提高",
    "tail": "程序的健壮性",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const 常量",
    "relation": "具有",
    "tail": "数据类型",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "宏常量",
    "relation": "不具有",
    "tail": "数据类型",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const 常量",
    "relation": "支持",
    "tail": "调试",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "宏常量",
    "relation": "不支持",
    "tail": "调试",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "对比",
    "tail": "define",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "define",
    "relation": "进行",
    "tail": "字符替换",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "define",
    "relation": "缺乏",
    "tail": "类型安全检查",
    "source_topic": "281.请说出const与#define 相比，有何优点？"
  },
  {
    "head": "数组",
    "relation": "存储位置",
    "tail": "静态存储区或栈",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "指针",
    "relation": "存储位置",
    "tail": "可指向任意类型的内存块",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "数组",
    "relation": "修改内容",
    "tail": "允许修改数组元素",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "指针",
    "relation": "修改内容",
    "tail": "指向常量字符串时不允许修改内容",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算",
    "tail": "数组的容量（字节数）",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算",
    "tail": "指针变量的字节数",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "数组",
    "relation": "传递参数",
    "tail": "退化为同类型的指针",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "数组",
    "relation": "底层结构",
    "tail": "连续内存块",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "指针",
    "relation": "底层结构",
    "tail": "内存地址",
    "source_topic": "282.简述数组与指针的区别？"
  },
  {
    "head": "str1",
    "relation": "分配于",
    "tail": "栈内存",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str2",
    "relation": "分配于",
    "tail": "栈内存",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str3",
    "relation": "分配于",
    "tail": "栈内存",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str4",
    "relation": "分配于",
    "tail": "栈内存",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str5",
    "relation": "指向",
    "tail": "文字常量区",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str6",
    "relation": "指向",
    "tail": "文字常量区",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str7",
    "relation": "指向",
    "tail": "文字常量区",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str8",
    "relation": "指向",
    "tail": "文字常量区",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str1",
    "relation": "内存空间独立于",
    "tail": "str2",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str2",
    "relation": "内存空间独立于",
    "tail": "str1",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str3",
    "relation": "内存空间独立于",
    "tail": "str4",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str4",
    "relation": "内存空间独立于",
    "tail": "str3",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str5",
    "relation": "内存空间相同于",
    "tail": "str6",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str6",
    "relation": "内存空间相同于",
    "tail": "str5",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str7",
    "relation": "内存空间相同于",
    "tail": "str8",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str8",
    "relation": "内存空间相同于",
    "tail": "str7",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "数组变量",
    "relation": "分配于",
    "tail": "栈内存",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "文字常量区",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str1",
    "relation": "属于",
    "tail": "数组变量",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str2",
    "relation": "属于",
    "tail": "数组变量",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str3",
    "relation": "属于",
    "tail": "数组变量",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str4",
    "relation": "属于",
    "tail": "数组变量",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str5",
    "relation": "属于",
    "tail": "指针",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str6",
    "relation": "属于",
    "tail": "指针",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str7",
    "relation": "属于",
    "tail": "指针",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "str8",
    "relation": "属于",
    "tail": "指针",
    "source_topic": "284.栈内存与文字常量区"
  },
  {
    "head": "函数指针",
    "relation": "调用",
    "tail": "执行代码",
    "source_topic": "285.将程序跳转到指定内存地址"
  },
  {
    "head": "程序跳转",
    "relation": "实现方式",
    "tail": "通过函数指针调用绝对地址",
    "source_topic": "285.将程序跳转到指定内存地址"
  },
  {
    "head": "强制类型转换",
    "relation": "应用",
    "tail": "函数指针定义",
    "source_topic": "285.将程序跳转到指定内存地址"
  },
  {
    "head": "typedef",
    "relation": "用于",
    "tail": "定义函数指针类型",
    "source_topic": "285.将程序跳转到指定内存地址"
  },
  {
    "head": "voidFuncPtr",
    "relation": "属于",
    "tail": "函数指针类型",
    "source_topic": "285.将程序跳转到指定内存地址"
  },
  {
    "head": "函数指针类型",
    "relation": "简化",
    "tail": "指针操作",
    "source_topic": "285.将程序跳转到指定内存地址"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "编译时运算符",
    "source_topic": "286.int id[sizeof(unsigned long)];这个对吗？为什么？"
  },
  {
    "head": "编译时运算符",
    "relation": "确定",
    "tail": "数组大小",
    "source_topic": "286.int id[sizeof(unsigned long)];这个对吗？为什么？"
  },
  {
    "head": "unsigned long",
    "relation": "类型大小",
    "tail": "依赖于机器架构",
    "source_topic": "286.int id[sizeof(unsigned long)];这个对吗？为什么？"
  },
  {
    "head": "引用",
    "relation": "必须初始化",
    "tail": "指针",
    "source_topic": "287.引用与指针有什么区别？"
  },
  {
    "head": "引用",
    "relation": "不可更改指向",
    "tail": "指针",
    "source_topic": "287.引用与指针有什么区别？"
  },
  {
    "head": "引用",
    "relation": "不能指向空值",
    "tail": "指针",
    "source_topic": "287.引用与指针有什么区别？"
  },
  {
    "head": "const",
    "relation": "属于",
    "tail": "C++语言特性",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "const",
    "relation": "具有",
    "tail": "数据类型",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "const",
    "relation": "支持",
    "tail": "类型安全检查",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "#define",
    "relation": "属于",
    "tail": "C预处理指令",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "#define",
    "relation": "缺乏",
    "tail": "数据类型",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "#define",
    "relation": "不支持",
    "tail": "类型安全检查",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "const",
    "relation": "支持",
    "tail": "调试工具调试",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "#define",
    "relation": "不支持",
    "tail": "调试工具调试",
    "source_topic": "288.const 与 #define 的比较 ，const有什么优点?"
  },
  {
    "head": "内存分配",
    "relation": "分类",
    "tail": "静态存储区域分配",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "内存分配",
    "relation": "分类",
    "tail": "栈上分配",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "内存分配",
    "relation": "分类",
    "tail": "堆上分配",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "编译时分配",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "运行期间内存持续存在",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "示例",
    "tail": "全局变量",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "函数执行时分配",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "函数执行结束时自动释放",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "内存分配效率高",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "内存容量有限",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "运行时动态分配",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "使用malloc或new申请",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "需要程序员手动释放",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存生存期由程序员决定",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存使用灵活",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "问题",
    "tail": "内存泄漏",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "问题",
    "tail": "碎片化",
    "source_topic": "289.内存的分配方式有几种?"
  },
  {
    "head": "基类析构函数",
    "relation": "导致",
    "tail": "资源泄漏",
    "source_topic": "290.基类的析构函数不是虚函数，会带来什么问题？"
  },
  {
    "head": "派生类析构函数",
    "relation": "无法使用",
    "tail": "基类析构函数非虚函数",
    "source_topic": "290.基类的析构函数不是虚函数，会带来什么问题？"
  },
  {
    "head": "全局变量",
    "relation": "生命周期不同",
    "tail": "主程序",
    "source_topic": "291.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "生命周期不同",
    "tail": "局部函数内部",
    "source_topic": "291.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "使用方式不同",
    "tail": "程序各个部分",
    "source_topic": "291.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "使用方式不同",
    "tail": "局部使用",
    "source_topic": "291.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "分配位置",
    "tail": "栈区",
    "source_topic": "291.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "分配位置",
    "tail": "全局数据段",
    "source_topic": "291.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "操作系统和编译器",
    "relation": "识别依据",
    "tail": "内存分配的位置",
    "source_topic": "291.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "const指针",
    "relation": "分类",
    "tail": "const关键字",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "指向const对象的指针",
    "relation": "分类",
    "tail": "const关键字",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "const形参",
    "relation": "特性",
    "tail": "在函数体内不能被修改",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "const成员函数",
    "relation": "修饰",
    "tail": "隐藏的*this指针",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "const成员函数",
    "relation": "特性",
    "tail": "不会修改类的成员变量",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "普通成员函数",
    "relation": "调用限制",
    "tail": "只能被普通对象调用",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "const返回值",
    "relation": "修饰",
    "tail": "返回值是const类型",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "const成员变量",
    "relation": "初始化方式",
    "tail": "必须在构造函数的列表里初始化",
    "source_topic": "const关键字（反义词mutable）"
  },
  {
    "head": "static变量",
    "relation": "维持",
    "tail": "函数调用过程中值不变",
    "source_topic": "static关键字"
  },
  {
    "head": "static函数",
    "relation": "调用限制",
    "tail": "仅限模块内其他函数调用",
    "source_topic": "static关键字"
  },
  {
    "head": "static成员变量",
    "relation": "归属",
    "tail": "整个类",
    "source_topic": "static关键字"
  },
  {
    "head": "static成员变量",
    "relation": "定义位置",
    "tail": "类的作用域中",
    "source_topic": "static关键字"
  },
  {
    "head": "static成员函数",
    "relation": "归属",
    "tail": "整个类",
    "source_topic": "static关键字"
  },
  {
    "head": "static成员函数",
    "relation": "特性",
    "tail": "不包含this指针",
    "source_topic": "static关键字"
  },
  {
    "head": "static成员函数",
    "relation": "调用限制",
    "tail": "只能调用static成员函数",
    "source_topic": "static关键字"
  },
  {
    "head": "static全局变量",
    "relation": "作用域限制",
    "tail": "仅限本文件使用",
    "source_topic": "static关键字"
  },
  {
    "head": "static局部变量",
    "relation": "初始化要求",
    "tail": "必须初始化",
    "source_topic": "static关键字"
  },
  {
    "head": "static局部变量",
    "relation": "生命周期",
    "tail": "函数调用结束后仍然存在",
    "source_topic": "static关键字"
  },
  {
    "head": "static局部变量",
    "relation": "访问限制",
    "tail": "其他函数不能引用",
    "source_topic": "static关键字"
  },
  {
    "head": "static函数",
    "relation": "作用域限制",
    "tail": "限定在本文件中使用",
    "source_topic": "static关键字"
  },
  {
    "head": "static函数",
    "relation": "优势",
    "tail": "静态函数不能为其他函数使用",
    "source_topic": "static关键字"
  },
  {
    "head": "extern C",
    "relation": "表示",
    "tail": "该段代码以C语言进行编译",
    "source_topic": "extern关键字"
  },
  {
    "head": "extern",
    "relation": "用于",
    "tail": "变量或函数的前向声明",
    "source_topic": "extern关键字"
  },
  {
    "head": "extern",
    "relation": "提示编译器",
    "tail": "去其他模块中找定义",
    "source_topic": "extern关键字"
  },
  {
    "head": "引用",
    "relation": "访问方式",
    "tail": "直接访问",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "指针",
    "relation": "访问方式",
    "tail": "间接访问",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "内存分配",
    "tail": "不单独分配内存空间",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "指针",
    "relation": "内存分配",
    "tail": "单独分配内存空间",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "绑定特性",
    "tail": "绑定内存空间后不可更改",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "初始化要求",
    "tail": "必须赋初值",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "功能特性",
    "tail": "变量的别名",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "优势",
    "tail": "具有指针的效率",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "优势",
    "tail": "具有变量使用的方便性和直观性",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "explicit",
    "relation": "作用",
    "tail": "阻止隐式转换",
    "source_topic": "296.explicit是干什么用的 ?"
  },
  {
    "head": "new/delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "malloc/free",
    "relation": "属于",
    "tail": "C/C++标准库函数",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "new/delete",
    "relation": "功能覆盖",
    "tail": "malloc/free",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "new",
    "relation": "自动分配",
    "tail": "空间大小",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "new/delete",
    "relation": "调用",
    "tail": "构造函数和析构函数",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "malloc/free",
    "relation": "不调用",
    "tail": "构造函数和析构函数",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "C++",
    "relation": "保留",
    "tail": "malloc/free",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "C++程序",
    "relation": "需要调用",
    "tail": "C函数",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "C程序",
    "relation": "只能使用",
    "tail": "malloc/free",
    "source_topic": "new/delete与malloc/free之间的区别？"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "同一资源析构两次",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "delete同一块内存两次",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "程序崩溃",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "指针指向同一内存空间",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "改动影响另一方",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "解决",
    "tail": "同一资源析构两次",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "解决",
    "tail": "delete同一块内存两次",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "解决",
    "tail": "程序崩溃",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "解决",
    "tail": "改动影响另一方",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "包含",
    "tail": "对指针的拷贝",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "包含",
    "tail": "对指针指向内容的拷贝",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "包含",
    "tail": "对指针的拷贝",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "导致",
    "tail": "两个不同地址的指针",
    "source_topic": "浅拷贝与深拷贝？为什么要使用深拷贝？"
  },
  {
    "head": "静态分配",
    "relation": "由编译器完成",
    "tail": "局部变量的分配",
    "source_topic": "深入谈谈堆和栈？"
  },
  {
    "head": "内存静态分配",
    "relation": "时间不同",
    "tail": "内存动态分配",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "内存静态分配",
    "relation": "发生时间",
    "tail": "程序编译和连接时",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "内存动态分配",
    "relation": "发生时间",
    "tail": "程序调入和执行时",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "静态分配",
    "relation": "执行者",
    "tail": "编译器",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "静态分配",
    "relation": "应用场景",
    "tail": "局部变量的分配",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "alloca",
    "relation": "功能",
    "tail": "从栈里动态分配内存",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "alloca",
    "relation": "特性",
    "tail": "不用担心内存泄露",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "alloca",
    "relation": "内存释放时机",
    "tail": "函数返回时自动释放",
    "source_topic": "301.内存的静态分配和动态分配的区别？"
  },
  {
    "head": "String类",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "实现string类"
  },
  {
    "head": "String类",
    "relation": "包含",
    "tail": "复制构造函数",
    "source_topic": "实现string类"
  },
  {
    "head": "String类",
    "relation": "包含",
    "tail": "移动构造函数",
    "source_topic": "实现string类"
  },
  {
    "head": "String类",
    "relation": "包含",
    "tail": "复制运算符重载",
    "source_topic": "实现string类"
  },
  {
    "head": "String类",
    "relation": "包含",
    "tail": "移动赋值运算符重载",
    "source_topic": "实现string类"
  },
  {
    "head": "String类",
    "relation": "包含",
    "tail": "析构函数",
    "source_topic": "实现string类"
  },
  {
    "head": "String类",
    "relation": "包含",
    "tail": "友元函数",
    "source_topic": "实现string类"
  },
  {
    "head": "复制构造函数",
    "relation": "实现",
    "tail": "深拷贝",
    "source_topic": "实现string类"
  },
  {
    "head": "移动构造函数",
    "relation": "实现",
    "tail": "右值引用",
    "source_topic": "实现string类"
  },
  {
    "head": "复制运算符重载",
    "relation": "实现",
    "tail": "深拷贝",
    "source_topic": "实现string类"
  },
  {
    "head": "移动赋值运算符重载",
    "relation": "实现",
    "tail": "资源转移",
    "source_topic": "实现string类"
  },
  {
    "head": "析构函数",
    "relation": "执行",
    "tail": "释放动态内存",
    "source_topic": "实现string类"
  },
  {
    "head": "友元函数",
    "relation": "允许",
    "tail": "ostream输出操作",
    "source_topic": "实现string类"
  },
  {
    "head": "ostream输出操作",
    "relation": "实现",
    "tail": "输出字符串内容",
    "source_topic": "实现string类"
  },
  {
    "head": "C++多态",
    "relation": "实现原理",
    "tail": "虚表指针",
    "source_topic": "什么是继承？什么是多态？"
  },
  {
    "head": "虚表指针",
    "relation": "初始化为",
    "tail": "本类的虚表",
    "source_topic": "什么是继承？什么是多态？"
  },
  {
    "head": "动态关联",
    "relation": "定义",
    "tail": "程序运行时才能确定执行的动作",
    "source_topic": "什么是静态关联？什么是动态关联？"
  },
  {
    "head": "虚函数",
    "relation": "实现方式",
    "tail": "虚表",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚表",
    "relation": "数据结构",
    "tail": "一维数组",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚表",
    "relation": "存储内容",
    "tail": "虚函数地址",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "基类",
    "relation": "包含",
    "tail": "虚表",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "派生类",
    "relation": "包含",
    "tail": "虚表",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "构造函数",
    "relation": "执行操作",
    "tail": "虚表的创建",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "构造函数",
    "relation": "执行操作",
    "tail": "虚表指针的初始化",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "子类对象",
    "relation": "初始化过程",
    "tail": "父类构造函数",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "父类构造函数",
    "relation": "执行操作",
    "tail": "初始化虚表指针",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "父类虚表指针",
    "relation": "指向",
    "tail": "父类虚表",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "子类构造函数",
    "relation": "执行操作",
    "tail": "初始化虚表指针",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "子类虚表指针",
    "relation": "指向",
    "tail": "子类虚表",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "子类虚表",
    "relation": "继承",
    "tail": "基类虚表",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "子类虚表",
    "relation": "函数地址排列",
    "tail": "基类虚表顺序",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚函数调用",
    "relation": "确定时机",
    "tail": "编译阶段",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚函数调用",
    "relation": "依赖",
    "tail": "指针/引用类型",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "多态性",
    "relation": "实现方式",
    "tail": "虚函数",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "多态性",
    "relation": "实现方式",
    "tail": "动态绑定",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "动态绑定",
    "relation": "确定时机",
    "tail": "运行时",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "动态绑定",
    "relation": "依赖",
    "tail": "对象类型",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚函数调用",
    "relation": "依据",
    "tail": "虚指针",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚指针",
    "relation": "指向",
    "tail": "虚表",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚表",
    "relation": "包含",
    "tail": "虚函数地址",
    "source_topic": "虚函数是如何实现的？"
  },
  {
    "head": "虚函数",
    "relation": "可以被",
    "tail": "子类重写",
    "source_topic": "虚函数与纯虚函数的区别？含有纯虚函数的类叫什么？"
  },
  {
    "head": "纯虚函数",
    "relation": "可以被",
    "tail": "子类重写",
    "source_topic": "虚函数与纯虚函数的区别？含有纯虚函数的类叫什么？"
  },
  {
    "head": "纯虚函数",
    "relation": "只有",
    "tail": "定义",
    "source_topic": "虚函数与纯虚函数的区别？含有纯虚函数的类叫什么？"
  },
  {
    "head": "虚函数",
    "relation": "既有",
    "tail": "定义",
    "source_topic": "虚函数与纯虚函数的区别？含有纯虚函数的类叫什么？"
  },
  {
    "head": "虚函数",
    "relation": "又有",
    "tail": "实现的代码",
    "source_topic": "虚函数与纯虚函数的区别？含有纯虚函数的类叫什么？"
  },
  {
    "head": "抽象类",
    "relation": "定义",
    "tail": "包含纯虚函数的类",
    "source_topic": "虚函数与纯虚函数的区别？含有纯虚函数的类叫什么？"
  },
  {
    "head": "多重继承",
    "relation": "导致",
    "tail": "二义性错误",
    "source_topic": "多重继承如何解决？"
  },
  {
    "head": "虚拟继承",
    "relation": "解决",
    "tail": "多重继承",
    "source_topic": "多重继承如何解决？"
  },
  {
    "head": "类D",
    "relation": "多重继承自",
    "tail": "类B和类C",
    "source_topic": "多重继承如何解决？"
  },
  {
    "head": "类B和类C",
    "relation": "虚拟继承自",
    "tail": "类A",
    "source_topic": "多重继承如何解决？"
  },
  {
    "head": "类D",
    "relation": "包含",
    "tail": "一个类A的对象",
    "source_topic": "多重继承如何解决？"
  },
  {
    "head": "成员限定符",
    "relation": "解决",
    "tail": "二义性",
    "source_topic": "多重继承如何解决？"
  },
  {
    "head": "派生类",
    "relation": "继承",
    "tail": "基类函数",
    "source_topic": "派生类与虚函数概述"
  },
  {
    "head": "虚函数",
    "relation": "定义目的",
    "tail": "派生类重新定义",
    "source_topic": "派生类与虚函数概述"
  },
  {
    "head": "派生类",
    "relation": "调用",
    "tail": "基类虚函数版本",
    "source_topic": "派生类与虚函数概述"
  },
  {
    "head": "派生类函数",
    "relation": "声明匹配",
    "tail": "基类中定义的方式",
    "source_topic": "派生类与虚函数概述"
  },
  {
    "head": "基类虚函数",
    "relation": "影响",
    "tail": "派生类函数为虚函数",
    "source_topic": "派生类与虚函数概述"
  },
  {
    "head": "析构函数",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "定义为",
    "tail": "虚函数",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "静态联编",
    "relation": "使用",
    "tail": "基类析构函数",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "动态联编",
    "relation": "使用",
    "tail": "子类析构函数",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "普通函数",
    "relation": "只能",
    "tail": "重载",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "普通函数",
    "relation": "不能",
    "tail": "重写",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "构造函数",
    "relation": "需要",
    "tail": "全部信息",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "虚函数",
    "relation": "允许",
    "tail": "部分信息",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "内联函数",
    "relation": "在编译时",
    "tail": "被展开",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "虚函数",
    "relation": "在运行时",
    "tail": "动态绑定",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "友元函数",
    "relation": "不能",
    "tail": "被继承",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "静态成员函数",
    "relation": "不能",
    "tail": "被继承",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "静态成员函数",
    "relation": "共有",
    "tail": "父类和子类",
    "source_topic": "为什么析构函数要定义为虚函数？哪些函数不能是虚函数？"
  },
  {
    "head": "析构函数",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "析构函数",
    "relation": "不能抛出异常",
    "tail": "C++标准",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "析构函数",
    "relation": "导致",
    "tail": "资源泄漏",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "析构函数",
    "relation": "导致",
    "tail": "程序崩溃",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "C++异常处理模型",
    "relation": "支持",
    "tail": "面向对象",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "C++异常处理模型",
    "relation": "负责",
    "tail": "清除失效对象",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "C++异常处理模型",
    "relation": "负责",
    "tail": "释放资源",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "运行时动态链接",
    "relation": "属于",
    "tail": "动态链接",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "载入时动态链接",
    "relation": "属于",
    "tail": "动态链接",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "载入时动态链接",
    "relation": "需要",
    "tail": "导入库",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "导入库",
    "relation": "提供",
    "tail": "DLL函数定位信息",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "导入库",
    "relation": "提供",
    "tail": "载入DLL所需信息",
    "source_topic": "析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "可变数组",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "vector",
    "relation": "支持",
    "tail": "快速随机访问",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "vector",
    "relation": "可能导致",
    "tail": "尾部之外插入或删除元素很慢",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "deque",
    "relation": "底层结构",
    "tail": "双端队列",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "deque",
    "relation": "支持",
    "tail": "快速随机访问",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "deque",
    "relation": "支持",
    "tail": "头尾快速插入或删除",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "双向链表",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "list",
    "relation": "支持",
    "tail": "双向顺序访问",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "list",
    "relation": "支持",
    "tail": "任何位置快速插入或删除",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "set",
    "relation": "属于",
    "tail": "关联容器",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "set",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "set",
    "relation": "支持",
    "tail": "存储唯一键值",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "multiset",
    "relation": "属于",
    "tail": "关联容器",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "multiset",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "multiset",
    "relation": "支持",
    "tail": "存储重复键值",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "map",
    "relation": "属于",
    "tail": "关联容器",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "map",
    "relation": "支持",
    "tail": "存储唯一关键字键值对",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "multimap",
    "relation": "属于",
    "tail": "关联容器",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "multimap",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "multimap",
    "relation": "支持",
    "tail": "存储重复关键字键值对",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "unordered_map",
    "relation": "属于",
    "tail": "无序关联容器",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "unordered_map",
    "relation": "底层结构",
    "tail": "哈希函数",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "unordered_set",
    "relation": "属于",
    "tail": "无序关联容器",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "unordered_set",
    "relation": "底层结构",
    "tail": "哈希函数",
    "source_topic": "STL各类容器（3个顺序+4个关联+1个无序关联）的实现原理及使用情形"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "容器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "迭代器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "适配器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "算法",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "函数对象",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "配置器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "迭代器",
    "relation": "分类",
    "tail": "随机访问迭代器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "迭代器",
    "relation": "分类",
    "tail": "双向迭代器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "迭代器",
    "relation": "分类",
    "tail": "前向迭代器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "迭代器",
    "relation": "分类",
    "tail": "输入迭代器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "迭代器",
    "relation": "分类",
    "tail": "输出迭代器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "适配器",
    "relation": "包装",
    "tail": "容器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "适配器",
    "relation": "包装",
    "tail": "迭代器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "适配器",
    "relation": "包装",
    "tail": "算法",
    "source_topic": "什么是STL？"
  },
  {
    "head": "容器适配器",
    "relation": "实例",
    "tail": "stack",
    "source_topic": "什么是STL？"
  },
  {
    "head": "容器适配器",
    "relation": "实例",
    "tail": "queue",
    "source_topic": "什么是STL？"
  },
  {
    "head": "容器适配器",
    "relation": "实例",
    "tail": "priority_queue",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL算法库",
    "relation": "分为",
    "tail": "非修改式序列操作",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL算法库",
    "relation": "分为",
    "tail": "修改式序列操作",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL算法库",
    "relation": "分为",
    "tail": "排序和相关操作",
    "source_topic": "什么是STL？"
  },
  {
    "head": "STL算法库",
    "relation": "分为",
    "tail": "通用数字运算",
    "source_topic": "什么是STL？"
  },
  {
    "head": "非修改式序列操作",
    "relation": "包含",
    "tail": "find()",
    "source_topic": "什么是STL？"
  },
  {
    "head": "非修改式序列操作",
    "relation": "包含",
    "tail": "for_each()",
    "source_topic": "什么是STL？"
  },
  {
    "head": "修改式序列操作",
    "relation": "包含",
    "tail": "transform()",
    "source_topic": "什么是STL？"
  },
  {
    "head": "修改式序列操作",
    "relation": "包含",
    "tail": "copy",
    "source_topic": "什么是STL？"
  },
  {
    "head": "排序和相关操作",
    "relation": "包含",
    "tail": "sort()",
    "source_topic": "什么是STL？"
  },
  {
    "head": "函数对象",
    "relation": "包括",
    "tail": "函数名",
    "source_topic": "什么是STL？"
  },
  {
    "head": "函数对象",
    "relation": "包括",
    "tail": "指向函数的指针",
    "source_topic": "什么是STL？"
  },
  {
    "head": "函数对象",
    "relation": "包括",
    "tail": "重载了()操作符的类对象",
    "source_topic": "什么是STL？"
  },
  {
    "head": "配置器",
    "relation": "分类",
    "tail": "一级配置器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "配置器",
    "relation": "分类",
    "tail": "二级配置器",
    "source_topic": "什么是STL？"
  },
  {
    "head": "空间配置器",
    "relation": "作用",
    "tail": "提高代码复用率",
    "source_topic": "什么是STL？"
  },
  {
    "head": "空间配置器",
    "relation": "作用",
    "tail": "减少内存碎片问题",
    "source_topic": "什么是STL？"
  },
  {
    "head": "空间配置器",
    "relation": "作用",
    "tail": "提高内存分配的效率",
    "source_topic": "什么是STL？"
  },
  {
    "head": "空间配置器",
    "relation": "作用",
    "tail": "有内存不足时的应对措施",
    "source_topic": "什么是STL？"
  },
  {
    "head": "空间配置器",
    "relation": "考虑",
    "tail": "多线程状态",
    "source_topic": "什么是STL？"
  },
  {
    "head": "一级空间配置器",
    "relation": "基于",
    "tail": "malloc()",
    "source_topic": "什么是STL？"
  },
  {
    "head": "一级空间配置器",
    "relation": "基于",
    "tail": "free()",
    "source_topic": "什么是STL？"
  },
  {
    "head": "一级空间配置器",
    "relation": "基于",
    "tail": "realloc()",
    "source_topic": "什么是STL？"
  },
  {
    "head": "二级空间配置器",
    "relation": "基于",
    "tail": "内存池",
    "source_topic": "什么是STL？"
  },
  {
    "head": "二级空间配置器",
    "relation": "管理",
    "tail": "自由链表",
    "source_topic": "什么是STL？"
  },
  {
    "head": "二级空间配置器",
    "relation": "对齐",
    "tail": "8个字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "二级空间配置器",
    "relation": "维护",
    "tail": "16个free_lists",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "8字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "16字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "24字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "32字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "40字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "48字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "56字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "64字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "72字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "80字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "88字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "96字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "104字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "112字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "120字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "free_list",
    "relation": "管理",
    "tail": "128字节",
    "source_topic": "什么是STL？"
  },
  {
    "head": "智能指针",
    "relation": "属于",
    "tail": "C++11",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "堆内存泄露",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "二次释放",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "程序异常时内存泄露",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "智能指针",
    "relation": "基于",
    "tail": "RAII",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "unique_ptr",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "shared_ptr",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "智能指针",
    "relation": "包含",
    "tail": "weak_ptr",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "unique_ptr",
    "relation": "实现",
    "tail": "禁止拷贝语义",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "unique_ptr",
    "relation": "实现",
    "tail": "移动语义",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "unique_ptr",
    "relation": "管理",
    "tail": "动态资源",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "unique_ptr",
    "relation": "生命周期",
    "tail": "从创建时开始",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "unique_ptr",
    "relation": "生命周期",
    "tail": "直到离开作用域",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "shared_ptr",
    "relation": "实现",
    "tail": "引用计数",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "shared_ptr",
    "relation": "引用计数",
    "tail": "线程安全",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "shared_ptr",
    "relation": "导致",
    "tail": "对象读取需要加锁",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "weak_ptr",
    "relation": "作用",
    "tail": "协助shared_ptr工作",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "weak_ptr",
    "relation": "不具有",
    "tail": "普通指针的行为",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "weak_ptr",
    "relation": "不重载",
    "tail": "operator*",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "weak_ptr",
    "relation": "不重载",
    "tail": "->",
    "source_topic": "什么是智能指针？底层实现？"
  },
  {
    "head": "多进程",
    "relation": "数据隔离方式",
    "tail": "进程数据是分开的",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "数据隔离方式",
    "tail": "共享进程数据",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "共享复杂性",
    "tail": "需要IPC",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "共享复杂性",
    "tail": "共享简单",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "同步复杂性",
    "tail": "同步简单",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "同步复杂性",
    "tail": "同步复杂",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "创建销毁复杂度",
    "tail": "复杂，速度慢",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "创建销毁复杂度",
    "tail": "简单，速度快",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "内存占用",
    "tail": "占用内存多",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "内存占用",
    "tail": "占用内存少",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "CPU利用率",
    "tail": "利用率低",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "CPU利用率",
    "tail": "利用率高",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "编程调试复杂度",
    "tail": "编程简单，调试简单",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "编程调试复杂度",
    "tail": "编程复杂，调试复杂",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "稳定性影响",
    "tail": "进程间不会相互影响",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "稳定性影响",
    "tail": "一个线程挂掉将导致整个进程挂掉",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多进程",
    "relation": "适用场景",
    "tail": "多核、多机分布",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "多线程",
    "relation": "适用场景",
    "tail": "多核",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "线程",
    "relation": "私有数据",
    "tail": "线程id",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "线程",
    "relation": "私有数据",
    "tail": "寄存器的值",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "线程",
    "relation": "私有数据",
    "tail": "线程的优先级和调度策略",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "线程",
    "relation": "私有数据",
    "tail": "线程的私有数据",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "线程",
    "relation": "私有数据",
    "tail": "信号屏蔽字",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "线程",
    "relation": "私有数据",
    "tail": "errno变量",
    "source_topic": "多进程与多线程之间的区别？（最好要了解透彻）"
  },
  {
    "head": "进程池",
    "relation": "属于",
    "tail": "并发编程技术",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "线程池",
    "relation": "属于",
    "tail": "并发编程技术",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "进程池",
    "relation": "解决",
    "tail": "频繁创建和销毁进程的开销",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "线程池",
    "relation": "解决",
    "tail": "频繁创建和销毁线程的开销",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "进程池",
    "relation": "包含",
    "tail": "一组子进程",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "线程池",
    "relation": "包含",
    "tail": "一组线程",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "进程池",
    "relation": "核心特性",
    "tail": "子进程数目通常在3~10个之间",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "线程池",
    "relation": "核心特性",
    "tail": "线程数量通常与CPU数量相近",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "进程池",
    "relation": "包含",
    "tail": "工作队列",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "线程池",
    "relation": "包含",
    "tail": "工作队列",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "工作队列",
    "relation": "功能",
    "tail": "同步进程池和线程池的任务分配",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "子进程",
    "relation": "运行",
    "tail": "相同的代码",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "子进程",
    "relation": "具有",
    "tail": "相同的属性",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "进程池",
    "relation": "使用",
    "tail": "共享工作队列",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "线程池",
    "relation": "使用",
    "tail": "共享工作队列",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "主进程",
    "relation": "选择",
    "tail": "子进程",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "主进程",
    "relation": "使用",
    "tail": "随机算法",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "主进程",
    "relation": "使用",
    "tail": "Round Robin算法",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "子进程",
    "relation": "等待",
    "tail": "工作队列",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "主进程",
    "relation": "通知",
    "tail": "子进程",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "进程间通信",
    "relation": "实现方式",
    "tail": "管道",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "线程间通信",
    "relation": "实现方式",
    "tail": "共享全局数据",
    "source_topic": "什么是进程池和线程池？"
  },
  {
    "head": "信号",
    "relation": "实现方式",
    "tail": "信号处理器",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "信号量",
    "relation": "实现方式",
    "tail": "P,V操作",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "消息队列",
    "relation": "属于",
    "tail": "进程间通信方式",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "消息队列",
    "relation": "核心特性",
    "tail": "可以在进程间传送message",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "消息队列",
    "relation": "核心特性",
    "tail": "支持传送普通字符串",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "消息队列",
    "relation": "核心特性",
    "tail": "可以被多个进程共享",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "消息队列",
    "relation": "核心特性",
    "tail": "消息包含标志以指定接收进程",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "共享内存",
    "relation": "属于",
    "tail": "进程间通信方式",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "共享内存",
    "relation": "核心特性",
    "tail": "映射一段能被其他进程访问的内存",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "共享内存",
    "relation": "核心特性",
    "tail": "最快的IPC方式",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "共享内存",
    "relation": "配合使用",
    "tail": "信号量",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "套接字",
    "relation": "属于",
    "tail": "进程间通信机制",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "套接字",
    "relation": "核心特性",
    "tail": "可用于不同机器间的进程通信",
    "source_topic": "进程间的通信方式有哪些？如何实现的？"
  },
  {
    "head": "普通B/S模式",
    "relation": "属于",
    "tail": "同步",
    "source_topic": "简述inux中的同步与异步机制？"
  },
  {
    "head": "ajax请求",
    "relation": "属于",
    "tail": "异步",
    "source_topic": "简述inux中的同步与异步机制？"
  },
  {
    "head": "异步",
    "relation": "对比",
    "tail": "同步",
    "source_topic": "简述inux中的同步与异步机制？"
  },
  {
    "head": "阻塞调用",
    "relation": "特性",
    "tail": "函数只有在得到结果之后才会返回",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "同步IO",
    "relation": "区别",
    "tail": "数据拷贝的时候进程是否阻塞",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "异步IO",
    "relation": "区别",
    "tail": "数据拷贝的时候进程是否阻塞",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "阻塞IO",
    "relation": "区别",
    "tail": "应用程序的调用是否立即返回",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "非阻塞IO",
    "relation": "区别",
    "tail": "应用程序的调用是否立即返回",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "同步",
    "relation": "与",
    "tail": "异步",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "阻塞",
    "relation": "与",
    "tail": "非阻塞",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "同步",
    "relation": "不同",
    "tail": "阻塞",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "异步",
    "relation": "不同",
    "tail": "非阻塞",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "同步",
    "relation": "修饰对象",
    "tail": "调用逻辑",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "异步",
    "relation": "修饰对象",
    "tail": "调用逻辑",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "阻塞",
    "relation": "修饰对象",
    "tail": "函数调用",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "非阻塞",
    "relation": "修饰对象",
    "tail": "函数调用",
    "source_topic": "319.简述阻塞与非阻塞？"
  },
  {
    "head": "阻塞I/O",
    "relation": "属于",
    "tail": "同步I/O",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "非阻塞I/O",
    "relation": "属于",
    "tail": "同步I/O",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "I/O复用",
    "relation": "包含",
    "tail": "select",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "I/O复用",
    "relation": "包含",
    "tail": "poll",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "I/O复用",
    "relation": "包含",
    "tail": "epoll",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "信号驱动I/O",
    "relation": "属于",
    "tail": "同步I/O",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "select",
    "relation": "基于",
    "tail": "轮询",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "select",
    "relation": "限制",
    "tail": "1024连接",
    "source_topic": "320.简述Linux中的5种I/O模式？"
  },
  {
    "head": "死锁",
    "relation": "属于",
    "tail": "进程阻塞现象",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "死锁",
    "relation": "导致",
    "tail": "系统卡死",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "死锁",
    "relation": "产生原因",
    "tail": "竞争资源",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "死锁",
    "relation": "产生原因",
    "tail": "进程推进顺序非法",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "互斥条件",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "请求和保持条件",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "不剥夺条件",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "环路等待条件",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "避免死锁",
    "relation": "方法",
    "tail": "银行家算法",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "银行家算法",
    "relation": "功能",
    "tail": "判断资源请求是否会导致死锁",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "解决死锁",
    "relation": "方法",
    "tail": "预防",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "解决死锁",
    "relation": "方法",
    "tail": "避免",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "解决死锁",
    "relation": "方法",
    "tail": "检测与解除",
    "source_topic": "什么是死锁？四个死锁的条件？避免死锁的方法？"
  },
  {
    "head": "Linux",
    "relation": "包含",
    "tail": "实时进程",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "Linux",
    "relation": "包含",
    "tail": "普通进程",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "实时进程",
    "relation": "优先于",
    "tail": "普通进程",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "实时进程",
    "relation": "使用调度算法",
    "tail": "FIFO",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "实时进程",
    "relation": "使用调度算法",
    "tail": "RR",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "进程",
    "relation": "具有",
    "tail": "动态优先级",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "进程",
    "relation": "具有",
    "tail": "实时优先级",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "非实时进程",
    "relation": "具有",
    "tail": "静态优先级",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "实时优先级",
    "relation": "决定",
    "tail": "CPU时间分配",
    "source_topic": "Linux的任务调度机制是什么？"
  },
  {
    "head": "系统调用",
    "relation": "属于",
    "tail": "操作系统接口",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "系统调用",
    "relation": "位于",
    "tail": "Linux内核",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "Linux内核",
    "relation": "包含",
    "tail": "系统调用接口",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "Linux内核",
    "relation": "包含",
    "tail": "内核子系统",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "用户进程",
    "relation": "调用",
    "tail": "系统调用接口",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "系统调用接口",
    "relation": "连接",
    "tail": "Linux内核子系统",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "Linux内核子系统",
    "relation": "连接",
    "tail": "硬件",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "库函数",
    "relation": "属于",
    "tail": "编程库",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "库函数",
    "relation": "提供",
    "tail": "常用函数",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "库函数",
    "relation": "使用方式",
    "tail": "通过#include引用",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "系统调用",
    "relation": "目的",
    "tail": "方便使用操作系统接口",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "库函数",
    "relation": "目的",
    "tail": "方便编程",
    "source_topic": "323.标准库函数与系统调用的区别？"
  },
  {
    "head": "三次握手",
    "relation": "包含",
    "tail": "SYN K",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "三次握手",
    "relation": "包含",
    "tail": "ACK K+1 SYN J",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "三次握手",
    "relation": "包含",
    "tail": "ACK J+1",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "三次握手",
    "relation": "属于",
    "tail": "TCP连接建立过程",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "四次挥手",
    "relation": "属于",
    "tail": "TCP连接关闭过程",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "三次握手",
    "relation": "依赖",
    "tail": "socket",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "三次握手",
    "relation": "依赖",
    "tail": "bind",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "三次握手",
    "relation": "依赖",
    "tail": "listen",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "三次握手",
    "relation": "导致",
    "tail": "accept 函数解除阻塞",
    "source_topic": "分别简述三次握手与四次挥手的过程？"
  },
  {
    "head": "UDP",
    "relation": "基于",
    "tail": "无连接",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "消耗更多",
    "tail": "系统资源",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "UDP",
    "relation": "消耗较少",
    "tail": "系统资源",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "提供",
    "tail": "面向连接",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "提供",
    "tail": "可靠性",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "提供",
    "tail": "数据顺序",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "超时重发",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "丢弃重复数据",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "检验数据",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "流量控制",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "UDP",
    "relation": "不提供",
    "tail": "可靠性",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "UDP",
    "relation": "不提供",
    "tail": "数据顺序",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "UDP",
    "relation": "不包含",
    "tail": "超时重发",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "UDP",
    "relation": "不包含",
    "tail": "流量控制",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "有",
    "tail": "拥塞控制",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "UDP",
    "relation": "没有",
    "tail": "拥塞控制",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "TCP",
    "relation": "属于",
    "tail": "流模式",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "UDP",
    "relation": "属于",
    "tail": "数据报模式",
    "source_topic": "tcp和udp之间的区别？"
  },
  {
    "head": "Select机制",
    "relation": "基于",
    "tail": "轮询",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Select机制",
    "relation": "限制",
    "tail": "1024连接",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Poll机制",
    "relation": "基于",
    "tail": "轮询",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll机制",
    "relation": "基于",
    "tail": "回调机制",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll机制",
    "relation": "使用",
    "tail": "红黑树",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll机制",
    "relation": "支持",
    "tail": "大量连接",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Select机制",
    "relation": "属于",
    "tail": "I/O多路复用技术",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Poll机制",
    "relation": "属于",
    "tail": "I/O多路复用技术",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll机制",
    "relation": "属于",
    "tail": "I/O多路复用技术",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Select机制",
    "relation": "缺点",
    "tail": "性能下降",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Poll机制",
    "relation": "缺点",
    "tail": "性能下降",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll机制",
    "relation": "优点",
    "tail": "高效处理大量连接",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll机制",
    "relation": "核心特性",
    "tail": "边缘触发",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll机制",
    "relation": "核心特性",
    "tail": "水平触发",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Select机制",
    "relation": "核心特性",
    "tail": "水平触发",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Poll机制",
    "relation": "核心特性",
    "tail": "水平触发",
    "source_topic": "select、poll、epoll之间的区别？"
  },
  {
    "head": "Epoll",
    "relation": "包含",
    "tail": "EPOLLLT",
    "source_topic": "epoll有哪些触发模式？"
  },
  {
    "head": "Epoll",
    "relation": "包含",
    "tail": "EPOLLET",
    "source_topic": "epoll有哪些触发模式？"
  },
  {
    "head": "EPOLLLT",
    "relation": "属于",
    "tail": "触发模式",
    "source_topic": "epoll有哪些触发模式？"
  },
  {
    "head": "EPOLLET",
    "relation": "属于",
    "tail": "触发模式",
    "source_topic": "epoll有哪些触发模式？"
  },
  {
    "head": "EPOLLLT",
    "relation": "默认模式",
    "tail": "Epoll",
    "source_topic": "epoll有哪些触发模式？"
  },
  {
    "head": "EPOLLET",
    "relation": "别称",
    "tail": "高速模式",
    "source_topic": "epoll有哪些触发模式？"
  },
  {
    "head": "EPOLLET",
    "relation": "解决",
    "tail": "避免数据丢失",
    "source_topic": "epoll有哪些触发模式？"
  },
  {
    "head": "Epoll",
    "relation": "属于",
    "tail": "并发模型",
    "source_topic": "若是有大规模的数据连接，并发模型如何设计？"
  },
  {
    "head": "线程池",
    "relation": "属于",
    "tail": "并发模型",
    "source_topic": "若是有大规模的数据连接，并发模型如何设计？"
  },
  {
    "head": "Epoll",
    "relation": "解决",
    "tail": "大规模数据连接",
    "source_topic": "若是有大规模的数据连接，并发模型如何设计？"
  },
  {
    "head": "线程池",
    "relation": "解决",
    "tail": "大规模数据连接",
    "source_topic": "若是有大规模的数据连接，并发模型如何设计？"
  },
  {
    "head": "Epoll",
    "relation": "采用",
    "tail": "libevent",
    "source_topic": "若是有大规模的数据连接，并发模型如何设计？"
  },
  {
    "head": "C++语言",
    "relation": "核心特性",
    "tail": "封装",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C语言",
    "relation": "动态内存管理方法",
    "tail": "malloc/free",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C++语言",
    "relation": "动态内存管理方法",
    "tail": "new/delete",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C++语言",
    "relation": "包含",
    "tail": "引用",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C语言",
    "relation": "不包含",
    "tail": "引用",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "指针",
    "relation": "存储",
    "tail": "变量地址",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "属于",
    "tail": "变量别名",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "操作",
    "tail": "变量本身",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "指针",
    "relation": "支持",
    "tail": "多级指针",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "限制",
    "tail": "一级",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "指针传参",
    "relation": "基于",
    "tail": "值传递",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "指针传参",
    "relation": "需要",
    "tail": "解引用操作",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "引用传参",
    "relation": "传递",
    "tail": "变量本身",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "引用传参",
    "relation": "允许",
    "tail": "直接修改变量",
    "source_topic": "C++中指针和引用的区别"
  },
  {
    "head": "结构体",
    "relation": "属于",
    "tail": "自定义类型",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "共同体",
    "relation": "属于",
    "tail": "自定义类型",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "独立地址的成员",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "共同体",
    "relation": "包含",
    "tail": "共享同一段内存的成员",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "结构体",
    "relation": "核心特性",
    "tail": "成员同时存在",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "共同体",
    "relation": "核心特性",
    "tail": "成员不能同时存在",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "结构体",
    "relation": "计算方式",
    "tail": "内存对齐后所有成员长度的总和",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "共同体",
    "relation": "计算方式",
    "tail": "内存对齐后最长数据成员的长度",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "内存对齐",
    "relation": "解决",
    "tail": "硬件平台访问异常",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "内存对齐",
    "relation": "导致",
    "tail": "CPU内存访问速度提升",
    "source_topic": "结构体struct和共同体union（联合）的区别"
  },
  {
    "head": "#define",
    "relation": "区别",
    "tail": "没有类型",
    "source_topic": "define和const的区别"
  },
  {
    "head": "const",
    "relation": "区别",
    "tail": "有类型名字",
    "source_topic": "define和const的区别"
  },
  {
    "head": "#define",
    "relation": "处理阶段",
    "tail": "预处理时进行替换",
    "source_topic": "define和const的区别"
  },
  {
    "head": "const",
    "relation": "处理阶段",
    "tail": "编译时确定其值",
    "source_topic": "define和const的区别"
  },
  {
    "head": "#define",
    "relation": "拷贝数量",
    "tail": "可能有多个拷贝",
    "source_topic": "define和const的区别"
  },
  {
    "head": "const",
    "relation": "拷贝数量",
    "tail": "只有一个拷贝",
    "source_topic": "define和const的区别"
  },
  {
    "head": "#define",
    "relation": "限制",
    "tail": "不可以用指针去指向",
    "source_topic": "define和const的区别"
  },
  {
    "head": "const",
    "relation": "支持",
    "tail": "可以用指针去指向该常量的地址",
    "source_topic": "define和const的区别"
  },
  {
    "head": "#define",
    "relation": "功能",
    "tail": "可以定义简单的函数",
    "source_topic": "define和const的区别"
  },
  {
    "head": "const",
    "relation": "限制",
    "tail": "不可以定义函数",
    "source_topic": "define和const的区别"
  },
  {
    "head": "函数重载",
    "relation": "属于",
    "tail": "overload",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "函数重写",
    "relation": "属于",
    "tail": "override",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "函数隐藏",
    "relation": "属于",
    "tail": "overwrite",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "overload",
    "relation": "特征",
    "tail": "相同范围（同一个类中）",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "overload",
    "relation": "特征",
    "tail": "函数名字相同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "overload",
    "relation": "特征",
    "tail": "参数不同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "overload",
    "relation": "特征",
    "tail": "返回值类型可以不同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "override",
    "relation": "特征",
    "tail": "不同范围（基类和派生类）",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "override",
    "relation": "特征",
    "tail": "函数名字相同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "override",
    "relation": "特征",
    "tail": "参数相同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "override",
    "relation": "特征",
    "tail": "返回值类型必须相同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "overwrite",
    "relation": "特征",
    "tail": "不同范围（基类和派生类）",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "overwrite",
    "relation": "特征",
    "tail": "函数名字相同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "overwrite",
    "relation": "特征",
    "tail": "返回值类型可以不同",
    "source_topic": "重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "new",
    "relation": "核心特性",
    "tail": "调用构造函数",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "delete",
    "relation": "核心特性",
    "tail": "调用析构函数",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "malloc",
    "relation": "核心特性",
    "tail": "不调用构造函数",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "free",
    "relation": "核心特性",
    "tail": "不调用析构函数",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "new",
    "relation": "解决",
    "tail": "无法初始化对象的问题",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "delete",
    "relation": "解决",
    "tail": "无法析构对象的问题",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "malloc/free",
    "relation": "限制",
    "tail": "无法处理非内部数据类型",
    "source_topic": "new、delete、malloc、free之间的关系"
  },
  {
    "head": "delete",
    "relation": "释放内存",
    "tail": "new分配的内存",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "delete[]",
    "relation": "释放内存",
    "tail": "new[]分配的内存",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "delete",
    "relation": "调用析构函数次数",
    "tail": "一次",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "delete[]",
    "relation": "调用析构函数次数",
    "tail": "每个成员一次",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "构造函数",
    "relation": "作用",
    "tail": "实现对象的初始化",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "构造函数",
    "relation": "特点",
    "tail": "没有类型",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "构造函数",
    "relation": "特点",
    "tail": "没有返回值",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "构造函数",
    "relation": "特点",
    "tail": "名字与类名相同",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "构造函数",
    "relation": "特点",
    "tail": "可重载",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "作用",
    "tail": "在对象被删除前做清理工作",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "没有类型",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "没有返回值",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "名字与类名相同",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "不带参数",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "特点",
    "tail": "不可重载",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "调用时机",
    "tail": "对象被销毁前",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "调用次数",
    "tail": "每个对象一次",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "动态对象",
    "relation": "销毁方式",
    "tail": "使用delete运算符",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "调用顺序",
    "tail": "最先构造的最后被析构",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "析构函数",
    "relation": "调用顺序",
    "tail": "最后构造的最先被析构",
    "source_topic": "delete和delete[]的区别"
  },
  {
    "head": "虚函数",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "虚函数",
    "relation": "核心特性",
    "tail": "动态绑定",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "定义",
    "tail": "基类中没有定义的虚函数",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "要求",
    "tail": "派生类必须定义实现方法",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "声明方式",
    "tail": "函数原型后加=0",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "导致",
    "tail": "类成为抽象类",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "定义",
    "tail": "包含纯虚函数的类",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "限制",
    "tail": "不能定义实例",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "用途",
    "tail": "作为继承层次结构的公共根",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "用途",
    "tail": "规范派生类的行为",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "动态绑定",
    "relation": "基于",
    "tail": "虚函数",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "动态绑定",
    "relation": "确定",
    "tail": "运行时调用的函数版本",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "静态类型",
    "relation": "定义",
    "tail": "对象在程序中被声明时采用的类型",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "动态类型",
    "relation": "定义",
    "tail": "当前所指对象的类型",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "动态类型",
    "relation": "可以改变",
    "tail": "执行过程中通过赋值运算",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "虚函数",
    "relation": "实现",
    "tail": "基类和派生类各自版本",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "虚函数",
    "relation": "解决",
    "tail": "多态性",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "析构函数",
    "relation": "必须是",
    "tail": "虚函数",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "引入目的",
    "tail": "安全",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "引入目的",
    "tail": "提高编码效率",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "规范",
    "tail": "派生类的行为",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "包含",
    "tail": "纯虚函数",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "只能作为",
    "tail": "基类",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "不能定义",
    "tail": "实例",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "可以声明",
    "tail": "指向具体类的指针或引用",
    "source_topic": "虚函数、纯虚函数"
  },
  {
    "head": "STL库",
    "relation": "包含",
    "tail": "容器",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "STL库",
    "relation": "包含",
    "tail": "算法",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "容器",
    "relation": "分类",
    "tail": "序列式容器",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "容器",
    "relation": "分类",
    "tail": "关联式容器",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "序列式容器",
    "relation": "包含",
    "tail": "vector",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "序列式容器",
    "relation": "包含",
    "tail": "list",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "序列式容器",
    "relation": "包含",
    "tail": "queue",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "序列式容器",
    "relation": "包含",
    "tail": "stack",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "序列式容器",
    "relation": "包含",
    "tail": "heap",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "序列式容器",
    "relation": "包含",
    "tail": "priority-queue",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "序列式容器",
    "relation": "包含",
    "tail": "slist",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "关联式容器",
    "relation": "底层结构",
    "tail": "平衡二叉树",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "关联式容器",
    "relation": "包含",
    "tail": "map",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "关联式容器",
    "relation": "包含",
    "tail": "set",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "关联式容器",
    "relation": "包含",
    "tail": "hashtable",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "关联式容器",
    "relation": "包含",
    "tail": "hash_set",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "算法",
    "relation": "包含",
    "tail": "排序",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "算法",
    "relation": "包含",
    "tail": "复制",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "迭代器",
    "relation": "属于",
    "tail": "STL精髓",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "迭代器",
    "relation": "作用",
    "tail": "顺序访问容器元素",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "迭代器",
    "relation": "隔离",
    "tail": "容器内部结构",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "属于",
    "tail": "序列式容器",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "动态数组",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "支持",
    "tail": "随机存取",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "支持",
    "tail": "插入",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "支持",
    "tail": "查找",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "内存结构",
    "tail": "连续空间",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "动态扩容",
    "tail": "两倍原空间",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "导致",
    "tail": "迭代器失效",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "重新配置空间",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "拷贝原内容",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "释放原空间",
    "source_topic": "STL库用过吗？常见的STL容器有哪些？算法用过几个？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "类的成员变量",
    "source_topic": "const知道吗？解释一下其作用"
  },
  {
    "head": "const",
    "relation": "表示",
    "tail": "常量不可能被修改",
    "source_topic": "const知道吗？解释一下其作用"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "类的成员函数",
    "source_topic": "const知道吗？解释一下其作用"
  },
  {
    "head": "const",
    "relation": "表示",
    "tail": "该函数不会修改类中的数据成员",
    "source_topic": "const知道吗？解释一下其作用"
  },
  {
    "head": "虚函数",
    "relation": "实现方式",
    "tail": "虚函数表",
    "source_topic": "虚函数是怎么实现的"
  },
  {
    "head": "虚函数表",
    "relation": "包含",
    "tail": "函数指针",
    "source_topic": "虚函数是怎么实现的"
  },
  {
    "head": "类的示例对象",
    "relation": "不包含",
    "tail": "虚函数表",
    "source_topic": "虚函数是怎么实现的"
  },
  {
    "head": "类的示例对象",
    "relation": "包含",
    "tail": "虚指针",
    "source_topic": "虚函数是怎么实现的"
  },
  {
    "head": "派生类",
    "relation": "生成",
    "tail": "兼容基类的虚函数表",
    "source_topic": "虚函数是怎么实现的"
  },
  {
    "head": "自由存储区",
    "relation": "属于",
    "tail": "C++内存区域",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "全局/静态存储区",
    "relation": "属于",
    "tail": "C++内存区域",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "常量存储区",
    "relation": "属于",
    "tail": "C++内存区域",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "自由存储区",
    "relation": "分配方式",
    "tail": "由malloc分配",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "自由存储区",
    "relation": "释放方式",
    "tail": "由free释放",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存放",
    "tail": "全局变量",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存放",
    "tail": "静态变量",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "常量存储区",
    "relation": "存放",
    "tail": "常量",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "进程内存映像",
    "relation": "包含",
    "tail": "代码区",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "进程内存映像",
    "relation": "包含",
    "tail": "静态存储区",
    "source_topic": "堆和栈的区别"
  },
  {
    "head": "static",
    "relation": "修饰",
    "tail": "局部变量",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static修饰的局部变量",
    "relation": "作用范围",
    "tail": "函数体",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static修饰的局部变量",
    "relation": "内存分配",
    "tail": "只被分配一次",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static修饰的局部变量",
    "relation": "值维持",
    "tail": "下次调用时维持上次的值",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static",
    "relation": "修饰",
    "tail": "全局变量",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static",
    "relation": "修饰",
    "tail": "全局函数",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static",
    "relation": "修饰",
    "tail": "成员变量",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static成员变量",
    "relation": "归属",
    "tail": "整个类",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static成员变量",
    "relation": "拷贝数量",
    "tail": "只有一份拷贝",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static",
    "relation": "修饰",
    "tail": "成员函数",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static成员函数",
    "relation": "归属",
    "tail": "整个类",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static成员函数",
    "relation": "参数",
    "tail": "不接受this指针",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static",
    "relation": "区别",
    "tail": "const",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "const",
    "relation": "强调",
    "tail": "值不能被修改",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "static",
    "relation": "强调",
    "tail": "唯一的拷贝",
    "source_topic": "关键字static的作用"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "STL中map和set的原理（关联式容器）"
  },
  {
    "head": "set",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "STL中map和set的原理（关联式容器）"
  },
  {
    "head": "内存泄漏",
    "relation": "解决方法",
    "tail": "malloc/free要配套",
    "source_topic": "什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？"
  },
  {
    "head": "指针越界",
    "relation": "解决方法",
    "tail": "使用的时候记得指针的长度",
    "source_topic": "什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？"
  },
  {
    "head": "声明",
    "relation": "属于",
    "tail": "编程概念",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "定义",
    "relation": "属于",
    "tail": "编程概念",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "声明",
    "relation": "功能",
    "tail": "告诉编译器变量的类型和名字",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "定义",
    "relation": "功能",
    "tail": "为变量分配空间",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "声明",
    "relation": "限制",
    "tail": "不分配空间",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "定义",
    "relation": "限制",
    "tail": "只能被定义一次",
    "source_topic": "定义和声明的区别"
  },
  {
    "head": "C++文件编译与执行",
    "relation": "包含",
    "tail": "预处理",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "C++文件编译与执行",
    "relation": "包含",
    "tail": "编译",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "C++文件编译与执行",
    "relation": "包含",
    "tail": "汇编",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "C++文件编译与执行",
    "relation": "包含",
    "tail": "链接",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "属于",
    "tail": "动态增长的数组",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "包含",
    "tail": "指针",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "指向",
    "tail": "连续的空间",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "对比",
    "tail": "array",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "array",
    "relation": "具有",
    "tail": "静态空间",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "申请更大的空间",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "拷贝原数据",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "释放旧空间",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "扩容策略",
    "tail": "原大小的两倍",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "扩容策略",
    "tail": "VS下1.5倍",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "vector",
    "relation": "扩容策略",
    "tail": "GCC下2倍",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "频繁调用push_back()",
    "relation": "导致",
    "tail": "性能下降",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "频繁调用push_back()",
    "relation": "原因",
    "tail": "扩容操作频繁",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "扩容操作",
    "relation": "导致",
    "tail": "数据拷贝",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "数据拷贝",
    "relation": "导致",
    "tail": "时间开销增加",
    "source_topic": "C++文件编译与执行的四个阶段"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "数据有序",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "map",
    "relation": "查询时间复杂度",
    "tail": "O(logN)",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "map",
    "relation": "插入时间复杂度",
    "tail": "O(logN)",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "map",
    "relation": "删除时间复杂度",
    "tail": "O(logN)",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "unordered_map",
    "relation": "底层结构",
    "tail": "哈希表",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "unordered_map",
    "relation": "核心特性",
    "tail": "数据无序",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "unordered_map",
    "relation": "查询时间复杂度",
    "tail": "O(1)",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "unordered_map",
    "relation": "插入时间复杂度",
    "tail": "O(1)",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "unordered_map",
    "relation": "删除时间复杂度",
    "tail": "O(1)",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "map",
    "relation": "分类",
    "tail": "关联容器",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "unordered_map",
    "relation": "分类",
    "tail": "关联容器",
    "source_topic": "STL中unordered_map和map的区别"
  },
  {
    "head": "C++内存管理",
    "relation": "包含",
    "tail": "自由存储区",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "C++内存管理",
    "relation": "包含",
    "tail": "全局/静态存储区",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "C++内存管理",
    "relation": "包含",
    "tail": "常量区",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "自由存储区",
    "relation": "分配",
    "tail": "malloc",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "自由存储区",
    "relation": "释放",
    "tail": "free",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存放",
    "tail": "全局变量",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存放",
    "tail": "静态变量",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "常量区",
    "relation": "存放",
    "tail": "常量",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "常量区",
    "relation": "特性",
    "tail": "不允许被修改",
    "source_topic": "C++的内存管理"
  },
  {
    "head": "构造函数",
    "relation": "不能声明为",
    "tail": "虚函数",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "构造函数",
    "relation": "原因",
    "tail": "创建对象时需要确定对象的类型",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "构造函数",
    "relation": "原因",
    "tail": "虚函数在运行时确定类型",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "构造函数",
    "relation": "原因",
    "tail": "虚函数表指针需要对象内存空间",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "析构函数",
    "relation": "最好声明为",
    "tail": "虚函数",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "析构函数",
    "relation": "原因",
    "tail": "避免内存泄露",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "析构函数",
    "relation": "原因",
    "tail": "静态绑定导致派生类析构不被调用",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "析构函数",
    "relation": "调用顺序",
    "tail": "先派生类后基类",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "析构函数",
    "relation": "调用顺序",
    "tail": "与构造函数相反",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "析构函数",
    "relation": "自动调用",
    "tail": "无需显式调用",
    "source_topic": "构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？"
  },
  {
    "head": "静态绑定",
    "relation": "属于",
    "tail": "C++多态性",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态绑定",
    "relation": "属于",
    "tail": "C++多态性",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态类型",
    "relation": "特性",
    "tail": "静态类型无法更改",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态类型",
    "relation": "特性",
    "tail": "对象的动态类型可变",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态绑定",
    "relation": "绑定依据",
    "tail": "对象的静态类型",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态绑定",
    "relation": "确定时间",
    "tail": "编译期",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态绑定",
    "relation": "绑定依据",
    "tail": "对象的动态类型",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态绑定",
    "relation": "确定时间",
    "tail": "运行期",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "动态绑定",
    "relation": "使用条件",
    "tail": "虚函数",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "静态绑定",
    "relation": "使用条件",
    "tail": "非虚函数",
    "source_topic": "静态绑定和动态绑定的介绍"
  },
  {
    "head": "引用",
    "relation": "实现",
    "tail": "动态绑定",
    "source_topic": "引用是否能实现动态绑定，为什么引用可以实现"
  },
  {
    "head": "引用",
    "relation": "支持",
    "tail": "指向基类对象",
    "source_topic": "引用是否能实现动态绑定，为什么引用可以实现"
  },
  {
    "head": "引用",
    "relation": "支持",
    "tail": "指向派生类对象",
    "source_topic": "引用是否能实现动态绑定，为什么引用可以实现"
  },
  {
    "head": "动态绑定",
    "relation": "依赖",
    "tail": "运行时确定虚函数调用",
    "source_topic": "引用是否能实现动态绑定，为什么引用可以实现"
  },
  {
    "head": "虚函数调用",
    "relation": "基于",
    "tail": "引用所指对象的实际类型",
    "source_topic": "引用是否能实现动态绑定，为什么引用可以实现"
  },
  {
    "head": "深拷贝",
    "relation": "区别",
    "tail": "浅拷贝",
    "source_topic": "深拷贝和浅拷贝的区别"
  },
  {
    "head": "深拷贝",
    "relation": "定义",
    "tail": "资源重新分配",
    "source_topic": "深拷贝和浅拷贝的区别"
  },
  {
    "head": "浅拷贝",
    "relation": "定义",
    "tail": "没有重新分配资源",
    "source_topic": "深拷贝和浅拷贝的区别"
  },
  {
    "head": "普通构造函数",
    "relation": "生成方式",
    "tail": "系统自动生成",
    "source_topic": "什么情况下会调用拷贝构造函数（三种情况）"
  },
  {
    "head": "拷贝构造函数",
    "relation": "生成方式",
    "tail": "系统自动生成",
    "source_topic": "什么情况下会调用拷贝构造函数（三种情况）"
  },
  {
    "head": "对象实例化",
    "relation": "调用",
    "tail": "普通构造函数",
    "source_topic": "什么情况下会调用拷贝构造函数（三种情况）"
  },
  {
    "head": "对象实例化",
    "relation": "调用",
    "tail": "拷贝构造函数",
    "source_topic": "什么情况下会调用拷贝构造函数（三种情况）"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "static_cast",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "dynamic_cast",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "const_cast",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "static_cast",
    "relation": "执行",
    "tail": "编译时期的静态类型检查",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "static_cast",
    "relation": "操作",
    "tail": "类型检查",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "static_cast",
    "relation": "操作",
    "tail": "指针越界检测",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "dynamic_cast",
    "relation": "执行",
    "tail": "运行时类型检查",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "dynamic_cast",
    "relation": "用于",
    "tail": "安全的向下转换",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "dynamic_cast",
    "relation": "要求",
    "tail": "源类包含虚函数",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "dynamic_cast",
    "relation": "返回",
    "tail": "NULL",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "dynamic_cast",
    "relation": "抛出",
    "tail": "bad_cast",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "const_cast",
    "relation": "用于",
    "tail": "去除const属性",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "const_cast",
    "relation": "用于",
    "tail": "转换volatile属性",
    "source_topic": "C++的四种强制转换"
  },
  {
    "head": "Visual Studio",
    "relation": "支持",
    "tail": "Debug功能",
    "source_topic": "调试程序的方法"
  },
  {
    "head": "GDB",
    "relation": "支持",
    "tail": "添加断点",
    "source_topic": "调试程序的方法"
  },
  {
    "head": "GDB",
    "relation": "支持",
    "tail": "监视程序行为",
    "source_topic": "调试程序的方法"
  },
  {
    "head": "Debug功能",
    "relation": "用于",
    "tail": "调试程序",
    "source_topic": "调试程序的方法"
  },
  {
    "head": "GDB",
    "relation": "用于",
    "tail": "调试程序",
    "source_topic": "调试程序的方法"
  },
  {
    "head": "define",
    "relation": "属于",
    "tail": "预处理命令",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "预处理命令",
    "relation": "执行方式",
    "tail": "简单的替换",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "预处理命令",
    "relation": "不执行",
    "tail": "正确性检查",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "typedef",
    "relation": "处理阶段",
    "tail": "编译时",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "typedef",
    "relation": "作用",
    "tail": "给已存在的类型定义别名",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "typedef",
    "relation": "作用域",
    "tail": "自己的作用域内",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "typedef",
    "relation": "定义",
    "tail": "int*",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "pINT",
    "relation": "别名",
    "tail": "int*",
    "source_topic": "define是预处理命令，在预处理是执行简单的替换，不做正确性的检查"
  },
  {
    "head": "pINT",
    "relation": "定义",
    "tail": "int*",
    "source_topic": "define pINT2 int*"
  },
  {
    "head": "pINT",
    "relation": "效果相同",
    "tail": "int *a; int *b;",
    "source_topic": "define pINT2 int*"
  },
  {
    "head": "pINT a,b",
    "relation": "效果相同",
    "tail": "int *a; int *b;",
    "source_topic": "define pINT2 int*"
  },
  {
    "head": "pINT2 a,b",
    "relation": "效果相同",
    "tail": "int *a, b;",
    "source_topic": "define pINT2 int*"
  },
  {
    "head": "pINT2",
    "relation": "定义",
    "tail": "int*",
    "source_topic": "define pINT2 int*"
  },
  {
    "head": "引用传参",
    "relation": "提高",
    "tail": "函数调用和运行效率",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "引用传参",
    "relation": "允许修改",
    "tail": "外部实参的值",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "值传递",
    "relation": "限制",
    "tail": "参数的值只能传入",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "引用传递",
    "relation": "底层结构",
    "tail": "间接寻址",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "引用传递",
    "relation": "基于",
    "tail": "实参变量的地址",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "引用作为返回值",
    "relation": "避免",
    "tail": "内存中产生被返回值的副本",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "引用作为返回值",
    "relation": "限制",
    "tail": "不能返回局部变量的引用",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "引用作为返回值",
    "relation": "建议",
    "tail": "返回类成员的const引用",
    "source_topic": "引用作为函数参数以及返回值的好处"
  },
  {
    "head": "纯虚函数",
    "relation": "属于",
    "tail": "虚函数",
    "source_topic": "纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "作用",
    "tail": "对子类的约束",
    "source_topic": "纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "实现方式",
    "tail": "只有声明没有实现",
    "source_topic": "纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "分类归属",
    "tail": "接口继承",
    "source_topic": "纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "定义",
    "tail": "包含纯虚函数的类",
    "source_topic": "纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "限制",
    "tail": "不能被实例化",
    "source_topic": "纯虚函数"
  },
  {
    "head": "子类",
    "relation": "实现",
    "tail": "纯虚函数",
    "source_topic": "纯虚函数"
  },
  {
    "head": "子类",
    "relation": "允许",
    "tail": "生成对象",
    "source_topic": "纯虚函数"
  },
  {
    "head": "野指针",
    "relation": "定义",
    "tail": "未初始化或者未清零的指针",
    "source_topic": "什么是野指针"
  },
  {
    "head": "野指针",
    "relation": "指向",
    "tail": "内存地址",
    "source_topic": "什么是野指针"
  },
  {
    "head": "野指针",
    "relation": "可能指向",
    "tail": "受限的内存",
    "source_topic": "什么是野指针"
  },
  {
    "head": "野指针",
    "relation": "成因",
    "tail": "指针变量没有被初始化",
    "source_topic": "什么是野指针"
  },
  {
    "head": "野指针",
    "relation": "成因",
    "tail": "指针超过了变量的作用范围",
    "source_topic": "什么是野指针"
  },
  {
    "head": "线程安全",
    "relation": "采用",
    "tail": "加锁机制",
    "source_topic": "线程安全和线程不安全"
  },
  {
    "head": "线程安全",
    "relation": "保证",
    "tail": "数据一致性",
    "source_topic": "线程安全和线程不安全"
  },
  {
    "head": "线程安全",
    "relation": "防止",
    "tail": "数据污染",
    "source_topic": "线程安全和线程不安全"
  },
  {
    "head": "线程不安全",
    "relation": "缺乏",
    "tail": "数据访问保护",
    "source_topic": "线程安全和线程不安全"
  },
  {
    "head": "线程不安全",
    "relation": "可能导致",
    "tail": "脏数据",
    "source_topic": "线程安全和线程不安全"
  },
  {
    "head": "内存泄漏",
    "relation": "导致",
    "tail": "程序运行速度减慢",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "内存泄漏",
    "relation": "导致",
    "tail": "系统崩溃",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "构造函数",
    "relation": "包含",
    "tail": "new",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "析构函数",
    "relation": "包含",
    "tail": "delete",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "new",
    "relation": "未配套",
    "tail": "delete",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "delete",
    "relation": "未配套",
    "tail": "new",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "delete",
    "relation": "错误使用",
    "tail": "释放对象数组",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "delete[]",
    "relation": "正确使用",
    "tail": "释放对象数组",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "基类析构函数",
    "relation": "未定义为",
    "tail": "虚函数",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "基类指针",
    "relation": "指向",
    "tail": "子类对象",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "子类析构函数",
    "relation": "未被调用",
    "tail": "基类析构函数不是虚函数",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "子类资源",
    "relation": "未正确释放",
    "tail": "子类析构函数未被调用",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "嵌套对象指针",
    "relation": "未正确清除",
    "tail": "内存泄漏",
    "source_topic": "C++中内存泄漏的几种情况"
  },
  {
    "head": "栈溢出",
    "relation": "导致",
    "tail": "函数调用层次过深",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "栈溢出",
    "relation": "导致",
    "tail": "局部变量体积太大",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "栈溢出",
    "relation": "包含情况",
    "tail": "分配的大小超过栈的最大值",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "栈溢出",
    "relation": "解决方法",
    "tail": "增加栈内存的数目",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "栈溢出",
    "relation": "解决方法",
    "tail": "使用堆内存",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "局部变量",
    "relation": "解决方法",
    "tail": "动态申请内存",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "局部变量",
    "relation": "解决方法",
    "tail": "定义为全局变量",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "局部变量",
    "relation": "解决方法",
    "tail": "定义前加static",
    "source_topic": "栈溢出的原因以及解决方法"
  },
  {
    "head": "C++标准库vector",
    "relation": "定义",
    "tail": "迭代器类型",
    "source_topic": "C++标准库vector以及迭代器"
  },
  {
    "head": "C++标准库vector",
    "relation": "包含",
    "tail": "begin函数",
    "source_topic": "C++标准库vector以及迭代器"
  },
  {
    "head": "C++标准库vector",
    "relation": "包含",
    "tail": "end函数",
    "source_topic": "C++标准库vector以及迭代器"
  },
  {
    "head": "迭代器",
    "relation": "属于",
    "tail": "容器类型",
    "source_topic": "C++标准库vector以及迭代器"
  },
  {
    "head": "迭代器",
    "relation": "提供",
    "tail": "顺序访问容器元素的方法",
    "source_topic": "C++标准库vector以及迭代器"
  },
  {
    "head": "迭代器",
    "relation": "隔离",
    "tail": "容器内部结构",
    "source_topic": "C++标准库vector以及迭代器"
  },
  {
    "head": "迭代器",
    "relation": "实现",
    "tail": "容器与算法的分离",
    "source_topic": "C++标准库vector以及迭代器"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "连续内存空间",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "支持随机存取",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "双向链表",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "内存空间不连续",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "插入和删除操作高效",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "list::iterator",
    "relation": "不支持操作",
    "tail": "+=",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "list::iterator",
    "relation": "支持操作",
    "tail": "++",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "vector",
    "relation": "适用场景",
    "tail": "高效的随机存取",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "list",
    "relation": "适用场景",
    "tail": "大量的插入和删除",
    "source_topic": "C++中vector和list的区别"
  },
  {
    "head": "int",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "float",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "double",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "char",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "bool",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "void",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "short",
    "relation": "修饰",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "long",
    "relation": "修饰",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "signed",
    "relation": "修饰",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "unsigned",
    "relation": "修饰",
    "tail": "C++基本数据类型",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "派生类型",
    "relation": "由...声明符组成",
    "tail": "基本类型关键字",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "派生类型",
    "relation": "由...声明符组成",
    "tail": "类型修饰符",
    "source_topic": "C++中的基本数据类型及派生类型"
  },
  {
    "head": "友元函数",
    "relation": "属于",
    "tail": "非成员函数",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元函数",
    "relation": "声明于",
    "tail": "类定义中",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元函数",
    "relation": "可以访问",
    "tail": "类的私有成员",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元函数",
    "relation": "可以访问",
    "tail": "类的保护成员",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元类",
    "relation": "声明于",
    "tail": "类定义中",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元类",
    "relation": "所有成员函数",
    "tail": "可以访问另一个类的私有成员",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元类",
    "relation": "所有成员函数",
    "tail": "可以访问另一个类的保护成员",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元关系",
    "relation": "不具有",
    "tail": "继承性",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元关系",
    "relation": "是",
    "tail": "单向的",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "友元关系",
    "relation": "不具有",
    "tail": "传递性",
    "source_topic": "友元函数和友元类"
  },
  {
    "head": "__gcd",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "reverse",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "unique",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "lower_bound",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "upper_bound",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "fill",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "reverse",
    "relation": "功能",
    "tail": "反转数组元素",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "unique",
    "relation": "功能",
    "tail": "去重数组元素",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "lower_bound",
    "relation": "功能",
    "tail": "查找第一个大于等于x的元素位置",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "upper_bound",
    "relation": "功能",
    "tail": "查找第一个大于x的元素位置",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "fill",
    "relation": "功能",
    "tail": "填充数组元素为指定值",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "fill",
    "relation": "区别",
    "tail": "memset按字节填充",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "memset",
    "relation": "限制",
    "tail": "仅适用于char型数组",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "fill",
    "relation": "区别",
    "tail": "fill适用于int型数组",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "unique",
    "relation": "返回值",
    "tail": "最后一个去重元素的地址",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "lower_bound",
    "relation": "时间复杂度",
    "tail": "O(logn)",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "upper_bound",
    "relation": "时间复杂度",
    "tail": "O(logn)",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "reverse",
    "relation": "适用数据结构",
    "tail": "数组",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "reverse",
    "relation": "适用数据结构",
    "tail": "字符型数组",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "unique",
    "relation": "适用数据结构",
    "tail": "数组",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "fill",
    "relation": "适用数据结构",
    "tail": "int数组",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "fill",
    "relation": "适用数据结构",
    "tail": "vector",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "fill",
    "relation": "适用数据结构",
    "tail": "char数组",
    "source_topic": "c++函数库<algorithm>中一些实用的函数"
  },
  {
    "head": "线程",
    "relation": "属于",
    "tail": "轻量级进程",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "组成",
    "tail": "线程ID",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "组成",
    "tail": "程序计数器",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "组成",
    "tail": "寄存器集合",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "组成",
    "tail": "堆栈",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "共享",
    "tail": "代码段",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "共享",
    "tail": "数据段",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "共享",
    "tail": "操作系统资源",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "新生状态",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "可运行状态",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "被阻塞状态",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "死亡状态",
    "source_topic": "线程的基本概念、线程的基本状态及状态之间的关系？"
  },
  {
    "head": "线程",
    "relation": "属于",
    "tail": "进程的一部分",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "线程",
    "relation": "被称为",
    "tail": "轻权进程",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "线程",
    "relation": "被称为",
    "tail": "轻量级进程",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程",
    "relation": "可以被看作",
    "tail": "单线程",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程",
    "relation": "包含",
    "tail": "多个线程",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程",
    "relation": "执行过程",
    "tail": "多条线（线程）共同完成",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程",
    "relation": "分配",
    "tail": "不同的内存区域",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "线程",
    "relation": "共享",
    "tail": "所属进程的资源",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "线程",
    "relation": "使用资源",
    "tail": "进程的资源",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "线程",
    "relation": "有",
    "tail": "线程控制表（TCB）",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程控制表（PCB）",
    "relation": "相似",
    "tail": "线程控制表（TCB）",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "线程控制表（TCB）",
    "relation": "保存状态",
    "tail": "比进程控制表（PCB）少",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程",
    "relation": "是",
    "tail": "系统资源分配的基本单位",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程",
    "relation": "拥有",
    "tail": "完整的虚拟空间地址",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "进程",
    "relation": "独立存在",
    "tail": "不依赖线程",
    "source_topic": "线程与进程的区别？"
  },
  {
    "head": "std::thread",
    "relation": "定义于",
    "tail": "thread头文件",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "构造时传入",
    "tail": "可调用对象",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "支持",
    "tail": "移动操作",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "不支持",
    "tail": "复制操作",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "必须调用",
    "tail": "join()或detach()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "定义于",
    "tail": "mutex头文件",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "用于",
    "tail": "保护共享数据",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "支持",
    "tail": "lock()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "支持",
    "tail": "try_lock()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "支持",
    "tail": "unlock()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "不支持",
    "tail": "复制操作",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "不支持",
    "tail": "移动操作",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::lock_guard",
    "relation": "用于",
    "tail": "管理mutex",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::lock_guard",
    "relation": "实现",
    "tail": "RAII式加锁解锁",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "不关联",
    "tail": "默认构造的thread对象",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "不关联",
    "tail": "被移动后的thread对象",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "核心特性",
    "tail": "防止多线程同时访问共享数据",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "核心特性",
    "tail": "创建后立即执行可调用对象",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "接口",
    "tail": "joinable()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "接口",
    "tail": "join()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "接口",
    "tail": "detach()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::lock_guard",
    "relation": "接口",
    "tail": "自动加锁和解锁",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "接口",
    "tail": "lock()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "接口",
    "tail": "try_lock()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "接口",
    "tail": "unlock()",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::mutex",
    "relation": "导致",
    "tail": "死锁",
    "source_topic": "include <mutex>"
  },
  {
    "head": "std::thread",
    "relation": "解决",
    "tail": "忘记unlock导致的死锁",
    "source_topic": "include <mutex>"
  },
  {
    "head": "C语言",
    "relation": "属于",
    "tail": "结构化语言",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C++语言",
    "relation": "属于",
    "tail": "面向对象语言",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C语言",
    "relation": "设计首要考虑",
    "tail": "过程处理输入输出",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C++语言",
    "relation": "设计首要考虑",
    "tail": "构造对象模型",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "C++语言",
    "relation": "基于",
    "tail": "C语言",
    "source_topic": "C和C++的区别"
  },
  {
    "head": "封装",
    "relation": "核心特性",
    "tail": "隐藏实现细节",
    "source_topic": "封装、继承、多态"
  },
  {
    "head": "封装",
    "relation": "核心特性",
    "tail": "代码模块化",
    "source_topic": "封装、继承、多态"
  },
  {
    "head": "虚函数",
    "relation": "实现",
    "tail": "多态机制",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "虚函数",
    "relation": "定义方式",
    "tail": "virtual关键字",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "虚函数",
    "relation": "动态绑定",
    "tail": "运行期确认",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "虚函数",
    "relation": "动态绑定",
    "tail": "根据对象类型调用合适的函数版本",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "虚函数",
    "relation": "调用方式",
    "tail": "基类指针或引用",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Draw函数",
    "relation": "属于",
    "tail": "Shape类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Draw函数",
    "relation": "被重写",
    "tail": "Circle类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Draw函数",
    "relation": "被重写",
    "tail": "Triangle类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Draw函数",
    "relation": "被重写",
    "tail": "Rectangle类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Draw函数",
    "relation": "被重写",
    "tail": "Square类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Shape类",
    "relation": "派生出",
    "tail": "Circle类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Shape类",
    "relation": "派生出",
    "tail": "Triangle类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Shape类",
    "relation": "派生出",
    "tail": "Rectangle类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "Shape类",
    "relation": "派生出",
    "tail": "Square类",
    "source_topic": "虚函数的作用及其实现原理"
  },
  {
    "head": "深拷贝",
    "relation": "核心特性",
    "tail": "对象资源重新分配",
    "source_topic": "深拷贝和浅拷贝（值拷贝和位拷贝）"
  },
  {
    "head": "深拷贝",
    "relation": "核心特性",
    "tail": "两个对象的资源内存不同",
    "source_topic": "深拷贝和浅拷贝（值拷贝和位拷贝）"
  },
  {
    "head": "浅拷贝",
    "relation": "核心特性",
    "tail": "两个对象均指向同一内存空间",
    "source_topic": "深拷贝和浅拷贝（值拷贝和位拷贝）"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "野指针",
    "source_topic": "深拷贝和浅拷贝（值拷贝和位拷贝）"
  },
  {
    "head": "虚函数",
    "relation": "声明方式",
    "tail": "virtual关键字",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "虚函数",
    "relation": "归属",
    "tail": "类的成员函数",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "存在虚函数的类",
    "relation": "包含",
    "tail": "虚函数表",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "虚函数表",
    "relation": "名称",
    "tail": "虚表",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "类的对象",
    "relation": "包含",
    "tail": "虚指针",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "虚指针",
    "relation": "指向",
    "tail": "虚表开始",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "多态性",
    "relation": "分类",
    "tail": "类的多态性",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "多态性",
    "relation": "分类",
    "tail": "函数的多态性",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "多态性",
    "relation": "实现方式",
    "tail": "虚函数",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "多态性",
    "relation": "结合",
    "tail": "动态绑定",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "纯虚函数",
    "relation": "定义方式",
    "tail": "虚函数加上=0",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "抽象类",
    "relation": "定义",
    "tail": "至少一个纯虚函数",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "抽象基类",
    "relation": "限制",
    "tail": "不能定义对象",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "纯虚函数",
    "relation": "实现要求",
    "tail": "必须在子类实现",
    "source_topic": "虚函数、纯虚函数怎么实现"
  },
  {
    "head": "纯虚函数",
    "relation": "解决",
    "tail": "基类生成对象不合情理",
    "source_topic": "为什么要有纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "解决",
    "tail": "无法实现多态性",
    "source_topic": "为什么要有纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "定义特征",
    "tail": "包含纯虚函数",
    "source_topic": "为什么要有纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "限制",
    "tail": "不能生成对象",
    "source_topic": "为什么要有纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "要求",
    "tail": "派生类必须重写",
    "source_topic": "为什么要有纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "实现",
    "tail": "多态性",
    "source_topic": "为什么要有纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "核心特性",
    "tail": "没有函数体",
    "source_topic": "纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "核心特性",
    "tail": "声明语句最后有分号",
    "source_topic": "纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "核心特性",
    "tail": "使用'=0'表示虚函数",
    "source_topic": "纯虚函数"
  },
  {
    "head": "虚析构函数",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "非虚析构函数",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "基类指针",
    "relation": "指向",
    "tail": "派生类对象",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "动态绑定",
    "relation": "未触发动态绑定",
    "tail": "非虚析构函数",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "析构函数",
    "relation": "调用",
    "tail": "基类析构函数",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "析构函数",
    "relation": "调用",
    "tail": "派生类析构函数",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "派生类对象",
    "relation": "申请",
    "tail": "内存空间",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "派生类析构函数",
    "relation": "释放",
    "tail": "内存空间",
    "source_topic": "为什么要有虚析构函数"
  },
  {
    "head": "构造函数",
    "relation": "不能是",
    "tail": "虚函数",
    "source_topic": "构造函数能不能是虚函数"
  },
  {
    "head": "构造函数",
    "relation": "初始化",
    "tail": "虚函数表",
    "source_topic": "构造函数能不能是虚函数"
  },
  {
    "head": "虚函数表指针",
    "relation": "初始化",
    "tail": "构造函数",
    "source_topic": "构造函数能不能是虚函数"
  },
  {
    "head": "构造函数",
    "relation": "确定",
    "tail": "对象实际类型",
    "source_topic": "构造函数能不能是虚函数"
  },
  {
    "head": "虚函数",
    "relation": "依赖",
    "tail": "虚函数表",
    "source_topic": "构造函数能不能是虚函数"
  },
  {
    "head": "虚函数表",
    "relation": "初始化",
    "tail": "构造函数",
    "source_topic": "构造函数能不能是虚函数"
  },
  {
    "head": "C++构造函数",
    "relation": "没有返回值",
    "tail": "类初始化行为",
    "source_topic": "C++里面构造函数能有返回值吗？"
  },
  {
    "head": "new操作符",
    "relation": "返回",
    "tail": "类实例的指针",
    "source_topic": "C++里面构造函数能有返回值吗？"
  },
  {
    "head": "构造函数",
    "relation": "不能被继承",
    "tail": "析构函数",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "构造函数",
    "relation": "属于",
    "tail": "类的特殊函数",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "析构函数",
    "relation": "属于",
    "tail": "类的特殊函数",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "构造函数",
    "relation": "处理",
    "tail": "对象的创建",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "析构函数",
    "relation": "处理",
    "tail": "对象的析构",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "子类的构造函数",
    "relation": "调用",
    "tail": "父类的构造函数",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "子类的构造函数",
    "relation": "隐式调用",
    "tail": "父类的默认构造函数",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "析构函数",
    "relation": "必须被调用",
    "tail": "整个层次中的所有析构函数",
    "source_topic": "构造函数和析构函数能被继承吗？"
  },
  {
    "head": "Overload",
    "relation": "属于",
    "tail": "函数重载",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "函数重载",
    "relation": "特征",
    "tail": "相同的范围",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "函数重载",
    "relation": "特征",
    "tail": "函数名字相同",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "函数重载",
    "relation": "特征",
    "tail": "参数不同",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "函数重载",
    "relation": "特征",
    "tail": "virtual关键字可有可无",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "Override",
    "relation": "属于",
    "tail": "函数覆盖",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "函数覆盖",
    "relation": "特征",
    "tail": "不同的范围",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "函数覆盖",
    "relation": "特征",
    "tail": "函数名字相同",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "函数覆盖",
    "relation": "特征",
    "tail": "参数相同",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "Overwrite",
    "relation": "属于",
    "tail": "函数隐藏",
    "source_topic": "C++中Overload、Overwrite及Override的区别"
  },
  {
    "head": "空的class类",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "一个空的class类里有什么"
  },
  {
    "head": "空的class类",
    "relation": "包含",
    "tail": "拷贝构造函数",
    "source_topic": "一个空的class类里有什么"
  },
  {
    "head": "空的class类",
    "relation": "包含",
    "tail": "析构函数",
    "source_topic": "一个空的class类里有什么"
  },
  {
    "head": "空的class类",
    "relation": "包含",
    "tail": "赋值运算符重载",
    "source_topic": "一个空的class类里有什么"
  },
  {
    "head": "空的class类",
    "relation": "包含",
    "tail": "取地址操作符重载",
    "source_topic": "一个空的class类里有什么"
  },
  {
    "head": "取地址操作符重载",
    "relation": "被修饰",
    "tail": "const",
    "source_topic": "一个空的class类里有什么"
  },
  {
    "head": "C++空类",
    "relation": "导致",
    "tail": "实例化后内存地址唯一",
    "source_topic": "C++中一个空类的大小为什么是1？"
  },
  {
    "head": "C++空类",
    "relation": "隐含添加",
    "tail": "1个字节",
    "source_topic": "C++中一个空类的大小为什么是1？"
  },
  {
    "head": "编译器",
    "relation": "解决",
    "tail": "空类实例内存地址唯一性问题",
    "source_topic": "C++中一个空类的大小为什么是1？"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "int",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "char",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "static int",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "int",
    "relation": "占用内存",
    "tail": "4字节",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "char",
    "relation": "内存对齐",
    "tail": "4字节",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "static int",
    "relation": "不计算",
    "tail": "结构体大小",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "结构体",
    "relation": "内存对齐",
    "tail": "8字节",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "C结构体",
    "relation": "不允许定义",
    "tail": "static变量",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "C++结构体",
    "relation": "允许定义",
    "tail": "static变量",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "C++结构体",
    "relation": "不计算",
    "tail": "static变量大小",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "内存对齐机制",
    "relation": "影响",
    "tail": "结构体内存占用",
    "source_topic": "一个结构体中有一个int，一个char，一个static int，问这个结构体占多少内存？（涉及到内存对齐机制）"
  },
  {
    "head": "结构体",
    "relation": "内存分配方式",
    "tail": "各成员各自拥有自己的内存",
    "source_topic": "结构体与联合体的区别"
  },
  {
    "head": "结构体",
    "relation": "内存对齐原则",
    "tail": "遵循",
    "source_topic": "结构体与联合体的区别"
  },
  {
    "head": "结构体",
    "relation": "总长度计算方式",
    "tail": "等于所有成员的长度之和",
    "source_topic": "结构体与联合体的区别"
  },
  {
    "head": "联合体",
    "relation": "内存分配方式",
    "tail": "各成员共用一块内存空间",
    "source_topic": "结构体与联合体的区别"
  },
  {
    "head": "联合体",
    "relation": "内存使用权",
    "tail": "同时只有一个成员可以得到",
    "source_topic": "结构体与联合体的区别"
  },
  {
    "head": "联合体",
    "relation": "内存首地址",
    "tail": "各变量共用一个",
    "source_topic": "结构体与联合体的区别"
  },
  {
    "head": "联合体",
    "relation": "内存节约性",
    "tail": "比结构体更节约内存",
    "source_topic": "结构体与联合体的区别"
  },
  {
    "head": "函数调用",
    "relation": "导致",
    "tail": "系统保留现场",
    "source_topic": "函数与宏的差别"
  },
  {
    "head": "函数调用",
    "relation": "导致",
    "tail": "系统恢复现场",
    "source_topic": "函数与宏的差别"
  },
  {
    "head": "内联函数",
    "relation": "展开时机",
    "tail": "编译时",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "展开时机",
    "tail": "预编译时",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "内联函数",
    "relation": "展开方式",
    "tail": "被嵌入到目标代码中",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "展开方式",
    "tail": "预处理器符号表中的简单替换",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "内联函数",
    "relation": "具备功能",
    "tail": "类型安全检查",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "内联函数",
    "relation": "具备功能",
    "tail": "语句是否正确检查",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "不具备功能",
    "tail": "类型安全检查",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "不具备功能",
    "tail": "语句是否正确检查",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "分类",
    "tail": "预处理器指令",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "使用注意事项",
    "tail": "参数需要用括号括起",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "内联函数",
    "relation": "使用注意事项",
    "tail": "不会出现二义性",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "内联函数",
    "relation": "展开建议",
    "tail": "编译器可以选择忽略",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "展开建议",
    "tail": "必须展开",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "宏函数",
    "relation": "限制",
    "tail": "无法进行参数有效性检测",
    "source_topic": "宏函数和inline函数的异同点"
  },
  {
    "head": "define",
    "relation": "原理不同",
    "tail": "typedef",
    "source_topic": "define 和 typedef 区别"
  },
  {
    "head": "define",
    "relation": "属于",
    "tail": "预处理指令",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "define",
    "relation": "功能",
    "tail": "字符串替换",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "define",
    "relation": "不进行",
    "tail": "正确性检查",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "define",
    "relation": "错误发现阶段",
    "tail": "编译阶段",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "typedef",
    "relation": "属于",
    "tail": "关键字",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "typedef",
    "relation": "处理阶段",
    "tail": "编译时",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "typedef",
    "relation": "功能",
    "tail": "定义类型别名",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "typedef",
    "relation": "功能",
    "tail": "定义机器无关的类型",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "typedef",
    "relation": "限制",
    "tail": "不能在函数定义内部使用",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "typedef",
    "relation": "优势",
    "tail": "增强程序可读性",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "typedef",
    "relation": "优势",
    "tail": "使程序书写更简单",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "REAL",
    "relation": "定义为",
    "tail": "long double",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "REAL",
    "relation": "定义为",
    "tail": "double",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "REAL",
    "relation": "定义为",
    "tail": "float",
    "source_topic": "define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"
  },
  {
    "head": "define",
    "relation": "作用域不同",
    "tail": "类型别名",
    "source_topic": "define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。"
  },
  {
    "head": "define",
    "relation": "作用域限制",
    "tail": "无作用域限制",
    "source_topic": "define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。"
  },
  {
    "head": "typedef",
    "relation": "作用域限制",
    "tail": "有作用域",
    "source_topic": "define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。"
  },
  {
    "head": "typedef",
    "relation": "使用范围",
    "tail": "作用域限制",
    "source_topic": "define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。"
  },
  {
    "head": "define",
    "relation": "对比",
    "tail": "typedef",
    "source_topic": "define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。"
  },
  {
    "head": "INTPTR1",
    "relation": "定义为",
    "tail": "int*",
    "source_topic": "define INTPTR1 int*"
  },
  {
    "head": "C++内存管理机制",
    "relation": "包含",
    "tail": "自由存储区",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "C++内存管理机制",
    "relation": "包含",
    "tail": "全局/静态存储区",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "C++内存管理机制",
    "relation": "包含",
    "tail": "常量存储区",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "自由存储区",
    "relation": "分配方式",
    "tail": "由malloc分配",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "自由存储区",
    "relation": "释放方式",
    "tail": "由free释放",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存储内容",
    "tail": "全局变量",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存储内容",
    "tail": "静态变量",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "全局/静态存储区",
    "relation": "与C语言区别",
    "tail": "C++中无初始化和未初始化区分",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "常量存储区",
    "relation": "存储内容",
    "tail": "常量",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "常量存储区",
    "relation": "特点",
    "tail": "不允许修改",
    "source_topic": "C++的内存管理机制"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C语言",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C语言",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "malloc",
    "relation": "分类",
    "tail": "内存管理函数",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "free",
    "relation": "分类",
    "tail": "内存管理函数",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "new",
    "relation": "分类",
    "tail": "内存管理操作符",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "delete",
    "relation": "分类",
    "tail": "内存管理操作符",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "malloc",
    "relation": "作用",
    "tail": "申请和释放内存",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "free",
    "relation": "作用",
    "tail": "申请和释放内存",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "new",
    "relation": "作用",
    "tail": "申请和释放内存",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "delete",
    "relation": "作用",
    "tail": "申请和释放内存",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "malloc",
    "relation": "参数",
    "tail": "手动计算内存大小",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "free",
    "relation": "参数",
    "tail": "手动计算内存大小",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "new",
    "relation": "参数",
    "tail": "自动计算类型大小",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "delete",
    "relation": "参数",
    "tail": "自动计算类型大小",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "malloc",
    "relation": "返回值",
    "tail": "void指针",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "free",
    "relation": "返回值",
    "tail": "void指针",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "new",
    "relation": "返回值",
    "tail": "类型指针",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "delete",
    "relation": "返回值",
    "tail": "类型指针",
    "source_topic": "C语言中的malloc/free和C++中的new/delete的区别和联系"
  },
  {
    "head": "递归",
    "relation": "基于",
    "tail": "选择结构",
    "source_topic": "迭代和递归区别"
  },
  {
    "head": "迭代",
    "relation": "基于",
    "tail": "重复结构",
    "source_topic": "迭代和递归区别"
  },
  {
    "head": "递归",
    "relation": "实现重复方式",
    "tail": "函数调用",
    "source_topic": "迭代和递归区别"
  },
  {
    "head": "迭代",
    "relation": "实现重复方式",
    "tail": "循环结构",
    "source_topic": "迭代和递归区别"
  },
  {
    "head": "递归",
    "relation": "终止条件",
    "tail": "基本情况",
    "source_topic": "迭代和递归区别"
  },
  {
    "head": "迭代",
    "relation": "终止条件",
    "tail": "循环条件失败",
    "source_topic": "迭代和递归区别"
  },
  {
    "head": "作用域操作符",
    "relation": "属于",
    "tail": "::",
    "source_topic": "不可操作的操作符"
  },
  {
    "head": "条件操作符",
    "relation": "属于",
    "tail": "?:",
    "source_topic": "不可操作的操作符"
  },
  {
    "head": "指向成员操作的指针操作符",
    "relation": "属于",
    "tail": "->",
    "source_topic": "不可操作的操作符"
  },
  {
    "head": "mutable",
    "relation": "突破",
    "tail": "const限制",
    "source_topic": "C++关键字mutable作用"
  },
  {
    "head": "mutable",
    "relation": "修饰",
    "tail": "非静态数据成员",
    "source_topic": "C++关键字mutable作用"
  },
  {
    "head": "const函数",
    "relation": "允许修改",
    "tail": "mutable成员",
    "source_topic": "C++关键字mutable作用"
  },
  {
    "head": "mutable成员",
    "relation": "与类状态无关",
    "tail": "数据成员",
    "source_topic": "C++关键字mutable作用"
  },
  {
    "head": "mutable",
    "relation": "用于",
    "tail": "隐藏实现细节",
    "source_topic": "C++关键字mutable作用"
  },
  {
    "head": "引用",
    "relation": "必须初始化",
    "tail": "指针",
    "source_topic": "引用与指针有什么区别？"
  },
  {
    "head": "引用",
    "relation": "不可更改指向",
    "tail": "指针",
    "source_topic": "引用与指针有什么区别？"
  },
  {
    "head": "引用",
    "relation": "不能指向空值",
    "tail": "指针",
    "source_topic": "引用与指针有什么区别？"
  },
  {
    "head": "引用",
    "relation": "底层实现",
    "tail": "只读指针",
    "source_topic": "引用与指针有什么区别？"
  },
  {
    "head": "白盒测试",
    "relation": "测试方式",
    "tail": "程序源代码",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "白盒测试",
    "relation": "测试目标",
    "tail": "内部代码缺点或错误",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "白盒测试",
    "relation": "测试内容",
    "tail": "算法",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "白盒测试",
    "relation": "测试内容",
    "tail": "溢出",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "白盒测试",
    "relation": "测试内容",
    "tail": "路径",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "白盒测试",
    "relation": "测试内容",
    "tail": "条件",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "黑盒测试",
    "relation": "测试方式",
    "tail": "软件功能",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "黑盒测试",
    "relation": "测试方法",
    "tail": "输入数据并观察输出结果",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "黑盒测试",
    "relation": "测试视角",
    "tail": "程序接口",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "黑盒测试",
    "relation": "测试假设",
    "tail": "不考虑程序内部结构",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "黑盒测试",
    "relation": "测试假设",
    "tail": "不考虑程序内部特性",
    "source_topic": "什么是黑盒测试和白盒测试？"
  },
  {
    "head": "vector",
    "relation": "属于",
    "tail": "容器类模板",
    "source_topic": "你知道的类模版有哪些"
  },
  {
    "head": "string",
    "relation": "属于",
    "tail": "容器类模板",
    "source_topic": "你知道的类模版有哪些"
  },
  {
    "head": "list",
    "relation": "属于",
    "tail": "容器类模板",
    "source_topic": "你知道的类模版有哪些"
  },
  {
    "head": "queue",
    "relation": "属于",
    "tail": "容器类模板",
    "source_topic": "你知道的类模版有哪些"
  },
  {
    "head": "map",
    "relation": "属于",
    "tail": "容器类模板",
    "source_topic": "你知道的类模版有哪些"
  },
  {
    "head": "set",
    "relation": "属于",
    "tail": "容器类模板",
    "source_topic": "你知道的类模版有哪些"
  },
  {
    "head": "stack",
    "relation": "属于",
    "tail": "容器类模板",
    "source_topic": "你知道的类模版有哪些"
  },
  {
    "head": "new",
    "relation": "搭配",
    "tail": "delete",
    "source_topic": "new可以搭配free吗，为什么？"
  },
  {
    "head": "free",
    "relation": "不调用",
    "tail": "析构函数",
    "source_topic": "new可以搭配free吗，为什么？"
  },
  {
    "head": "析构函数",
    "relation": "负责释放",
    "tail": "动态内存",
    "source_topic": "new可以搭配free吗，为什么？"
  },
  {
    "head": "new",
    "relation": "申请内存",
    "tail": "free",
    "source_topic": "new可以搭配free吗，为什么？"
  },
  {
    "head": "内存泄漏",
    "relation": "导致",
    "tail": "未释放动态内存",
    "source_topic": "new可以搭配free吗，为什么？"
  },
  {
    "head": "new",
    "relation": "可能导致",
    "tail": "内存泄漏",
    "source_topic": "new可以搭配free吗，为什么？"
  },
  {
    "head": "内存泄漏",
    "relation": "解决",
    "tail": "良好的编码习惯",
    "source_topic": "怎么查看内存泄漏"
  },
  {
    "head": "内存泄漏",
    "relation": "解决",
    "tail": "链表管理内存指针",
    "source_topic": "怎么查看内存泄漏"
  },
  {
    "head": "内存泄漏",
    "relation": "解决",
    "tail": "Boost智能指针",
    "source_topic": "怎么查看内存泄漏"
  },
  {
    "head": "内存溢出",
    "relation": "原因",
    "tail": "内存中加载的数据量过于庞大",
    "source_topic": "什么是内存溢出"
  },
  {
    "head": "内存溢出",
    "relation": "原因",
    "tail": "使用的第三方软件中的BUG",
    "source_topic": "什么是内存溢出"
  },
  {
    "head": "内存溢出",
    "relation": "原因",
    "tail": "启动参数内存值设定的过小",
    "source_topic": "什么是内存溢出"
  },
  {
    "head": "内存溢出",
    "relation": "解决",
    "tail": "JVM启动参数修改",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "JVM启动参数修改",
    "relation": "包含",
    "tail": "-Xms",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "JVM启动参数修改",
    "relation": "包含",
    "tail": "-Xmx",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存溢出",
    "relation": "检查",
    "tail": "错误日志",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "错误日志",
    "relation": "包含",
    "tail": "OutOfMemory",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存溢出",
    "relation": "排查",
    "tail": "数据库查询",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "数据库查询",
    "relation": "导致",
    "tail": "内存溢出",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "数据库查询",
    "relation": "建议",
    "tail": "分页方式",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存溢出",
    "relation": "排查",
    "tail": "死循环",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存溢出",
    "relation": "排查",
    "tail": "递归调用",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存溢出",
    "relation": "排查",
    "tail": "大循环",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "大循环",
    "relation": "导致",
    "tail": "重复产生新对象实体",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存溢出",
    "relation": "排查",
    "tail": "集合对象",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "集合对象",
    "relation": "包含",
    "tail": "List",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "集合对象",
    "relation": "包含",
    "tail": "MAP",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "集合对象",
    "relation": "导致",
    "tail": "对象不能被GC回收",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存溢出",
    "relation": "解决",
    "tail": "内存查看工具",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "内存查看工具",
    "relation": "用于",
    "tail": "动态查看内存使用情况",
    "source_topic": "内存溢出的解决方案"
  },
  {
    "head": "指针函数",
    "relation": "返回值类型",
    "tail": "指针",
    "source_topic": "函数指针与指针函数分别是什么"
  },
  {
    "head": "函数指针",
    "relation": "属于",
    "tail": "指针",
    "source_topic": "函数指针与指针函数分别是什么"
  },
  {
    "head": "std::array",
    "relation": "保存在",
    "tail": "栈内存",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "std::array",
    "relation": "相比",
    "tail": "std::vector",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "std::array",
    "relation": "提供",
    "tail": "灵活访问元素",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "std::array",
    "relation": "获得",
    "tail": "更高性能",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "auto",
    "relation": "实现",
    "tail": "类型推导",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "decltype",
    "relation": "实现",
    "tail": "类型推导",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "nullptr",
    "relation": "替代",
    "tail": "NULL",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "unique_ptr",
    "relation": "属于",
    "tail": "智能指针",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "shared_ptr",
    "relation": "属于",
    "tail": "智能指针",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "weak_ptr",
    "relation": "属于",
    "tail": "智能指针",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "基于范围的for循环",
    "relation": "属于",
    "tail": "C++11新特性",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "基于范围的for循环",
    "relation": "实现",
    "tail": "简洁遍历写法",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "基于范围的for循环",
    "relation": "类似",
    "tail": "Python循环语句",
    "source_topic": "C++11新特性了解吗"
  },
  {
    "head": "抽象类",
    "relation": "可以包含",
    "tail": "抽象方法",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "抽象类",
    "relation": "可以包含",
    "tail": "非抽象方法",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "抽象类",
    "relation": "可以在不提供接口方法实现的情况下",
    "tail": "实现接口",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "Java接口中的成员函数",
    "relation": "默认是",
    "tail": "public",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "抽象类的成员函数",
    "relation": "可以是",
    "tail": "private",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "抽象类的成员函数",
    "relation": "可以是",
    "tail": "protected",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "抽象类的成员函数",
    "relation": "可以是",
    "tail": "public",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "struct",
    "relation": "默认数据访问控制是",
    "tail": "public",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "class",
    "relation": "默认成员变量访问控制是",
    "tail": "private",
    "source_topic": "接口和抽象类的区别"
  },
  {
    "head": "预编译",
    "relation": "处理",
    "tail": "代码文本替换",
    "source_topic": "预编译在做些什么事情？"
  },
  {
    "head": "预编译",
    "relation": "处理",
    "tail": "以#开头的指令",
    "source_topic": "预编译在做些什么事情？"
  },
  {
    "head": "预编译",
    "relation": "包含",
    "tail": "define宏定义的替换",
    "source_topic": "预编译在做些什么事情？"
  },
  {
    "head": "预编译",
    "relation": "包含",
    "tail": "条件编译",
    "source_topic": "预编译在做些什么事情？"
  },
  {
    "head": "预编译",
    "relation": "属于",
    "tail": "编译预备阶段",
    "source_topic": "预编译在做些什么事情？"
  },
  {
    "head": "静态库",
    "relation": "链接时期",
    "tail": "编译时期",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "静态库",
    "relation": "运行时特性",
    "tail": "与函数库无关联",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "静态库",
    "relation": "移植特性",
    "tail": "方便",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "静态库",
    "relation": "文件后缀",
    "tail": ".a",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "静态库",
    "relation": "文件后缀",
    "tail": ".lib",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "动态库",
    "relation": "链接时期",
    "tail": "程序运行时期",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "动态库",
    "relation": "资源共享",
    "tail": "进程之间共享",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "动态库",
    "relation": "升级特性",
    "tail": "直接修改动态库即可升级",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "动态库",
    "relation": "文件后缀",
    "tail": ".so",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "动态库",
    "relation": "文件后缀",
    "tail": ".dll",
    "source_topic": "动态库和静态库？"
  },
  {
    "head": "C语言函数参数入栈顺序",
    "relation": "导致",
    "tail": "从右至左",
    "source_topic": "函数参数压栈方式为什么是从右到左的？"
  },
  {
    "head": "C语言函数参数入栈顺序",
    "relation": "解决",
    "tail": "动态变化参数个数",
    "source_topic": "函数参数压栈方式为什么是从右到左的？"
  },
  {
    "head": "确定的参数",
    "relation": "必须保证",
    "tail": "在栈中的位置确定",
    "source_topic": "函数参数压栈方式为什么是从右到左的？"
  },
  {
    "head": "确定的参数",
    "relation": "入栈顺序",
    "tail": "最后入栈",
    "source_topic": "函数参数压栈方式为什么是从右到左的？"
  },
  {
    "head": "C语言函数参数入栈顺序",
    "relation": "支持",
    "tail": "可变长函数参数",
    "source_topic": "函数参数压栈方式为什么是从右到左的？"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "智能指针",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "智能指针",
    "relation": "分类",
    "tail": "auto_ptr",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "智能指针",
    "relation": "分类",
    "tail": "shared_ptr",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "智能指针",
    "relation": "分类",
    "tail": "weak_ptr",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "智能指针",
    "relation": "分类",
    "tail": "unique_ptr",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "auto_ptr",
    "relation": "属于",
    "tail": "C++98",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "auto_ptr",
    "relation": "被弃用",
    "tail": "C++11",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "shared_ptr",
    "relation": "属于",
    "tail": "C++11",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "unique_ptr",
    "relation": "属于",
    "tail": "C++11",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "weak_ptr",
    "relation": "属于",
    "tail": "C++11",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "智能指针",
    "relation": "作用",
    "tail": "避免内存泄漏",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "智能指针",
    "relation": "实现原理",
    "tail": "自动调用析构函数",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "auto_ptr",
    "relation": "缺点",
    "tail": "潜在的内存崩溃问题",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "unique_ptr",
    "relation": "替换",
    "tail": "auto_ptr",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "unique_ptr",
    "relation": "核心特性",
    "tail": "独占式拥有",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "shared_ptr",
    "relation": "核心特性",
    "tail": "共享式拥有",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "shared_ptr",
    "relation": "使用机制",
    "tail": "引用计数",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "weak_ptr",
    "relation": "不控制",
    "tail": "对象生命周期",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "weak_ptr",
    "relation": "指向",
    "tail": "shared_ptr管理的对象",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "shared_ptr",
    "relation": "导致",
    "tail": "引用计数无法下降为0",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "weak_ptr",
    "relation": "可以转换为",
    "tail": "shared_ptr",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "shared_ptr",
    "relation": "可以转换为",
    "tail": "weak_ptr",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "shared_ptr",
    "relation": "包含",
    "tail": "use_count()函数",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "shared_ptr",
    "relation": "包含",
    "tail": "release()函数",
    "source_topic": "C++中的智能指针"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "虚函数",
    "source_topic": "基类里private成员函数可以声明为虚函数吗？"
  },
  {
    "head": "虚函数",
    "relation": "访问权限",
    "tail": "private",
    "source_topic": "基类里private成员函数可以声明为虚函数吗？"
  },
  {
    "head": "private成员函数",
    "relation": "可以声明为",
    "tail": "虚函数",
    "source_topic": "基类里private成员函数可以声明为虚函数吗？"
  },
  {
    "head": "private成员函数",
    "relation": "不建议实现",
    "tail": "原因：与私有成员创建的本意相反",
    "source_topic": "基类里private成员函数可以声明为虚函数吗？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "函数参数",
    "source_topic": "函数A调用函数B的时候，有什么需要压栈？"
  },
  {
    "head": "函数参数",
    "relation": "压栈顺序",
    "tail": "从右往左",
    "source_topic": "函数A调用函数B的时候，有什么需要压栈？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "函数内部定义的变量",
    "source_topic": "函数A调用函数B的时候，有什么需要压栈？"
  },
  {
    "head": "数组",
    "relation": "传递时退化为",
    "tail": "指针",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组名",
    "relation": "可作为",
    "tail": "指针常量",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "存储结构为",
    "tail": "顺序存储结构",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "内存分配为",
    "tail": "连续内存空间",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "标识符代表",
    "tail": "整个数组",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "可使用",
    "tail": "sizeof获取真实大小",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "指针",
    "relation": "内存分配为",
    "tail": "一个指针大小的内存",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "指针",
    "relation": "可指向",
    "tail": "有效内存空间",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "链表",
    "relation": "存储结构为",
    "tail": "链式存储结构",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "链表",
    "relation": "元素连接方式为",
    "tail": "通过指针",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "元素连接方式为",
    "tail": "按次序依次存储",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "链表",
    "relation": "插入删除元素",
    "tail": "相对简单",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "链表",
    "relation": "查找元素",
    "tail": "较为困难",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "查找元素",
    "tail": "较为简单",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "插入删除元素",
    "tail": "较为复杂",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "最大长度",
    "tail": "需在编程时指定",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "链表",
    "relation": "最大长度",
    "tail": "可动态扩充",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "数组",
    "relation": "结构模型",
    "tail": "线性结构",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "链表",
    "relation": "结构模型",
    "tail": "线性结构",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "单向链表",
    "relation": "节点包含",
    "tail": "信息域",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "单向链表",
    "relation": "节点包含",
    "tail": "指针域",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "单向链表",
    "relation": "指针域指向",
    "tail": "下一个节点的地址",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "单向链表",
    "relation": "最后一个节点指向",
    "tail": "空值或空列表",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "双向链表",
    "relation": "节点包含",
    "tail": "前一个节点的指针",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "双向链表",
    "relation": "节点包含",
    "tail": "后一个节点的指针",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "双向链表",
    "relation": "第一个节点的前指针指向",
    "tail": "空值或空列表",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "双向链表",
    "relation": "最后一个节点的后指针指向",
    "tail": "空值或空列表",
    "source_topic": "数组和指针区别？数组和链表呢？双向链表和单向链表？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "动态数组",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector",
    "relation": "扩容方式",
    "tail": "二倍扩容",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "GCC",
    "relation": "扩容方式",
    "tail": "二倍扩容",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "VS13",
    "relation": "扩容方式",
    "tail": "1.5倍扩容",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "二倍扩容",
    "relation": "原因",
    "tail": "内存碎片",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "二倍扩容",
    "relation": "原因",
    "tail": "伙伴系统",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "二倍扩容",
    "relation": "原因",
    "tail": "内存的浪费",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector扩容",
    "relation": "导致",
    "tail": "迭代器失效",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector初始扩容",
    "relation": "导致",
    "tail": "频繁内存申请",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector初始扩容",
    "relation": "导致",
    "tail": "内存碎片",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "resize()",
    "relation": "功能",
    "tail": "改变vector中元素的数量",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "resize()",
    "relation": "功能",
    "tail": "创建容器中的对象",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "resize()",
    "relation": "操作",
    "tail": "删除多余元素",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "resize()",
    "relation": "操作",
    "tail": "在尾部插入元素",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "resize()",
    "relation": "参数",
    "tail": "value_type val",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "resize()",
    "relation": "影响",
    "tail": "容器大小",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "resize()",
    "relation": "影响",
    "tail": "存储空间重新分配",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "reserve()",
    "relation": "功能",
    "tail": "更改vector的容量",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "reserve()",
    "relation": "操作",
    "tail": "扩容",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "reserve()",
    "relation": "影响",
    "tail": "避免频繁申请内存",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "reserve()",
    "relation": "影响",
    "tail": "减少内存碎片",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "随机存取效率高",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector",
    "relation": "时间复杂度",
    "tail": "O(1)",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "随机插入效率低",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector",
    "relation": "核心特性",
    "tail": "需要移动较多元素",
    "source_topic": "vector底层实现？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "连续内存空间",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "支持",
    "tail": "随机存取",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "不支持",
    "tail": "高效的插入和删除",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "实现方式",
    "tail": "数组",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "提供",
    "tail": "[]操作符",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "导致",
    "tail": "内存块拷贝",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "需要",
    "tail": "重新申请内存",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "双向链表",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "list",
    "relation": "不支持",
    "tail": "随机存取",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "list",
    "relation": "支持",
    "tail": "高效的插入和删除",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "list",
    "relation": "不提供",
    "tail": "[]操作符",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "list",
    "relation": "访问方式",
    "tail": "指针访问",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "list",
    "relation": "搜索复杂度",
    "tail": "O(n)",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "随机存取复杂度",
    "tail": "O(1)",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "vector",
    "relation": "插入删除复杂度",
    "tail": "O(n)",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "list",
    "relation": "插入删除复杂度",
    "tail": "O(1)",
    "source_topic": "vector与list的区别？"
  },
  {
    "head": "变量声明",
    "relation": "不分配",
    "tail": "内存空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量定义",
    "relation": "分配",
    "tail": "内存空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量声明",
    "relation": "允许",
    "tail": "多个地方",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量定义",
    "relation": "唯一",
    "tail": "一个地方",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "extern修饰符",
    "relation": "用于",
    "tail": "变量声明",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "外部变量",
    "relation": "可能",
    "tail": "仅声明不分配内存空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "外部变量",
    "relation": "初始化",
    "tail": "具体使用时分配内存空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "#ifdef",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "#else",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "#endif",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "#ifndef",
    "relation": "属于",
    "tail": "条件编译命令",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "条件编译命令",
    "relation": "解决",
    "tail": "目标程序长度过长",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "条件编译命令",
    "relation": "解决",
    "tail": "运行时间过长",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "条件编译",
    "relation": "减少",
    "tail": "被编译的语句",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "条件编译",
    "relation": "减少",
    "tail": "目标程序长度",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "条件编译",
    "relation": "减少",
    "tail": "运行时间",
    "source_topic": "简述#ifdef、#else、#endif和#ifndef的作用"
  },
  {
    "head": "int变量",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出int、bool、float、指针变量与“零值”比较的if语句"
  },
  {
    "head": "bool变量",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出int、bool、float、指针变量与“零值”比较的if语句"
  },
  {
    "head": "float变量",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出int、bool、float、指针变量与“零值”比较的if语句"
  },
  {
    "head": "指针变量",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "写出int、bool、float、指针变量与“零值”比较的if语句"
  },
  {
    "head": "float与零值比较",
    "relation": "使用",
    "tail": "误差范围",
    "source_topic": "写出int、bool、float、指针变量与“零值”比较的if语句"
  },
  {
    "head": "指针与零值比较",
    "relation": "使用",
    "tail": "NULL常量",
    "source_topic": "写出int、bool、float、指针变量与“零值”比较的if语句"
  },
  {
    "head": "结构体",
    "relation": "允许",
    "tail": "直接赋值",
    "source_topic": "结构体可以直接赋值吗？"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "指针成员",
    "source_topic": "结构体可以直接赋值吗？"
  },
  {
    "head": "指针成员",
    "relation": "导致",
    "tail": "内存释放冲突",
    "source_topic": "结构体可以直接赋值吗？"
  },
  {
    "head": "内存释放冲突",
    "relation": "解决",
    "tail": "确保其他指针不再使用内存空间",
    "source_topic": "结构体可以直接赋值吗？"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "操作符",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "strlen",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "sizeof",
    "relation": "计算",
    "tail": "数据类型占内存的大小",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "strlen",
    "relation": "计算",
    "tail": "字符串实际的长度",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "sizeof",
    "relation": "参数类型",
    "tail": "数据类型或变量",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "strlen",
    "relation": "参数类型",
    "tail": "以结尾为‘\\0’的字符串",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "sizeof",
    "relation": "计算时机",
    "tail": "编译时",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "strlen",
    "relation": "计算时机",
    "tail": "运行时",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "数组",
    "relation": "在sizeof中",
    "tail": "不退化",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "数组",
    "relation": "在strlen中",
    "tail": "退化为指针",
    "source_topic": "sizeof和strlen的区别"
  },
  {
    "head": "C语言",
    "relation": "支持",
    "tail": "静态局部变量",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C语言",
    "relation": "支持",
    "tail": "静态外部变量",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C语言",
    "relation": "支持",
    "tail": "静态函数",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "静态局部变量",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "静态外部变量",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "静态函数",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "静态成员变量",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "静态成员函数",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C语言 static",
    "relation": "具有",
    "tail": "记忆性",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C语言 static",
    "relation": "具有",
    "tail": "全局性",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++ static",
    "relation": "具有",
    "tail": "静态成员",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++ static",
    "relation": "具有",
    "tail": "多个对象实例间通信",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "C++ static",
    "relation": "具有",
    "tail": "传递消息",
    "source_topic": "c语言的关键字static和c++关键字static有什么区别？"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++操作符",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++操作符",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "可以重载",
    "tail": "C++操作符",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "delete",
    "relation": "可以重载",
    "tail": "C++操作符",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "可以覆盖",
    "tail": "C函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "free",
    "relation": "可以覆盖",
    "tail": "C函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "不执行",
    "tail": "构造函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "free",
    "relation": "不执行",
    "tail": "析构函数",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "返回",
    "tail": "某种数据类型指针",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "返回",
    "tail": "void指针",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "new",
    "relation": "必须使用",
    "tail": "delete释放内存",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "malloc",
    "relation": "必须使用",
    "tail": "free释放内存",
    "source_topic": "c语言的malloc和c++中的new有什么区别？"
  },
  {
    "head": "++i",
    "relation": "操作顺序",
    "tail": "先自增1，再返回",
    "source_topic": "++i和i++的区别"
  },
  {
    "head": "i++",
    "relation": "操作顺序",
    "tail": "先返回i，再自增1",
    "source_topic": "++i和i++的区别"
  },
  {
    "head": "volatile",
    "relation": "作用于",
    "tail": "状态寄存器",
    "source_topic": "volatile有什么作用"
  },
  {
    "head": "volatile",
    "relation": "作用于",
    "tail": "并行设备硬件寄存器",
    "source_topic": "volatile有什么作用"
  },
  {
    "head": "volatile",
    "relation": "修饰",
    "tail": "多线程被几个任务共享的变量",
    "source_topic": "volatile有什么作用"
  },
  {
    "head": "volatile",
    "relation": "应用领域",
    "tail": "嵌入式系统",
    "source_topic": "volatile有什么作用"
  },
  {
    "head": "volatile",
    "relation": "应用领域",
    "tail": "PC软件多线程",
    "source_topic": "volatile有什么作用"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "不允许程序中的代码改变某一变量",
    "source_topic": "一个参数可以既是const又是volatile吗"
  },
  {
    "head": "volatile",
    "relation": "核心特性",
    "tail": "编译器不会优化这个变量",
    "source_topic": "一个参数可以既是const又是volatile吗"
  },
  {
    "head": "const",
    "relation": "分类",
    "tail": "变量修饰符",
    "source_topic": "一个参数可以既是const又是volatile吗"
  },
  {
    "head": "volatile",
    "relation": "分类",
    "tail": "变量修饰符",
    "source_topic": "一个参数可以既是const又是volatile吗"
  },
  {
    "head": "volatile",
    "relation": "核心特性",
    "tail": "每次使用变量时都要从内存读取",
    "source_topic": "一个参数可以既是const又是volatile吗"
  },
  {
    "head": "&a",
    "relation": "代表",
    "tail": "变量a的地址",
    "source_topic": "a和&a有什么区别？"
  },
  {
    "head": "*a",
    "relation": "在声明语句中",
    "tail": "说明a是一个指针变量",
    "source_topic": "a和&a有什么区别？"
  },
  {
    "head": "int *a",
    "relation": "属于",
    "tail": "指针变量声明",
    "source_topic": "a和&a有什么区别？"
  },
  {
    "head": "b=*a",
    "relation": "表示",
    "tail": "将指针a指向的数据赋值给变量b",
    "source_topic": "a和&a有什么区别？"
  },
  {
    "head": "*a",
    "relation": "当a是普通变量时",
    "tail": "代表乘以a的操作",
    "source_topic": "a和&a有什么区别？"
  },
  {
    "head": "死循环程序",
    "relation": "实现方式",
    "tail": "while(1) {}",
    "source_topic": "用c编写一个死循环程序"
  },
  {
    "head": "结构体内存对齐",
    "relation": "遵循",
    "tail": "自然对齐条件",
    "source_topic": "结构体内存对齐的问题"
  },
  {
    "head": "结构体内存对齐",
    "relation": "目的",
    "tail": "提高运算速率",
    "source_topic": "结构体内存对齐的问题"
  },
  {
    "head": "结构体成员变量",
    "relation": "存储方式",
    "tail": "顺序存储",
    "source_topic": "结构体内存对齐的问题"
  },
  {
    "head": "结构体成员变量",
    "relation": "对齐模数",
    "tail": "4或8",
    "source_topic": "结构体内存对齐的问题"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "复合数据类型",
    "source_topic": "结构体内存对齐的问题"
  },
  {
    "head": "结构体",
    "relation": "包含",
    "tail": "基本数据类型",
    "source_topic": "结构体内存对齐的问题"
  },
  {
    "head": "结构体",
    "relation": "对齐方式",
    "tail": "按最大成员size对齐",
    "source_topic": "结构体内存对齐的问题"
  },
  {
    "head": "全局变量",
    "relation": "生存期",
    "tail": "整个程序从运行到结束",
    "source_topic": "全局变量和局部变量有什么区别？是怎么是实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "生存期",
    "tail": "模块结束（函数调用完毕）",
    "source_topic": "全局变量和局部变量有什么区别？是怎么是实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "内存分配位置",
    "tail": "全局数据段",
    "source_topic": "全局变量和局部变量有什么区别？是怎么是实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "内存分配位置",
    "tail": "堆栈",
    "source_topic": "全局变量和局部变量有什么区别？是怎么是实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "访问范围",
    "tail": "整个程序都可访问",
    "source_topic": "全局变量和局部变量有什么区别？是怎么是实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "访问范围",
    "tail": "所在模块可访问",
    "source_topic": "全局变量和局部变量有什么区别？是怎么是实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "操作系统和编译器",
    "relation": "识别方式",
    "tail": "内存分配的位置",
    "source_topic": "全局变量和局部变量有什么区别？是怎么是实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "静态存储区域分配",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "内存在程序编译时就已经分配好",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "内存在整个程序运行期间都存在",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "速度快",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "不容易出错",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "全局变量",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "static变量",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "常量字符串",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "栈上分配",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "效率很高",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "分配的内存容量有限",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "大小为2M",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "堆上分配",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "动态内存分配",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "动态内存的生存期由程序员决定",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "导致",
    "tail": "内存泄露",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "堆上分配",
    "relation": "导致",
    "tail": "堆内碎块",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "栈区",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "全局区",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "文字常量区",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "C/C++程序编译",
    "relation": "包含",
    "tail": "程序代码块区",
    "source_topic": "简述c、c++程序编译的内存分配情况"
  },
  {
    "head": "strcpy",
    "relation": "操作对象",
    "tail": "字符串",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "sprintf",
    "relation": "操作对象",
    "tail": "多种数据类型",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "操作对象",
    "tail": "任意内存地址",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "strcpy",
    "relation": "实现功能",
    "tail": "字符串变量间的拷贝",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "sprintf",
    "relation": "实现功能",
    "tail": "其他数据类型格式到字符串的转化",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "实现功能",
    "tail": "内存块间的拷贝",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "strcpy",
    "relation": "执行效率",
    "tail": "次之",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "sprintf",
    "relation": "执行效率",
    "tail": "最低",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "memcpy",
    "relation": "执行效率",
    "tail": "最高",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "((void(*)())0)",
    "relation": "类型",
    "tail": "函数指针",
    "source_topic": "简述strcpy、sprintf、memcpy的区别"
  },
  {
    "head": "C语言指针",
    "relation": "区别",
    "tail": "C++引用",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "存储空间",
    "tail": "独立空间",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "存储空间",
    "tail": "别名",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "sizeof大小",
    "tail": "4字节",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "sizeof大小",
    "tail": "被引用对象的大小",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "参数传递操作",
    "tail": "需要解引用",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "参数传递操作",
    "tail": "直接修饰对象",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "可变性",
    "tail": "可指向其他对象",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "可变性",
    "tail": "只能绑定一个对象",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "多级指针支持",
    "tail": "支持多级指针",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "多级指针支持",
    "tail": "仅支持一级",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "运算符意义",
    "tail": "指向地址递增",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "运算符意义",
    "tail": "对象值递增",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "内存管理",
    "tail": "必须返回动态内存",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "内存管理",
    "tail": "可能引起内存泄漏",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C语言指针",
    "relation": "const支持",
    "tail": "支持const指针",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "C++引用",
    "relation": "const支持",
    "tail": "不支持const引用",
    "source_topic": "c语言的指针和引用和c++的有什么区别？"
  },
  {
    "head": "new",
    "relation": "动态分配内存来源",
    "tail": "自由存储区",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "new",
    "relation": "无需指定",
    "tail": "内存块大小",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "malloc",
    "relation": "需要显式指定",
    "tail": "内存尺寸",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "delete",
    "relation": "必须配对使用",
    "tail": "new",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "delete []",
    "relation": "必须配对使用",
    "tail": "new int [10]",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "free",
    "relation": "必须配对使用",
    "tail": "malloc",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++内存管理机制",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C内存管理函数",
    "source_topic": "438.new与malloc的区别"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "new",
    "relation": "解决",
    "tail": "无法自动执行构造函数的问题",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "delete",
    "relation": "解决",
    "tail": "无法自动执行析构函数的问题",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "malloc/free",
    "relation": "限制",
    "tail": "无法处理对象的构造与析构",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "new/delete",
    "relation": "解决",
    "tail": "动态内存分配与初始化问题",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "构造函数",
    "relation": "执行",
    "tail": "对象创建时",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "析构函数",
    "relation": "执行",
    "tail": "对象消亡前",
    "source_topic": "439.malloc/free 为什么还要 new/delete？"
  },
  {
    "head": "delete",
    "relation": "配套",
    "tail": "new",
    "source_topic": "440.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "配套",
    "tail": "new[]",
    "source_topic": "440.delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "调用次数",
    "tail": "一次析构函数",
    "source_topic": "440.delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "调用次数",
    "tail": "每一个数组元素的析构函数",
    "source_topic": "440.delete与 delete []区别"
  },
  {
    "head": "malloc",
    "relation": "调用",
    "tail": "mmap",
    "source_topic": "441.在物理内存为1G的计算机中能否malloc(1.2G)？"
  },
  {
    "head": "mmap",
    "relation": "属于",
    "tail": "虚拟内存管理",
    "source_topic": "441.在物理内存为1G的计算机中能否malloc(1.2G)？"
  },
  {
    "head": "操作系统",
    "relation": "支持",
    "tail": "虚拟内存管理",
    "source_topic": "441.在物理内存为1G的计算机中能否malloc(1.2G)？"
  },
  {
    "head": "实时操作系统",
    "relation": "不支持",
    "tail": "虚拟内存管理",
    "source_topic": "441.在物理内存为1G的计算机中能否malloc(1.2G)？"
  },
  {
    "head": "malloc(1.2G)",
    "relation": "导致",
    "tail": "内存分配失败",
    "source_topic": "441.在物理内存为1G的计算机中能否malloc(1.2G)？"
  },
  {
    "head": "物理内存",
    "relation": "限制",
    "tail": "1G",
    "source_topic": "441.在物理内存为1G的计算机中能否malloc(1.2G)？"
  },
  {
    "head": "内存分配失败",
    "relation": "发生于",
    "tail": "实时操作系统",
    "source_topic": "441.在物理内存为1G的计算机中能否malloc(1.2G)？"
  },
  {
    "head": "C语言",
    "relation": "实现方式",
    "tail": "指针大小判断",
    "source_topic": "442.用C写个程序，如何判断一个操作系统是16位还是32位的？"
  },
  {
    "head": "指针大小判断",
    "relation": "依赖",
    "tail": "sizeof运算符",
    "source_topic": "442.用C写个程序，如何判断一个操作系统是16位还是32位的？"
  },
  {
    "head": "sizeof运算符",
    "relation": "作用",
    "tail": "返回指针所占内存字节数",
    "source_topic": "442.用C写个程序，如何判断一个操作系统是16位还是32位的？"
  },
  {
    "head": "指针所占内存字节数",
    "relation": "判断依据",
    "tail": "操作系统位数",
    "source_topic": "442.用C写个程序，如何判断一个操作系统是16位还是32位的？"
  },
  {
    "head": "4字节",
    "relation": "表示",
    "tail": "32位操作系统",
    "source_topic": "442.用C写个程序，如何判断一个操作系统是16位还是32位的？"
  },
  {
    "head": "2字节",
    "relation": "表示",
    "tail": "16位操作系统",
    "source_topic": "442.用C写个程序，如何判断一个操作系统是16位还是32位的？"
  },
  {
    "head": "位域",
    "relation": "属于",
    "tail": "C语言数据结构",
    "source_topic": "443.解释下位域，为什么要用位域，位域的好处？"
  },
  {
    "head": "位域",
    "relation": "目的",
    "tail": "节省存储空间",
    "source_topic": "443.解释下位域，为什么要用位域，位域的好处？"
  },
  {
    "head": "位域",
    "relation": "适用场景",
    "tail": "存储不需要完整字节的信息",
    "source_topic": "443.解释下位域，为什么要用位域，位域的好处？"
  },
  {
    "head": "位域",
    "relation": "解决",
    "tail": "存储空间浪费问题",
    "source_topic": "443.解释下位域，为什么要用位域，位域的好处？"
  },
  {
    "head": "逻辑与",
    "relation": "符号表示",
    "tail": "&&",
    "source_topic": "444.位操作"
  },
  {
    "head": "逻辑或",
    "relation": "符号表示",
    "tail": "||",
    "source_topic": "444.位操作"
  },
  {
    "head": "左移位",
    "relation": "符号表示",
    "tail": "<<",
    "source_topic": "444.位操作"
  },
  {
    "head": "右移位",
    "relation": "符号表示",
    "tail": ">>",
    "source_topic": "444.位操作"
  },
  {
    "head": "无符号数左移",
    "relation": "补码方式",
    "tail": "右侧补0",
    "source_topic": "444.位操作"
  },
  {
    "head": "无符号数右移",
    "relation": "补码方式",
    "tail": "左侧补0",
    "source_topic": "444.位操作"
  },
  {
    "head": "有符号数左移",
    "relation": "补码方式",
    "tail": "右侧补0",
    "source_topic": "444.位操作"
  },
  {
    "head": "有符号数右移",
    "relation": "补码方式",
    "tail": "左侧补符号位",
    "source_topic": "444.位操作"
  },
  {
    "head": "有符号数右移",
    "relation": "移位类型",
    "tail": "算术移位",
    "source_topic": "444.位操作"
  },
  {
    "head": "无符号数右移",
    "relation": "移位类型",
    "tail": "逻辑移位",
    "source_topic": "444.位操作"
  },
  {
    "head": "嵌入式系统",
    "relation": "研究对象",
    "tail": "无符号数移位",
    "source_topic": "444.位操作"
  },
  {
    "head": "整型变量",
    "relation": "设置地址",
    "tail": "0x67a9",
    "source_topic": "445.在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。"
  },
  {
    "head": "指针变量",
    "relation": "指向地址",
    "tail": "0x67a9",
    "source_topic": "445.在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。"
  },
  {
    "head": "ANSI编译器",
    "relation": "支持",
    "tail": "C语言指针操作",
    "source_topic": "445.在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。"
  },
  {
    "head": "指针解引用",
    "relation": "赋值",
    "tail": "0xaa66",
    "source_topic": "445.在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。"
  },
  {
    "head": "BIT3",
    "relation": "定义",
    "tail": "0x1<<3",
    "source_topic": "446.给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit，在以上两个操作中，要保持其它位不变。"
  },
  {
    "head": "set_bit3",
    "relation": "实现方式",
    "tail": "按位或操作",
    "source_topic": "446.给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit，在以上两个操作中，要保持其它位不变。"
  },
  {
    "head": "clear_bit3",
    "relation": "实现方式",
    "tail": "按位与非操作",
    "source_topic": "446.给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit，在以上两个操作中，要保持其它位不变。"
  },
  {
    "head": "按位或操作",
    "relation": "作用",
    "tail": "设置特定位为1",
    "source_topic": "446.给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit，在以上两个操作中，要保持其它位不变。"
  },
  {
    "head": "按位与非操作",
    "relation": "作用",
    "tail": "清除特定位为0",
    "source_topic": "446.给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit，在以上两个操作中，要保持其它位不变。"
  },
  {
    "head": "整型变量",
    "relation": "操作",
    "tail": "位操作",
    "source_topic": "446.给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit，在以上两个操作中，要保持其它位不变。"
  },
  {
    "head": "位操作",
    "relation": "应用场景",
    "tail": "位掩码处理",
    "source_topic": "446.给定一个整型变量a，写两段代码，第一个设置a的bit3，第二个清除a的bit，在以上两个操作中，要保持其它位不变。"
  },
  {
    "head": "右值引用",
    "relation": "定义",
    "tail": "用于绑定临时对象的引用类型",
    "source_topic": "447.什么是右值引用，跟左值又有什么区别"
  },
  {
    "head": "右值引用",
    "relation": "区别",
    "tail": "左值",
    "source_topic": "447.什么是右值引用，跟左值又有什么区别"
  },
  {
    "head": "左值",
    "relation": "区别",
    "tail": "右值",
    "source_topic": "447.什么是右值引用，跟左值又有什么区别"
  },
  {
    "head": "x++",
    "relation": "效率高于",
    "tail": "x=x+1",
    "source_topic": "448.判断x=x+1,x+=1,x++哪个效率最高?为什么?"
  },
  {
    "head": "x++",
    "relation": "效率高于",
    "tail": "x+=1",
    "source_topic": "448.判断x=x+1,x+=1,x++哪个效率最高?为什么?"
  },
  {
    "head": "x=x+1",
    "relation": "执行步骤包含",
    "tail": "读取右x的地址",
    "source_topic": "448.判断x=x+1,x+=1,x++哪个效率最高?为什么?"
  },
  {
    "head": "x=x+1",
    "relation": "执行步骤包含",
    "tail": "x+1",
    "source_topic": "448.判断x=x+1,x+=1,x++哪个效率最高?为什么?"
  },
  {
    "head": "x=x+1",
    "relation": "执行步骤包含",
    "tail": "读取左x的地址",
    "source_topic": "448.判断x=x+1,x+=1,x++哪个效率最高?为什么?"
  },
  {
    "head": "x=x+1",
    "relation": "执行步骤包含",
    "tail": "将右值传给左边的x",
    "source_topic": "448.判断x=x+1,x+=1,x++哪个效率最高?为什么?"
  },
  {
    "head": "编译器",
    "relation": "不认为",
    "tail": "左右两边的x的地址相同",
    "source_topic": "448.判断x=x+1,x+=1,x++哪个效率最高?为什么?"
  },
  {
    "head": "C语言",
    "relation": "属于",
    "tail": "强类型语言",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "C语言",
    "relation": "要求",
    "tail": "变量必须声明取值类型",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "char",
    "relation": "占用位数",
    "tail": "8位",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "char",
    "relation": "占用字节数",
    "tail": "1字节",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "short",
    "relation": "占用位数",
    "tail": "16位",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "short",
    "relation": "占用字节数",
    "tail": "2字节",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "int",
    "relation": "占用位数",
    "tail": "32位",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "int",
    "relation": "占用字节数",
    "tail": "4字节",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "long",
    "relation": "占用位数",
    "tail": "32位",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "long",
    "relation": "占用字节数",
    "tail": "4字节",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "float",
    "relation": "占用位数",
    "tail": "32位",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "float",
    "relation": "占用字节数",
    "tail": "4字节",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "double",
    "relation": "占用位数",
    "tail": "64位",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "double",
    "relation": "占用字节数",
    "tail": "8字节",
    "source_topic": "450.C语言是强类型的语言，这是什么意思？"
  },
  {
    "head": "char",
    "relation": "转换规则",
    "tail": "int最低一个字节",
    "source_topic": "451.char 与 int之间的转换"
  },
  {
    "head": "int",
    "relation": "转换规则",
    "tail": "char截断",
    "source_topic": "451.char 与 int之间的转换"
  },
  {
    "head": "float",
    "relation": "包含",
    "tail": "1bit(符号位)",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "float",
    "relation": "包含",
    "tail": "8bit(指数位)",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "float",
    "relation": "包含",
    "tail": "23bit(尾数位)",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "float",
    "relation": "核心特性",
    "tail": "最多有7位有效数字",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "double",
    "relation": "包含",
    "tail": "1bit(符号位)",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "double",
    "relation": "包含",
    "tail": "11bit(指数位)",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "double",
    "relation": "包含",
    "tail": "52bit(尾数位)",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "double",
    "relation": "核心特性",
    "tail": "精度为15~16位",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "printf",
    "relation": "限制",
    "tail": "小数点后6位",
    "source_topic": "float（单精度浮点型）和double（双精度浮点型）"
  },
  {
    "head": "转义字符",
    "relation": "表示方法",
    "tail": "使用斜杠/",
    "source_topic": "453.字符常量"
  },
  {
    "head": "char b[5],*p=b",
    "relation": "正确赋值语句",
    "tail": "p=“abcd”",
    "source_topic": "453.字符常量"
  },
  {
    "head": "字符型常量",
    "relation": "正确表示",
    "tail": "’\\t’",
    "source_topic": "453.字符常量"
  },
  {
    "head": "字符型常量",
    "relation": "错误表示",
    "tail": "“a”",
    "source_topic": "453.字符常量"
  },
  {
    "head": "字符型常量",
    "relation": "错误表示",
    "tail": "297",
    "source_topic": "453.字符常量"
  },
  {
    "head": "字符型常量",
    "relation": "错误表示",
    "tail": "“abcd”",
    "source_topic": "453.字符常量"
  },
  {
    "head": "非图形字符",
    "relation": "表示方式",
    "tail": "转义字符",
    "source_topic": "453.字符常量"
  },
  {
    "head": "bool型数据",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "454.写出bool 、int、 指针变量与“零值”比较的if语句"
  },
  {
    "head": "int型数据",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "454.写出bool 、int、 指针变量与“零值”比较的if语句"
  },
  {
    "head": "指针变量",
    "relation": "比较方式",
    "tail": "零值",
    "source_topic": "454.写出bool 、int、 指针变量与“零值”比较的if语句"
  },
  {
    "head": "%d",
    "relation": "对应数据类型",
    "tail": "int",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "%ld",
    "relation": "对应数据类型",
    "tail": "long",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "%lld",
    "relation": "对应数据类型",
    "tail": "long long",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "%lf",
    "relation": "对应数据类型",
    "tail": "double",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "%f",
    "relation": "对应数据类型",
    "tail": "float",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "int",
    "relation": "在32位编译器中等于",
    "tail": "long",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "long",
    "relation": "在32位编译器中等于",
    "tail": "32bit",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "long long",
    "relation": "在32位编译器中等于",
    "tail": "64bit",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "float",
    "relation": "输入格式",
    "tail": "%f",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "double",
    "relation": "输入格式",
    "tail": "%lf",
    "source_topic": "456.区分 `%d`, `%ld`, `%lld`, `%lf`, `%f`"
  },
  {
    "head": "printf",
    "relation": "支持",
    "tail": "左对齐",
    "source_topic": "输出数据问题"
  },
  {
    "head": "printf",
    "relation": "支持",
    "tail": "右对齐",
    "source_topic": "输出数据问题"
  },
  {
    "head": "printf",
    "relation": "使用",
    "tail": "格式化字符串",
    "source_topic": "输出数据问题"
  },
  {
    "head": "%10.3f",
    "relation": "指定",
    "tail": "浮点数精度",
    "source_topic": "输出数据问题"
  },
  {
    "head": "%10.3f",
    "relation": "指定",
    "tail": "字段宽度",
    "source_topic": "输出数据问题"
  },
  {
    "head": "%04d",
    "relation": "指定",
    "tail": "整数宽度",
    "source_topic": "输出数据问题"
  },
  {
    "head": "%04d",
    "relation": "填充",
    "tail": "前导零",
    "source_topic": "输出数据问题"
  },
  {
    "head": "左对齐",
    "relation": "实现方式",
    "tail": "在格式化字符串中添加负号",
    "source_topic": "输出数据问题"
  },
  {
    "head": "右对齐",
    "relation": "实现方式",
    "tail": "在格式化字符串中指定宽度",
    "source_topic": "输出数据问题"
  },
  {
    "head": "printf",
    "relation": "输出",
    "tail": "格式化数据",
    "source_topic": "输出数据问题"
  },
  {
    "head": "C语言",
    "relation": "实现方式",
    "tail": "while(1)",
    "source_topic": "458.嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环"
  },
  {
    "head": "C语言",
    "relation": "实现方式",
    "tail": "for(;;)",
    "source_topic": "458.嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环"
  },
  {
    "head": "惰性计算方法",
    "relation": "应用在",
    "tail": "C语言循环条件",
    "source_topic": "459.惰性计算方法"
  },
  {
    "head": "C语言循环条件",
    "relation": "包含",
    "tail": "逻辑与运算符",
    "source_topic": "459.惰性计算方法"
  },
  {
    "head": "逻辑与运算符",
    "relation": "特性",
    "tail": "短路求值",
    "source_topic": "459.惰性计算方法"
  },
  {
    "head": "k++",
    "relation": "属于",
    "tail": "后置递增操作",
    "source_topic": "459.惰性计算方法"
  },
  {
    "head": "后置递增操作",
    "relation": "特性",
    "tail": "先使用当前值，再递增",
    "source_topic": "459.惰性计算方法"
  },
  {
    "head": "n++>2",
    "relation": "属于",
    "tail": "后置递增比较操作",
    "source_topic": "459.惰性计算方法"
  },
  {
    "head": "后置递增比较操作",
    "relation": "特性",
    "tail": "先使用当前值进行比较，再递增",
    "source_topic": "459.惰性计算方法"
  },
  {
    "head": "变量声明",
    "relation": "区别",
    "tail": "变量定义",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量定义",
    "relation": "功能",
    "tail": "为变量分配地址和存储空间",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量声明",
    "relation": "功能",
    "tail": "不分配地址",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量声明",
    "relation": "允许",
    "tail": "在多个地方声明",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "变量定义",
    "relation": "唯一性",
    "tail": "只在一个地方定义",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "extern修饰符",
    "relation": "作用",
    "tail": "表示变量的声明",
    "source_topic": "变量的声明和定义有什么区别"
  },
  {
    "head": "sizeof",
    "relation": "参数类型",
    "tail": "数据类型或变量",
    "source_topic": "463.sizeof和strlen的区别"
  },
  {
    "head": "strlen",
    "relation": "参数类型",
    "tail": "以'\\",
    "source_topic": "463.sizeof和strlen的区别"
  },
  {
    "head": "C语言 static",
    "relation": "具有",
    "tail": "记忆性",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C语言 static",
    "relation": "具有",
    "tail": "隐藏性",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C++ static",
    "relation": "具有",
    "tail": "记忆性",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C++ static",
    "relation": "具有",
    "tail": "隐藏性",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C++ static",
    "relation": "用于定义",
    "tail": "类的成员变量",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C++ static",
    "relation": "用于定义",
    "tail": "类的成员函数",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C++ static",
    "relation": "扩展功能",
    "tail": "静态成员",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C++ static",
    "relation": "扩展功能",
    "tail": "静态成员函数",
    "source_topic": "c语言中的static和C++中static的区别"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "值传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "指针传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "引用传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "全局变量初始化",
    "relation": "不属于",
    "tail": "main()函数引起的动作",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例。"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "全局变量初始化过程",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例。"
  },
  {
    "head": "全局变量初始化",
    "relation": "触发",
    "tail": "构造函数执行",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例。"
  },
  {
    "head": "构造函数",
    "relation": "属于",
    "tail": "类A的成员函数",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例。"
  },
  {
    "head": "面向对象",
    "relation": "基于",
    "tail": "对象的角度",
    "source_topic": "谈谈对面向对象的认识"
  },
  {
    "head": "面向对象",
    "relation": "对比",
    "tail": "基于功能的程序设计",
    "source_topic": "谈谈对面向对象的认识"
  },
  {
    "head": "面向对象",
    "relation": "设计目标",
    "tail": "程序简洁清晰",
    "source_topic": "谈谈对面向对象的认识"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "封装性",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "继承性",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "多态性",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "封装性",
    "relation": "实现方式",
    "tail": "protection",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "protection",
    "relation": "具体实现",
    "tail": "private",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "protection",
    "relation": "具体实现",
    "tail": "protected",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "protection",
    "relation": "具体实现",
    "tail": "public",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "继承性",
    "relation": "目的",
    "tail": "重用代码",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "继承性",
    "relation": "优势",
    "tail": "节省开发时间",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "继承性",
    "relation": "实现方式",
    "tail": "子类继承父类的属性和方法",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "多态性",
    "relation": "技术实现",
    "tail": "父类对象赋值为子类对象",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "多态性",
    "relation": "作用",
    "tail": "根据子对象特性以不同方式运作",
    "source_topic": "469.面向对象的三大特性"
  },
  {
    "head": "编译器",
    "relation": "生成",
    "tail": "虚函数表",
    "source_topic": "简述多态的原理"
  },
  {
    "head": "虚函数表",
    "relation": "包含",
    "tail": "指向对应虚函数的指针",
    "source_topic": "简述多态的原理"
  },
  {
    "head": "编译器",
    "relation": "插入",
    "tail": "vptr指针",
    "source_topic": "简述多态的原理"
  },
  {
    "head": "vptr指针",
    "relation": "指向",
    "tail": "虚函数表",
    "source_topic": "简述多态的原理"
  },
  {
    "head": "vptr指针",
    "relation": "关联",
    "tail": "对应的vtable",
    "source_topic": "简述多态的原理"
  },
  {
    "head": "this指针",
    "relation": "指向",
    "tail": "具体的类",
    "source_topic": "简述多态的原理"
  },
  {
    "head": "this指针",
    "relation": "获取",
    "tail": "正确的vtable",
    "source_topic": "简述多态的原理"
  },
  {
    "head": "抽象类",
    "relation": "定义条件",
    "tail": "具有纯虚函数的类",
    "source_topic": "472.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "限制",
    "tail": "不能声明对象",
    "source_topic": "472.多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "用途",
    "tail": "只能作为基类为派生类服务",
    "source_topic": "472.多态，虚函数，纯虚函数"
  },
  {
    "head": "派生类",
    "relation": "实现条件",
    "tail": "完全实现基类的所有纯虚函数",
    "source_topic": "472.多态，虚函数，纯虚函数"
  },
  {
    "head": "派生类",
    "relation": "结果",
    "tail": "不再是抽象类",
    "source_topic": "472.多态，虚函数，纯虚函数"
  },
  {
    "head": "重载",
    "relation": "属于",
    "tail": "同一名字子空间",
    "source_topic": "473.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别?"
  },
  {
    "head": "重定义/隐藏",
    "relation": "属于",
    "tail": "不同名字子空间",
    "source_topic": "473.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别?"
  },
  {
    "head": "重定义/隐藏",
    "relation": "用途",
    "tail": "用于继承",
    "source_topic": "473.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别?"
  },
  {
    "head": "重写/覆盖",
    "relation": "属于",
    "tail": "不同名字子空间",
    "source_topic": "473.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别?"
  },
  {
    "head": "重写/覆盖",
    "relation": "用途",
    "tail": "用于继承",
    "source_topic": "473.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别?"
  },
  {
    "head": "重写/覆盖",
    "relation": "定义",
    "tail": "子类重新定义父类虚函数的方法",
    "source_topic": "473.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别?"
  },
  {
    "head": "C++运算符重载",
    "relation": "限制",
    "tail": "不能改变内部数据类型的运算符",
    "source_topic": "474.所有的运算符都能重载吗？"
  },
  {
    "head": "C++运算符重载",
    "relation": "限制",
    "tail": "运算符‘.’",
    "source_topic": "474.所有的运算符都能重载吗？"
  },
  {
    "head": "C++运算符重载",
    "relation": "限制",
    "tail": "未存在的符号如#,@,$",
    "source_topic": "474.所有的运算符都能重载吗？"
  },
  {
    "head": "C++运算符重载",
    "relation": "限制",
    "tail": "不能改变运算符优先级规则",
    "source_topic": "474.所有的运算符都能重载吗？"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "模板类",
    "source_topic": "用C++设计一个不能继承的类"
  },
  {
    "head": "构造函数",
    "relation": "不能为",
    "tail": "虚函数",
    "source_topic": "476.构造函数能否为虚函数"
  },
  {
    "head": "析构函数",
    "relation": "可以为",
    "tail": "虚函数",
    "source_topic": "476.构造函数能否为虚函数"
  },
  {
    "head": "虚函数表指针",
    "relation": "初始化阶段",
    "tail": "构造函数初始化列表",
    "source_topic": "476.构造函数能否为虚函数"
  },
  {
    "head": "虚函数表指针",
    "relation": "用于调用",
    "tail": "虚函数",
    "source_topic": "476.构造函数能否为虚函数"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "真正意义上的常量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "真正意义上的常量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "只读变量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "允许",
    "tail": "通过指针修改const变量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "限制",
    "tail": "const变量不可修改",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "const变量作为数组大小",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "const变量作为数组大小",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "内联函数",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "替代",
    "tail": "宏代码片段",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "减少",
    "tail": "参数压栈",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "减少",
    "tail": "跳转",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "减少",
    "tail": "返回",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "发生在",
    "tail": "编译阶段",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "检查",
    "tail": "参数检查",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "检查",
    "tail": "返回值检查",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "限制",
    "tail": "不能有任何形式的循环",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "限制",
    "tail": "不能有过多的条件判断",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "限制",
    "tail": "不能对函数进行取地址操作",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "编译器",
    "relation": "支持",
    "tail": "内联函数",
    "source_topic": "478.宏和内联（inline）函数的比较？"
  },
  {
    "head": "typedef",
    "relation": "用法不同",
    "tail": "定义数据类型的别名",
    "source_topic": "typedef和define由什么区别"
  },
  {
    "head": "define",
    "relation": "用法不同",
    "tail": "定义常量和书写复杂使用频繁的宏",
    "source_topic": "typedef和define由什么区别"
  },
  {
    "head": "typedef",
    "relation": "执行时间不同",
    "tail": "编译过程的一部分",
    "source_topic": "typedef和define由什么区别"
  },
  {
    "head": "define",
    "relation": "执行时间不同",
    "tail": "预编译的部分",
    "source_topic": "typedef和define由什么区别"
  },
  {
    "head": "typedef",
    "relation": "包含",
    "tail": "类型检查",
    "source_topic": "typedef和define由什么区别"
  },
  {
    "head": "define",
    "relation": "不包含",
    "tail": "类型检查",
    "source_topic": "typedef和define由什么区别"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "内存溢出",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strcpy",
    "relation": "不包含",
    "tail": "检查措施",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strcpy",
    "relation": "不包含",
    "tail": "判断拷贝大小",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strcpy",
    "relation": "不包含",
    "tail": "判断目的地址内存是否够用",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strncat",
    "relation": "主要功能",
    "tail": "在字符串的结尾追加n个字符",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strncat",
    "relation": "参数",
    "tail": "size_t n",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strcat",
    "relation": "主要功能",
    "tail": "将两个char类型字符串连接",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strcat",
    "relation": "参数",
    "tail": "char *dest",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strcat",
    "relation": "参数",
    "tail": "char *src",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "memcpy",
    "relation": "区别",
    "tail": "strcpy",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "memcpy",
    "relation": "可以拷贝",
    "tail": "任意类型的数据",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "strcpy",
    "relation": "只能拷贝",
    "tail": "字符串类型",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "memcpy",
    "relation": "参数",
    "tail": "void *dest",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "memcpy",
    "relation": "参数",
    "tail": "void *src",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "memcpy",
    "relation": "控制",
    "tail": "拷贝的字节数",
    "source_topic": "strcat、strncat、strcpy哪些函数会导致内存溢出？如何改进？"
  },
  {
    "head": "队列",
    "relation": "属于",
    "tail": "线性存储结构",
    "source_topic": "481.简述队列和栈的异同"
  },
  {
    "head": "队列",
    "relation": "核心特性",
    "tail": "先进先出",
    "source_topic": "481.简述队列和栈的异同"
  },
  {
    "head": "动态分配的对象",
    "relation": "例如",
    "tail": "malloc出来的对象",
    "source_topic": "482.堆和栈的区别？"
  },
  {
    "head": "非static对象",
    "relation": "例如",
    "tail": "局部变量",
    "source_topic": "482.堆和栈的区别？"
  },
  {
    "head": "自由存储区",
    "relation": "属于",
    "tail": "C++的抽象概念",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "自由存储区",
    "relation": "分配方式",
    "tail": "new",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "自由存储区",
    "relation": "释放方式",
    "tail": "delete",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "C++",
    "relation": "建议使用",
    "tail": "智能指针",
    "source_topic": "什么是内存泄漏？面对内存泄漏有什么避免方法"
  },
  {
    "head": "malloc",
    "relation": "需要配合",
    "tail": "free",
    "source_topic": "什么是内存泄漏？面对内存泄漏有什么避免方法"
  },
  {
    "head": "new",
    "relation": "需要配合",
    "tail": "delete",
    "source_topic": "什么是内存泄漏？面对内存泄漏有什么避免方法"
  },
  {
    "head": "链表",
    "relation": "存储形式",
    "tail": "可不连续的动态空间",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "数组",
    "relation": "存储形式",
    "tail": "一块连续的空间",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "长度可变",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "数组",
    "relation": "核心特性",
    "tail": "声明时就要确定长度",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "每个结点保存相邻结点指针",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "数组",
    "relation": "核心特性",
    "tail": "存在越界问题",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "不存在越界问题",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "数组",
    "relation": "数据查找",
    "tail": "线性查找速度快",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "数组",
    "relation": "数据查找",
    "tail": "使用偏移地址",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "链表",
    "relation": "数据查找",
    "tail": "需要按顺序检索结点",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "链表",
    "relation": "数据查找",
    "tail": "效率低",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "链表",
    "relation": "数据插入或删除",
    "tail": "快速插入和删除结点",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "数组",
    "relation": "数据插入或删除",
    "tail": "可能需要大量数据移动",
    "source_topic": "485.链表和数组的区别"
  },
  {
    "head": "结构",
    "relation": "区别",
    "tail": "联合",
    "source_topic": "486.结构与联合有和区别"
  },
  {
    "head": "结构",
    "relation": "赋值特性",
    "tail": "对不同成员赋值互不影响",
    "source_topic": "486.结构与联合有和区别"
  },
  {
    "head": "结构体指针",
    "relation": "访问成员方式",
    "tail": "使用'->'操作符",
    "source_topic": "486.结构与联合有和区别"
  },
  {
    "head": "结构体变量",
    "relation": "访问成员方式",
    "tail": "使用'.'操作符",
    "source_topic": "486.结构与联合有和区别"
  },
  {
    "head": "结构名",
    "relation": "作用",
    "tail": "作为结构的标识符，不是变量名",
    "source_topic": "486.结构与联合有和区别"
  },
  {
    "head": "结构变量",
    "relation": "定义要求",
    "tail": "需要先对其定义",
    "source_topic": "486.结构与联合有和区别"
  },
  {
    "head": "引用",
    "relation": "属于",
    "tail": "计算机编程概念",
    "source_topic": "487.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "定义",
    "tail": "目标变量的别名",
    "source_topic": "487.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "特性",
    "tail": "不占存储单元",
    "source_topic": "487.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "特性",
    "tail": "系统不分配存储单元",
    "source_topic": "487.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "限制",
    "tail": "不能建立数组的引用",
    "source_topic": "487.什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用传递",
    "relation": "效果相同于",
    "tail": "指针传递",
    "source_topic": "488.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "操作方式",
    "tail": "直接对实参操作",
    "source_topic": "488.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "内存特点",
    "tail": "不产生实参的副本",
    "source_topic": "488.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "使用场景",
    "tail": "函数参数",
    "source_topic": "488.将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "单端数组",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "deque",
    "relation": "底层结构",
    "tail": "双端数组",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "双向链表",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "set",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "deque",
    "relation": "核心特性",
    "tail": "支持头尾两端的插入和删除操作",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "适合频繁且不确定位置的元素操作",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "vector",
    "relation": "建议使用",
    "tail": "优先于deque",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "deque",
    "relation": "缺点",
    "tail": "迭代器比vector复杂",
    "source_topic": "489.STL标准模板库"
  },
  {
    "head": "if(i = 1)",
    "relation": "导致",
    "tail": "j=3",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "if(i = 2)",
    "relation": "导致",
    "tail": "j=5",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "if(i=3)",
    "relation": "导致",
    "tail": "j=6",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "有符号数",
    "relation": "隐式转换",
    "tail": "无符号数",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "a+b",
    "relation": "计算结果",
    "tail": "-14",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "a+b>6",
    "relation": "比较结果",
    "tail": "c=1",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "a+b",
    "relation": "比较结果",
    "tail": "大于6",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "a+b",
    "relation": "计算结果",
    "tail": "无符号数",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "a+b",
    "relation": "比较结果",
    "tail": "远大于6",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "数组a",
    "relation": "地址",
    "tail": "&a",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "&a",
    "relation": "类型",
    "tail": "行指针",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "&a+1",
    "relation": "指向",
    "tail": "下一行首地址",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "ptr",
    "relation": "指向",
    "tail": "&a+1",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "*(a+1)",
    "relation": "等价于",
    "tail": "a[1]",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "*(ptr-1)",
    "relation": "等价于",
    "tail": "a[4]",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "printf",
    "relation": "输出",
    "tail": "2,5",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "内存越界",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "char a",
    "relation": "大小",
    "tail": "1字节",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "字符串hello",
    "relation": "长度",
    "tail": "5字节",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "strcpy",
    "relation": "操作",
    "tail": "将字符串赋值给字符变量",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "野指针",
    "relation": "导致",
    "tail": "段错误",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "段错误",
    "relation": "原因",
    "tail": "未初始化指针",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "指针p",
    "relation": "未分配空间",
    "tail": "段错误",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "wap函数",
    "relation": "导致",
    "tail": "段错误",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "指针p",
    "relation": "未初始化",
    "tail": "段错误",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "指针p",
    "relation": "未指向有效内存",
    "tail": "段错误",
    "source_topic": "490.陷阱题"
  },
  {
    "head": "C++源文件",
    "relation": "经过",
    "tail": "预处理",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "预处理",
    "relation": "生成",
    "tail": ".ii文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "C++源文件",
    "relation": "经过",
    "tail": "编译",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "编译",
    "relation": "生成",
    "tail": "汇编文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "汇编文件",
    "relation": "属于",
    "tail": ".s文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "汇编",
    "relation": "生成",
    "tail": "目标文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "目标文件",
    "relation": "属于",
    "tail": ".o文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "目标文件",
    "relation": "属于",
    "tail": ".obj文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "链接",
    "relation": "生成",
    "tail": "可执行文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "可执行文件",
    "relation": "属于",
    "tail": ".out文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "可执行文件",
    "relation": "属于",
    "tail": ".exe文件",
    "source_topic": "一个C++源文件从文本到可执行文件经历的过程"
  },
  {
    "head": "#include",
    "relation": "影响",
    "tail": "头文件引用顺序",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "头文件引用顺序",
    "relation": "导致",
    "tail": "变量类型未声明错误",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "#include",
    "relation": "区分",
    "tail": "尖括号和双引号",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "#include<>",
    "relation": "表示",
    "tail": "标准头文件",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "#include<>",
    "relation": "查找位置",
    "tail": "预定义的位置集",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "预定义的位置集",
    "relation": "修改方式",
    "tail": "设置查找路径环境变量",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "预定义的位置集",
    "relation": "修改方式",
    "tail": "命令行选项",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "#include\"",
    "relation": "表示",
    "tail": "非系统头文件",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "#include\"",
    "relation": "查找起点",
    "tail": "源文件所在的路径",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "#include\"",
    "relation": "查找范围",
    "tail": "大于标准头文件查找范围",
    "source_topic": "include 的顺序以及尖叫括号和双引号的区别"
  },
  {
    "head": "线程",
    "relation": "属于",
    "tail": "进程",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "进程",
    "relation": "导致",
    "tail": "独立地址空间分配",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "独立地址空间分配",
    "relation": "解决",
    "tail": "资源开销问题",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "线程",
    "relation": "共享",
    "tail": "地址空间",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "线程切换",
    "relation": "效率更高",
    "tail": "进程切换",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "进程间通信",
    "relation": "解决",
    "tail": "数据传递问题",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "线程间通信",
    "relation": "解决",
    "tail": "数据传递问题",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "线程",
    "relation": "属于",
    "tail": "多任务工作方式",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "多线程程序",
    "relation": "改善",
    "tail": "程序结构",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "多线程程序",
    "relation": "支持",
    "tail": "多CPU系统",
    "source_topic": "进程和线程，为什么要有线程"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "auto",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "nullptr",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "for循环新语法",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "std::array",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "std::thread",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "std::atomic",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "std::shared_ptr",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "std::weak_ptr",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "std::function",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "std::bind",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "lambda表达式",
    "source_topic": "C++11有哪些新特性"
  },
  {
    "head": "malloc",
    "relation": "底层结构",
    "tail": "空闲链表",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "malloc",
    "relation": "功能",
    "tail": "分配内存",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "malloc",
    "relation": "实现方式",
    "tail": "查找足够大的内存块",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "malloc",
    "relation": "实现方式",
    "tail": "分割内存块",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "malloc",
    "relation": "实现方式",
    "tail": "返回剩余内存块到空闲链表",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "free",
    "relation": "功能",
    "tail": "释放内存",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "free",
    "relation": "实现方式",
    "tail": "将内存块连接到空闲链表",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "malloc",
    "relation": "实现方式",
    "tail": "合并相邻空闲块",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "brk",
    "relation": "功能",
    "tail": "调整数据段的最高地址指针",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "mmap",
    "relation": "功能",
    "tail": "分配虚拟内存",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "mmap",
    "relation": "位置",
    "tail": "文件映射区域",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "brk",
    "relation": "分配类型",
    "tail": "虚拟内存",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "mmap",
    "relation": "分配类型",
    "tail": "虚拟内存",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "缺页中断",
    "relation": "触发条件",
    "tail": "第一次访问已分配的虚拟地址空间",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "缺页中断",
    "relation": "处理方式",
    "tail": "操作系统分配物理内存",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "malloc",
    "relation": "底层实现",
    "tail": "brk",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "malloc",
    "relation": "底层实现",
    "tail": "mmap",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "free",
    "relation": "底层实现",
    "tail": "munmap",
    "source_topic": "malloc的原理，brk系统调用干什么的，mmap呢"
  },
  {
    "head": "C++",
    "relation": "内存管理方式包含",
    "tail": "全局/静态存储区",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存储内容包含",
    "tail": "全局变量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存储内容包含",
    "tail": "静态变量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "全局/静态存储区",
    "relation": "内存释放方式",
    "tail": "程序结束时自动释放",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "全局/静态存储区",
    "relation": "包含",
    "tail": "DATA段",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "全局/静态存储区",
    "relation": "包含",
    "tail": "BSS段",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "DATA段",
    "relation": "存储内容包含",
    "tail": "初始化的全局变量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "DATA段",
    "relation": "存储内容包含",
    "tail": "初始化的静态变量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "BSS段",
    "relation": "存储内容包含",
    "tail": "未初始化的全局变量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "BSS段",
    "relation": "存储内容包含",
    "tail": "未初始化的静态变量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "BSS段",
    "relation": "内存特点",
    "tail": "程序执行前自动清零",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "C++",
    "relation": "内存管理方式包含",
    "tail": "文字常量区",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "文字常量区",
    "relation": "存储内容包含",
    "tail": "常量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "文字常量区",
    "relation": "内存特点",
    "tail": "不允许修改",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "文字常量区",
    "relation": "内存释放方式",
    "tail": "程序结束后由系统释放",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "C++",
    "relation": "内存管理方式包含",
    "tail": "程序代码区",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "程序代码区",
    "relation": "存储内容包含",
    "tail": "程序的二进制代码",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "SGI版本STL",
    "relation": "默认配置器",
    "tail": "std::alloc",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "std::alloc",
    "relation": "参见",
    "tail": "《STL源码剖析》",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "SGI版本STL",
    "relation": "内存管理方式包含",
    "tail": "双层配置器",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "双层配置器",
    "relation": "第一级配置器使用",
    "tail": "malloc",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "双层配置器",
    "relation": "第一级配置器使用",
    "tail": "free",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "内存池",
    "relation": "核心组成",
    "tail": "16个自由链表",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "自由链表",
    "relation": "管理",
    "tail": "8bytes",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "自由链表",
    "relation": "管理",
    "tail": "16bytes",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "自由链表",
    "relation": "管理",
    "tail": "128bytes",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "内存池",
    "relation": "分配策略",
    "tail": "当自由链表为空时请求分配空间",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "内存池",
    "relation": "分配策略",
    "tail": "默认为自由链表分配20个区块",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "内存池",
    "relation": "分配策略",
    "tail": "当剩余容量不足时分配最大容量",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "chunk_alloc",
    "relation": "分配策略",
    "tail": "尝试调用malloc分配",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "chunk_alloc",
    "relation": "分配策略",
    "tail": "否则返回bad_alloc异常",
    "source_topic": "C++的内存管理方式，STL的allocator，最新版本默认使用的分配器"
  },
  {
    "head": "hash表",
    "relation": "实现涉及",
    "tail": "散列函数",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "hash表",
    "relation": "实现涉及",
    "tail": "碰撞处理",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "碰撞处理",
    "relation": "解决方法",
    "tail": "线性探测",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "碰撞处理",
    "relation": "解决方法",
    "tail": "二次探测",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "碰撞处理",
    "relation": "解决方法",
    "tail": "开链法",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "SGI STL",
    "relation": "使用",
    "tail": "开链法",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "SGI STL",
    "relation": "设计表格大小为",
    "tail": "质数",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "SGI STL",
    "relation": "包含",
    "tail": "28个质数",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "SGI STL",
    "relation": "提供函数查询",
    "tail": "最接近某数并大于某数的质数",
    "source_topic": "hash表的实现，包括STL中的哈希桶长度常数。"
  },
  {
    "head": "Hash表",
    "relation": "导致",
    "tail": "负载因子达到1",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "负载因子",
    "relation": "影响",
    "tail": "Hash表查找的期望复杂度",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "Hash表",
    "relation": "保证",
    "tail": "负载因子小于1",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "Hash表",
    "relation": "处理方式",
    "tail": "Rehash",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "Rehash",
    "relation": "基于",
    "tail": "扩容方式",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "扩容方式",
    "relation": "模仿",
    "tail": "C++ vector",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "Rehash",
    "relation": "涉及",
    "tail": "开辟新桶数组",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "新桶数组",
    "relation": "空间大小",
    "tail": "原桶数组的两倍",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "Rehash",
    "relation": "需要",
    "tail": "元素重新哈希",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "元素重新哈希",
    "relation": "操作对象",
    "tail": "原桶数组中的元素",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "元素重新哈希",
    "relation": "目标",
    "tail": "新桶数组",
    "source_topic": "hash表如何rehash，怎么处理其中保存的资源"
  },
  {
    "head": "Redis rehash",
    "relation": "实现方式",
    "tail": "渐进式rehash",
    "source_topic": "Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"
  },
  {
    "head": "渐进式rehash",
    "relation": "实现步骤",
    "tail": "为ht[1]分配空间",
    "source_topic": "Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"
  },
  {
    "head": "渐进式rehash",
    "relation": "核心特性",
    "tail": "分而治之",
    "source_topic": "Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"
  },
  {
    "head": "渐进式rehash",
    "relation": "核心特性",
    "tail": "将计算工作均摊到每个字典操作上",
    "source_topic": "Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"
  },
  {
    "head": "Redis哈希表",
    "relation": "包含",
    "tail": "ht[0]",
    "source_topic": "Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"
  },
  {
    "head": "Redis哈希表",
    "relation": "包含",
    "tail": "ht[1]",
    "source_topic": "Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的"
  },
  {
    "head": "Redis服务器",
    "relation": "实现",
    "tail": "定时机制",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "定时机制",
    "relation": "基于",
    "tail": "时间事件",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "时间事件",
    "relation": "包含",
    "tail": "id",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "时间事件",
    "relation": "包含",
    "tail": "when",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "时间事件",
    "relation": "包含",
    "tail": "timeProc",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "时间事件处理器",
    "relation": "判断",
    "tail": "定时事件或周期性事件",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "Redis服务器",
    "relation": "处理",
    "tail": "文件事件",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "Redis服务器",
    "relation": "处理",
    "tail": "时间事件",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "时间事件",
    "relation": "导致",
    "tail": "实际处理时间不准确",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "时间事件",
    "relation": "导致",
    "tail": "处理时间稍晚",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "改进",
    "relation": "可能方案",
    "tail": "多线程",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "多线程",
    "relation": "处理",
    "tail": "文件事件",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "多线程",
    "relation": "处理",
    "tail": "时间事件",
    "source_topic": "Redis的定时机制怎么实现的，有哪些弊端，你将如何改进这个弊端"
  },
  {
    "head": "Redis",
    "relation": "使用",
    "tail": "I/O多路复用程序",
    "source_topic": "Redis是单线程的，为什么这么高效"
  },
  {
    "head": "I/O多路复用程序",
    "relation": "实现",
    "tail": "高性能的网络通信模型",
    "source_topic": "Redis是单线程的，为什么这么高效"
  },
  {
    "head": "Redis",
    "relation": "保持",
    "tail": "内部单线程设计的简单性",
    "source_topic": "Redis是单线程的，为什么这么高效"
  },
  {
    "head": "文件事件处理器",
    "relation": "属于",
    "tail": "Redis",
    "source_topic": "Redis是单线程的，为什么这么高效"
  },
  {
    "head": "文件事件处理器",
    "relation": "运行方式",
    "tail": "单线程",
    "source_topic": "Redis是单线程的，为什么这么高效"
  },
  {
    "head": "I/O多路复用程序",
    "relation": "监听",
    "tail": "多个套接字",
    "source_topic": "Redis是单线程的，为什么这么高效"
  },
  {
    "head": "Redis字符串",
    "relation": "底层结构",
    "tail": "整数值",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis字符串",
    "relation": "底层结构",
    "tail": "简单动态字符串（SDS）",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis列表",
    "relation": "底层结构",
    "tail": "压缩列表",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis列表",
    "relation": "底层结构",
    "tail": "双端链表",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis哈希",
    "relation": "底层结构",
    "tail": "压缩列表",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis哈希",
    "relation": "底层结构",
    "tail": "字典",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis集合",
    "relation": "底层结构",
    "tail": "整数集合",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis集合",
    "relation": "底层结构",
    "tail": "字典",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis有序集合",
    "relation": "底层结构",
    "tail": "压缩列表",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis有序集合",
    "relation": "底层结构",
    "tail": "跳跃表",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis有序集合",
    "relation": "底层结构",
    "tail": "字典",
    "source_topic": "Redis的数据类型有哪些，底层怎么实现"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "set",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "list",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Memcached",
    "relation": "支持",
    "tail": "简单数据类型",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "数据落地持久化存储",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Memcached",
    "relation": "不支持",
    "tail": "数据落地持久化存储",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Memcached",
    "relation": "支持",
    "tail": "一致性hash",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Memcached",
    "relation": "限制",
    "tail": "key长度小于250字符",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Memcached",
    "relation": "限制",
    "tail": "单个item存储小于1M",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Redis",
    "relation": "使用",
    "tail": "单线程模型",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "单线程模型",
    "relation": "保证",
    "tail": "数据按顺序提交",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Memcached",
    "relation": "使用",
    "tail": "CAS",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "CAS",
    "relation": "属于",
    "tail": "乐观锁",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Redis",
    "relation": "限制",
    "tail": "只能使用一个cpu",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "Redis",
    "relation": "解决",
    "tail": "开启多个redis进程",
    "source_topic": "Redis和memcached的区别"
  },
  {
    "head": "TCP",
    "relation": "属于",
    "tail": "四层模型",
    "source_topic": "TCP的模型，状态转移"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "三次握手",
    "source_topic": "TCP的模型，状态转移"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "四次释放",
    "source_topic": "TCP的模型，状态转移"
  },
  {
    "head": "三次握手",
    "relation": "实现",
    "tail": "状态转移",
    "source_topic": "TCP的模型，状态转移"
  },
  {
    "head": "四次释放",
    "relation": "实现",
    "tail": "状态转移",
    "source_topic": "TCP的模型，状态转移"
  },
  {
    "head": "Strategy模式",
    "relation": "实现方式",
    "tail": "std::function",
    "source_topic": "用过哪些设计模式，单例模式，观察者模式的多线程安全问题"
  },
  {
    "head": "pthread_create",
    "relation": "属于",
    "tail": "线程创建",
    "source_topic": "用过多线程吗，以前的多线程代码还能怎么优化，线程池的实现"
  },
  {
    "head": "pthread_cancel",
    "relation": "用于",
    "tail": "终止同一进程中的另一个线程",
    "source_topic": "用过多线程吗，以前的多线程代码还能怎么优化，线程池的实现"
  },
  {
    "head": "pthread_exit",
    "relation": "用于",
    "tail": "终止当前线程",
    "source_topic": "用过多线程吗，以前的多线程代码还能怎么优化，线程池的实现"
  },
  {
    "head": "epoll",
    "relation": "实现",
    "tail": "epoll_create",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "epoll_create",
    "relation": "返回",
    "tail": "eventpoll的对象",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "eventpoll",
    "relation": "包含",
    "tail": "红黑树",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "红黑树",
    "relation": "存储",
    "tail": "需要监控的事件",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "eventpoll",
    "relation": "包含",
    "tail": "双链表",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "双链表",
    "relation": "存放",
    "tail": "满足条件的事件",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "epoll",
    "relation": "实现",
    "tail": "epoll_ctl",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "epoll_ctl",
    "relation": "功能",
    "tail": "添加、删除、修改感兴趣的事件",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "epoll",
    "relation": "实现",
    "tail": "epoll_wait",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "Reactor模型",
    "relation": "包含",
    "tail": "Handle",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "Handle",
    "relation": "定义",
    "tail": "操作系统中的句柄",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "Handle",
    "relation": "属于",
    "tail": "Socket Handle",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "Reactor模型",
    "relation": "包含",
    "tail": "EventHandler",
    "source_topic": "epoll怎么实现的，reactor模型组成"
  },
  {
    "head": "互斥量",
    "relation": "属于",
    "tail": "线程同步方式",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "条件变量",
    "relation": "属于",
    "tail": "线程同步方式",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "信号量",
    "relation": "属于",
    "tail": "线程同步方式",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_init",
    "relation": "属于",
    "tail": "信号量系统调用",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_wait",
    "relation": "属于",
    "tail": "信号量系统调用",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_trywait",
    "relation": "属于",
    "tail": "信号量系统调用",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_post",
    "relation": "属于",
    "tail": "信号量系统调用",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_destroy",
    "relation": "属于",
    "tail": "信号量系统调用",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_wait",
    "relation": "功能",
    "tail": "获取资源并使信号量值减1",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_trywait",
    "relation": "功能",
    "tail": "尝试获取资源，不挂起等待",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_post",
    "relation": "功能",
    "tail": "释放资源并使信号量值加1",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "sem_post",
    "relation": "作用",
    "tail": "唤醒挂起等待的线程",
    "source_topic": "线程间的同步方式，最好说出具体的系统调用"
  },
  {
    "head": "哈希表",
    "relation": "使用",
    "tail": "质数",
    "source_topic": "哈希表的桶个数为什么是质数，合数有何不妥？"
  },
  {
    "head": "质数",
    "relation": "优势",
    "tail": "避免冲撞",
    "source_topic": "哈希表的桶个数为什么是质数，合数有何不妥？"
  },
  {
    "head": "哈希表",
    "relation": "避免使用",
    "tail": "合数",
    "source_topic": "哈希表的桶个数为什么是质数，合数有何不妥？"
  },
  {
    "head": "合数",
    "relation": "劣势",
    "tail": "冲撞概率增加",
    "source_topic": "哈希表的桶个数为什么是质数，合数有何不妥？"
  },
  {
    "head": "哈希表",
    "relation": "核心特性",
    "tail": "分布均匀",
    "source_topic": "哈希表的桶个数为什么是质数，合数有何不妥？"
  },
  {
    "head": "C内存",
    "relation": "包含",
    "tail": "程序代码区",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "C内存",
    "relation": "包含",
    "tail": "全局/静态存储区",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "C内存",
    "relation": "包含",
    "tail": "常量存储区",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "C++内存",
    "relation": "包含",
    "tail": "自由存储区",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "程序代码区",
    "relation": "存储内容",
    "tail": "二进制代码",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存储内容",
    "tail": "全局变量",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "全局/静态存储区",
    "relation": "存储内容",
    "tail": "static变量",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "常量存储区",
    "relation": "存储内容",
    "tail": "常量",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "全局/静态存储区",
    "relation": "初始化方式",
    "tail": "缺省值",
    "source_topic": "C/C++内存有哪几种类型？"
  },
  {
    "head": "动态分配的对象",
    "relation": "由程序控制",
    "tail": "生存期",
    "source_topic": "堆和栈的区别？"
  },
  {
    "head": "非static对象",
    "relation": "定义在",
    "tail": "函数内的局部变量",
    "source_topic": "堆和栈的区别？"
  },
  {
    "head": "静态内存",
    "relation": "保存",
    "tail": "static对象",
    "source_topic": "堆和栈的区别？"
  },
  {
    "head": "静态内存",
    "relation": "保存",
    "tail": "类static数据成员",
    "source_topic": "堆和栈的区别？"
  },
  {
    "head": "静态内存",
    "relation": "保存",
    "tail": "定义在任何函数外部的变量",
    "source_topic": "堆和栈的区别？"
  },
  {
    "head": "static对象",
    "relation": "分配时间",
    "tail": "使用之前",
    "source_topic": "堆和栈的区别？"
  },
  {
    "head": "static对象",
    "relation": "销毁时间",
    "tail": "程序结束时",
    "source_topic": "堆和栈的区别？"
  },
  {
    "head": "自由存储区",
    "relation": "属于",
    "tail": "C++中的抽象概念",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "自由存储区",
    "relation": "被分配",
    "tail": "new运算符",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "自由存储区",
    "relation": "被释放",
    "tail": "delete运算符",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "C++编译器",
    "relation": "默认使用",
    "tail": "堆实现自由存储",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "全局运算符new",
    "relation": "可能实现方式",
    "tail": "malloc",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "全局运算符delete",
    "relation": "可能实现方式",
    "tail": "free",
    "source_topic": "堆和自由存储区的区别？"
  },
  {
    "head": "程序编译过程",
    "relation": "包含",
    "tail": "预处理",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "程序编译过程",
    "relation": "包含",
    "tail": "编译",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "程序编译过程",
    "relation": "包含",
    "tail": "汇编",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "程序编译过程",
    "relation": "包含",
    "tail": "链接",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "预处理",
    "relation": "处理",
    "tail": "头文件包含",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "预处理",
    "relation": "处理",
    "tail": "宏替换",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "预处理",
    "relation": "处理",
    "tail": "条件编译",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "编译",
    "relation": "生成",
    "tail": "汇编代码",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "汇编",
    "relation": "生成",
    "tail": "目标代码",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "链接",
    "relation": "生成",
    "tail": "可执行文件",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "C语言程序",
    "relation": "经过",
    "tail": "程序编译过程",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "hello.c",
    "relation": "属于",
    "tail": "C语言程序",
    "source_topic": "程序编译的过程？"
  },
  {
    "head": "负数",
    "relation": "存储方式",
    "tail": "补码",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "补码",
    "relation": "定义",
    "tail": "负数补码为反码加1",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "补码",
    "relation": "定义",
    "tail": "正数补码为原码",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "补码",
    "relation": "使用原因",
    "tail": "统一加减法",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "补码",
    "relation": "使用原因",
    "tail": "解决正负零问题",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "浮点数",
    "relation": "分类",
    "tail": "单精度类型",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "浮点数",
    "relation": "分类",
    "tail": "双精度类型",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "单精度类型",
    "relation": "存储规范",
    "tail": "IEEE R32.24",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "双精度类型",
    "relation": "存储规范",
    "tail": "IEEE R64.53",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "浮点数存储",
    "relation": "包含",
    "tail": "符号位",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "浮点数存储",
    "relation": "包含",
    "tail": "指数位",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "浮点数存储",
    "relation": "包含",
    "tail": "尾数部分",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "符号位",
    "relation": "功能",
    "tail": "表示正负，0代表正，1代表负",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "指数位",
    "relation": "功能",
    "tail": "存储科学计数法中的指数数据",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "指数位",
    "relation": "存储方式",
    "tail": "移位存储",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "尾数部分",
    "relation": "功能",
    "tail": "存储数值的尾数部分",
    "source_topic": "计算机内部如何存储负数和浮点数？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "参数拷贝",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "参数拷贝",
    "relation": "顺序",
    "tail": "从右到左",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "保存返回地址",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "跳转到目标函数",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "栈帧结构建立",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "栈帧结构建立",
    "relation": "包含",
    "tail": "移动ebp和esp",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "执行函数体",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "返回值传递",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "栈帧结构恢复",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "栈帧结构恢复",
    "relation": "包含",
    "tail": "出栈操作",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "函数调用",
    "relation": "包含",
    "tail": "返回到调用者",
    "source_topic": "函数调用的过程？"
  },
  {
    "head": "左值",
    "relation": "特性",
    "tail": "可以取地址",
    "source_topic": "左值和右值"
  },
  {
    "head": "左值",
    "relation": "特性",
    "tail": "有名字",
    "source_topic": "左值和右值"
  },
  {
    "head": "左值",
    "relation": "特性",
    "tail": "非临时",
    "source_topic": "左值和右值"
  },
  {
    "head": "右值",
    "relation": "特性",
    "tail": "不能取地址",
    "source_topic": "左值和右值"
  },
  {
    "head": "右值",
    "relation": "特性",
    "tail": "没有名字",
    "source_topic": "左值和右值"
  },
  {
    "head": "右值",
    "relation": "特性",
    "tail": "临时",
    "source_topic": "左值和右值"
  },
  {
    "head": "右值",
    "relation": "生命周期",
    "tail": "通常在某个表达式之内",
    "source_topic": "左值和右值"
  },
  {
    "head": "右值",
    "relation": "可修改性",
    "tail": "可以通过成员函数修改",
    "source_topic": "左值和右值"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "lvalue",
    "source_topic": "左值和右值"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "glvalue",
    "source_topic": "左值和右值"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "rvalue",
    "source_topic": "左值和右值"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "xvalue",
    "source_topic": "左值和右值"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "prvalue",
    "source_topic": "左值和右值"
  },
  {
    "head": "内存泄漏",
    "relation": "解决",
    "tail": "使用的时候要记得指针的长度",
    "source_topic": "什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？"
  },
  {
    "head": "指针越界",
    "relation": "解决",
    "tail": "使用的时候要记得指针的长度",
    "source_topic": "什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？"
  },
  {
    "head": "智能指针",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？"
  },
  {
    "head": "C++11",
    "relation": "包含",
    "tail": "shared_ptr",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "C++11",
    "relation": "包含",
    "tail": "unique_ptr",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "C++11",
    "relation": "包含",
    "tail": "weak_ptr",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "shared_ptr",
    "relation": "引用计数实现方式",
    "tail": "堆上存储",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "unique_ptr",
    "relation": "实现方式",
    "tail": "拷贝构造函数声明为delete",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "unique_ptr",
    "relation": "实现方式",
    "tail": "赋值操作符声明为private",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "make_shared",
    "relation": "作用",
    "tail": "避免内存泄露",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "make_unique",
    "relation": "作用",
    "tail": "避免内存泄露",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "shared_ptr",
    "relation": "是否线程安全",
    "tail": "部分线程安全",
    "source_topic": "C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？"
  },
  {
    "head": "C++",
    "relation": "是",
    "tail": "C的超集",
    "source_topic": "C和C++的区别？"
  },
  {
    "head": "C程序设计",
    "relation": "首要考虑",
    "tail": "如何通过过程处理输入输出",
    "source_topic": "C和C++的区别？"
  },
  {
    "head": "C++",
    "relation": "首要考虑",
    "tail": "如何构造对象模型",
    "source_topic": "C和C++的区别？"
  },
  {
    "head": "C++对象模型",
    "relation": "契合",
    "tail": "对应的问题域",
    "source_topic": "C和C++的区别？"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "只读变量",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "常量",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数参数",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数返回值",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "const成员函数",
    "relation": "限制",
    "tail": "修改成员变量的值",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "const成员函数",
    "relation": "可以访问",
    "tail": "非const成员",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "只读对象",
    "relation": "只能调用",
    "tail": "const成员函数",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "const成员变量",
    "relation": "属于",
    "tail": "类的成员变量",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "const成员函数",
    "relation": "属于",
    "tail": "类的成员函数",
    "source_topic": "const 有什么用途"
  },
  {
    "head": "C语言",
    "relation": "无法定义",
    "tail": "真正意义上的常量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "const变量存储于",
    "tail": "栈空间（局部const常量）",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "只读变量",
    "tail": "无法修改",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "可以定义",
    "tail": "真正意义上的常量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const变量加入",
    "tail": "符号表（编译期）",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const变量",
    "tail": "不可修改",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "真正常量实现方式",
    "tail": "enum",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "const变量",
    "tail": "运行期无效",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const变量初始化方式",
    "tail": "字面量初始化（加入符号表）",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const变量初始化方式",
    "tail": "变量初始化（只读变量）",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const成员变量",
    "tail": "只读变量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const成员变量修改方式",
    "tail": "可以通过指针修改",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const成员变量初始化方式",
    "tail": "初始化列表",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++11",
    "relation": "引入",
    "tail": "constexpr",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "constexpr",
    "relation": "用于表示",
    "tail": "真正意义上的常量",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "constexpr",
    "relation": "函数结果计算于",
    "tail": "编译期",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "constexpr",
    "relation": "依赖条件",
    "tail": "所依赖的内容在编译期可计算",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "const变量",
    "tail": "无法通过指针修改（理论上）",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const变量",
    "tail": "无法通过指针修改（实际）",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "const变量",
    "tail": "允许通过指针修改（实际）",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C语言",
    "relation": "const变量",
    "tail": "编译期不可用于数组定义",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "const变量",
    "tail": "编译期可用于数组定义",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "C++",
    "relation": "constexpr函数",
    "tail": "结果在编译期计算",
    "source_topic": "在C中用const 能定义真正意义上的常量吗？C++中的const呢？"
  },
  {
    "head": "内联函数",
    "relation": "引入于",
    "tail": "C++",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "C++",
    "relation": "推荐使用",
    "tail": "内联函数",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "减少",
    "tail": "参数压栈",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "减少",
    "tail": "跳转",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "减少",
    "tail": "返回",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "发生阶段",
    "tail": "编译阶段",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "提供",
    "tail": "参数检查",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "提供",
    "tail": "返回值检查",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "相较",
    "tail": "更安全",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "inline关键字",
    "relation": "提出请求",
    "tail": "编译器",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "由编译器决定",
    "tail": "是否内联",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "可能实现于",
    "tail": "定义在class内部的方法",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "限制",
    "tail": "不能过于复杂",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "最初限制",
    "tail": "不能有任何形式的循环",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "最初限制",
    "tail": "不能有过多的条件判断",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "内联函数",
    "relation": "最初限制",
    "tail": "不能对函数进行取地址操作",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "现代编译器",
    "relation": "支持",
    "tail": "复杂内联函数",
    "source_topic": "宏和内联（inline）函数的比较？"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "new",
    "relation": "解决",
    "tail": "无法自动执行构造函数的问题",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "delete",
    "relation": "解决",
    "tail": "无法自动执行析构函数的问题",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "malloc",
    "relation": "限制",
    "tail": "不支持构造函数和析构函数",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "new",
    "relation": "触发",
    "tail": "构造函数",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "delete",
    "relation": "触发",
    "tail": "析构函数",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "malloc",
    "relation": "依赖",
    "tail": "C标准库",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "new",
    "relation": "无需依赖",
    "tail": "C标准库",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "new运算符",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "delete运算符",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "new",
    "relation": "支持",
    "tail": "面向对象特性",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "malloc",
    "relation": "不支持",
    "tail": "面向对象特性",
    "source_topic": "C++中有了malloc / free , 为什么还需要 new / delete？"
  },
  {
    "head": "C语言",
    "relation": "使用",
    "tail": "强制类型转换语法",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "强制类型转换语法",
    "relation": "定义",
    "tail": "在变量或表达式前加（目标类型）",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "C语言强制类型转换",
    "relation": "缺点",
    "tail": "缺少编译检查",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "C语言强制类型转换",
    "relation": "缺点",
    "tail": "容易导致难以发现的错误",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "C++语言",
    "relation": "引入",
    "tail": "static_cast",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "static_cast",
    "relation": "用于",
    "tail": "基本类型间转换",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "static_cast",
    "relation": "不用于",
    "tail": "基本类型指针间转换",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "static_cast",
    "relation": "用于",
    "tail": "有继承关系类对象间转换",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "static_cast",
    "relation": "用于",
    "tail": "有继承关系类指针间转换",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "C++语言",
    "relation": "引入",
    "tail": "dynamic_cast",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "dynamic_cast",
    "relation": "用于",
    "tail": "有继承关系的类指针间转换",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "dynamic_cast",
    "relation": "用于",
    "tail": "有交叉关系的类指针间转换",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "dynamic_cast",
    "relation": "特性",
    "tail": "具有类型检查功能",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "dynamic_cast",
    "relation": "要求",
    "tail": "需要虚函数支持",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "C++语言",
    "relation": "引入",
    "tail": "const_cast",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "const_cast",
    "relation": "用于",
    "tail": "去掉变量的const属性",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "const_cast",
    "relation": "限制",
    "tail": "目标类型必须是引用或指针",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "C++语言",
    "relation": "支持",
    "tail": "类型转换构造函数",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "类型转换构造函数",
    "relation": "限制",
    "tail": "无法抑制隐式调用",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "类型转换构造函数",
    "relation": "导致",
    "tail": "隐式调用成为bug来源",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "C++语言",
    "relation": "替代方案",
    "tail": "显式调用普通函数",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "test类",
    "relation": "定义",
    "tail": "toInt()普通函数",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "类型转换函数",
    "relation": "功能",
    "tail": "将类转换为普通类型",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "显式调用普通函数",
    "relation": "实现",
    "tail": "显式类型转换",
    "source_topic": "C和C++中的强制类型转换？"
  },
  {
    "head": "static",
    "relation": "用于定义",
    "tail": "静态（局部/全局）变量",
    "source_topic": "static 有什么用途"
  },
  {
    "head": "static",
    "relation": "用于定义",
    "tail": "静态函数",
    "source_topic": "static 有什么用途"
  },
  {
    "head": "static",
    "relation": "用于定义",
    "tail": "类的静态数据成员",
    "source_topic": "static 有什么用途"
  },
  {
    "head": "static",
    "relation": "用于定义",
    "tail": "类的静态成员函数",
    "source_topic": "static 有什么用途"
  },
  {
    "head": "静态成员变量",
    "relation": "需要在类内声明",
    "tail": "static",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员变量",
    "relation": "在类外初始化",
    "tail": "不加static",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员变量",
    "relation": "存储位置",
    "tail": "全局数据区",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员变量",
    "relation": "生命周期",
    "tail": "不依赖于类的某个对象",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员变量",
    "relation": "访问方式",
    "tail": "通过对象名直接访问",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员变量",
    "relation": "访问方式",
    "tail": "通过类名直接调用",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员函数",
    "relation": "属于",
    "tail": "类所共享",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员函数",
    "relation": "可以访问",
    "tail": "静态成员变量",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员函数",
    "relation": "不能直接访问",
    "tail": "普通成员变量",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员函数",
    "relation": "访问方式",
    "tail": "通过对象名直接访问",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "静态成员函数",
    "relation": "访问方式",
    "tail": "通过类名直接调用",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "普通成员函数",
    "relation": "可以访问",
    "tail": "普通成员变量",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "普通成员函数",
    "relation": "可以访问",
    "tail": "静态成员变量",
    "source_topic": "类的静态成员变量和静态成员函数各有哪些特性？"
  },
  {
    "head": "C++编译器",
    "relation": "产生",
    "tail": "函数名修饰",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”?"
  },
  {
    "head": "C编译器",
    "relation": "不支持",
    "tail": "函数重载",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”?"
  },
  {
    "head": "C++编译器",
    "relation": "支持",
    "tail": "函数重载",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”?"
  },
  {
    "head": "函数重载",
    "relation": "导致",
    "tail": "函数名不同",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”?"
  },
  {
    "head": "extern\"C\"",
    "relation": "解决",
    "tail": "函数名匹配问题",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”?"
  },
  {
    "head": "extern\"C\"",
    "relation": "指定",
    "tail": "C链接方式",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”?"
  },
  {
    "head": "C链接方式",
    "relation": "避免",
    "tail": "函数名修饰",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”?"
  },
  {
    "head": "ifndef",
    "relation": "由",
    "tail": "语言本身提供支持",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "program once",
    "relation": "由",
    "tail": "编译器提供支持",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "program once",
    "relation": "可能不被支持",
    "tail": "老的编译器",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "ifndef",
    "relation": "运行速度",
    "tail": "慢于 program once",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "program once",
    "relation": "速度优势",
    "tail": "大型项目中更明显",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "ifndef",
    "relation": "作用范围",
    "tail": "某一段被包含的代码",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "program once",
    "relation": "作用范围",
    "tail": "包含该语句的整个文件",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "program once",
    "relation": "速度更快原因",
    "tail": "针对整个文件",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "ifndef",
    "relation": "潜在问题",
    "tail": "宏名字撞车导致宏未定义",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "program once",
    "relation": "潜在问题",
    "tail": "无法从内容判断是否同一个头文件",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "program once",
    "relation": "判断依据",
    "tail": "物理文件",
    "source_topic": "头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？"
  },
  {
    "head": "i++",
    "relation": "底层结构",
    "tail": "返回i的值",
    "source_topic": "当i是一个整数的时候++i和i++那个更快一点？i++和++i的区别是什么？"
  },
  {
    "head": "++i",
    "relation": "底层结构",
    "tail": "返回i+1的值",
    "source_topic": "当i是一个整数的时候++i和i++那个更快一点？i++和++i的区别是什么？"
  },
  {
    "head": "i++",
    "relation": "区别",
    "tail": "返回的是i的值",
    "source_topic": "当i是一个整数的时候++i和i++那个更快一点？i++和++i的区别是什么？"
  },
  {
    "head": "++i",
    "relation": "区别",
    "tail": "返回的是i+1的值",
    "source_topic": "当i是一个整数的时候++i和i++那个更快一点？i++和++i的区别是什么？"
  },
  {
    "head": "i++",
    "relation": "性能",
    "tail": "通常与++i几乎无差别",
    "source_topic": "当i是一个整数的时候++i和i++那个更快一点？i++和++i的区别是什么？"
  },
  {
    "head": "++i",
    "relation": "性能",
    "tail": "理论上更快",
    "source_topic": "当i是一个整数的时候++i和i++那个更快一点？i++和++i的区别是什么？"
  },
  {
    "head": "i++",
    "relation": "性能",
    "tail": "编译器优化影响实际性能",
    "source_topic": "当i是一个整数的时候++i和i++那个更快一点？i++和++i的区别是什么？"
  },
  {
    "head": "指针",
    "relation": "属于",
    "tail": "地址概念",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "属于",
    "tail": "地址概念",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "内存地址",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "指向",
    "tail": "内存别名",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "内部实现",
    "tail": "指针",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "替代",
    "tail": "指针",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "区别",
    "tail": "实体",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "区别",
    "tail": "别名",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "初始化",
    "tail": "定义时初始化一次",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "初始化",
    "tail": "可变",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "特性",
    "tail": "从一而终",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "特性",
    "tail": "见异思迁",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "限制",
    "tail": "不能为空",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "限制",
    "tail": "可以为空",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "sizeof 引用",
    "relation": "返回",
    "tail": "变量大小",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "sizeof 指针",
    "relation": "返回",
    "tail": "指针大小",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "支持",
    "tail": "自增运算",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "支持",
    "tail": "自增运算",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "自增运算",
    "relation": "意义不同",
    "tail": "指针与引用",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "特性",
    "tail": "类型安全",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "特性",
    "tail": "非类型安全",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "优势",
    "tail": "可读性",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "优势",
    "tail": "实用性",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "占用内存空间",
    "tail": "内存空间",
    "source_topic": "引用占用内存空间吗？"
  },
  {
    "head": "引用",
    "relation": "底层实现",
    "tail": "指针",
    "source_topic": "引用占用内存空间吗？"
  },
  {
    "head": "引用",
    "relation": "等价于",
    "tail": "常量指针",
    "source_topic": "引用占用内存空间吗？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "引用",
    "source_topic": "引用占用内存空间吗？"
  },
  {
    "head": "引用",
    "relation": "取地址",
    "tail": "引用所对应的内存空间的地址",
    "source_topic": "引用占用内存空间吗？"
  },
  {
    "head": "引用",
    "relation": "内部实现",
    "tail": "指针",
    "source_topic": "引用占用内存空间吗？"
  },
  {
    "head": "指针",
    "relation": "占用内存空间",
    "tail": "内存空间",
    "source_topic": "引用占用内存空间吗？"
  },
  {
    "head": "三目运算符",
    "relation": "结果类型",
    "tail": "右值",
    "source_topic": "三目运算符"
  },
  {
    "head": "三目运算符",
    "relation": "返回类型",
    "tail": "引用",
    "source_topic": "三目运算符"
  },
  {
    "head": "C语言",
    "relation": "限制",
    "tail": "三目运算符结果仅作为右值",
    "source_topic": "三目运算符"
  },
  {
    "head": "C++",
    "relation": "改进",
    "tail": "允许三目运算符返回引用",
    "source_topic": "三目运算符"
  },
  {
    "head": "三目运算符",
    "relation": "实现方式",
    "tail": "引用",
    "source_topic": "三目运算符"
  },
  {
    "head": "数组指针",
    "relation": "本质为",
    "tail": "指针",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "数组指针",
    "relation": "指向",
    "tail": "数组首元素的地址",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "指针数组",
    "relation": "本质为",
    "tail": "数组",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "指针数组",
    "relation": "元素类型为",
    "tail": "指针",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "指针数组",
    "relation": "形式为",
    "tail": "类型名 数组标识符[数组长度]",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "数组指针",
    "relation": "区别于",
    "tail": "指针数组",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "p+1",
    "relation": "跨过",
    "tail": "n个整型数据的长度",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "指针数组",
    "relation": "区别于",
    "tail": "数组指针",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "指针数组",
    "relation": "元素",
    "tail": "指针变量",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "指针数组",
    "relation": "可以用来存放",
    "tail": "变量地址",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "p+1",
    "relation": "指向下一个",
    "tail": "数组元素",
    "source_topic": "指针数组和数组指针的区别"
  },
  {
    "head": "左值引用",
    "relation": "属于",
    "tail": "C++引用",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "左值引用",
    "relation": "绑定对象",
    "tail": "左值",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "右值引用",
    "relation": "属于",
    "tail": "C++引用",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "右值引用",
    "relation": "绑定对象",
    "tail": "右值",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "右值引用",
    "relation": "特性",
    "tail": "延长右值的生存期",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "右值引用",
    "relation": "引入版本",
    "tail": "C++11",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "左值引用",
    "relation": "限制",
    "tail": "不能直接绑定到立即数",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "左值引用",
    "relation": "允许绑定",
    "tail": "常量",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "右值引用",
    "relation": "允许绑定",
    "tail": "临时对象",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "右值引用",
    "relation": "操作权限",
    "tail": "支持读写操作",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "左值引用",
    "relation": "操作权限",
    "tail": "仅支持读操作",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "move函数",
    "relation": "作用",
    "tail": "将左值转换为右值引用",
    "source_topic": "左值引用与右值引用"
  },
  {
    "head": "右值引用",
    "relation": "支持",
    "tail": "移动语义",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "移动语义",
    "relation": "实现",
    "tail": "减少拷贝",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "减少拷贝",
    "relation": "提升",
    "tail": "程序执行效率",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "右值引用",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "factory_new",
    "relation": "使用",
    "tail": "右值引用",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "std::forward",
    "relation": "用于",
    "tail": "完美转发",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "完美转发",
    "relation": "实现",
    "tail": "保留参数的值类别",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "右值",
    "relation": "不能直接绑定",
    "tail": "左值引用",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "右值",
    "relation": "可以绑定",
    "tail": "右值引用",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "右值引用",
    "relation": "解决",
    "tail": "右值无法直接传递的问题",
    "source_topic": "右值引用的意义"
  },
  {
    "head": "面向对象",
    "relation": "属于",
    "tail": "编程范式",
    "source_topic": "什么是面向对象（OOP）？面向对象的意义？"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "数据抽象",
    "source_topic": "什么是面向对象（OOP）？面向对象的意义？"
  },
  {
    "head": "面向对象",
    "relation": "核心特性",
    "tail": "动态绑定",
    "source_topic": "什么是面向对象（OOP）？面向对象的意义？"
  },
  {
    "head": "面向对象",
    "relation": "意义",
    "tail": "引入日常思维方式到程序设计",
    "source_topic": "什么是面向对象（OOP）？面向对象的意义？"
  },
  {
    "head": "面向对象",
    "relation": "意义",
    "tail": "直观映射需求概念到解决方案",
    "source_topic": "什么是面向对象（OOP）？面向对象的意义？"
  },
  {
    "head": "面向对象",
    "relation": "意义",
    "tail": "构建可复用的软件系统",
    "source_topic": "什么是面向对象（OOP）？面向对象的意义？"
  },
  {
    "head": "面向对象",
    "relation": "意义",
    "tail": "提高软件可维护性和可扩展性",
    "source_topic": "什么是面向对象（OOP）？面向对象的意义？"
  },
  {
    "head": "封装",
    "relation": "属于",
    "tail": "面向对象程序设计",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "封装",
    "relation": "核心特性",
    "tail": "将数据或函数集合在类中",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "封装",
    "relation": "目的",
    "tail": "保护或防止代码被无意中破坏",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "public",
    "relation": "允许",
    "tail": "类的对象访问",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "private",
    "relation": "限制",
    "tail": "类的对象不能访问",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "protected",
    "relation": "允许",
    "tail": "子类继承",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "protected",
    "relation": "限制",
    "tail": "类外不能直接调用",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "虚继承",
    "relation": "解决",
    "tail": "多重继承问题",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "虚继承",
    "relation": "解决",
    "tail": "浪费存储空间",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "虚继承",
    "relation": "解决",
    "tail": "二义性问题",
    "source_topic": "解释下封装、继承和多态？"
  },
  {
    "head": "默认构造函数",
    "relation": "生成条件",
    "tail": "类没有任何构造函数",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "默认拷贝构造函数",
    "relation": "生成条件",
    "tail": "类没有定义拷贝构造函数",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "定义",
    "tail": "拷贝后对象的逻辑状态相同",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "定义",
    "tail": "拷贝后对象的物理状态相同",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "默认拷贝构造函数",
    "relation": "属于",
    "tail": "浅拷贝",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "使用场景",
    "tail": "类成员指代了系统资源",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "系统资源",
    "relation": "示例",
    "tail": "动态内存空间",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "系统资源",
    "relation": "示例",
    "tail": "外存中的文件",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "系统资源",
    "relation": "示例",
    "tail": "网络接口",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "解决",
    "tail": "多次释放系统资源问题",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "定义原则",
    "tail": "类是否有成员调用了系统资源",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "深拷贝",
    "relation": "实现条件",
    "tail": "需要定义拷贝构造函数",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "浅拷贝",
    "relation": "实现方式",
    "tail": "默认拷贝构造函数",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "拷贝构造",
    "relation": "触发方式",
    "tail": "等号出现在构造新对象时",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "赋值操作符",
    "relation": "触发方式",
    "tail": "等号出现在已有对象时",
    "source_topic": "什么时候生成默认构造函数（无参构造函数）？什么时候生成默认拷贝构造函数？什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "父类的构造函数",
    "source_topic": "构造函数和析构函数的执行顺序？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "成员变量的构造函数",
    "source_topic": "构造函数和析构函数的执行顺序？"
  },
  {
    "head": "构造函数",
    "relation": "执行顺序",
    "tail": "类自身的构造函数",
    "source_topic": "构造函数和析构函数的执行顺序？"
  },
  {
    "head": "析构函数",
    "relation": "调用顺序",
    "tail": "与构造函数的调用顺序相反",
    "source_topic": "构造函数和析构函数的执行顺序？"
  },
  {
    "head": "析构函数",
    "relation": "调用顺序",
    "tail": "与delete的顺序相关",
    "source_topic": "构造函数和析构函数的执行顺序？"
  },
  {
    "head": "虚析构函数",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "虚析构函数",
    "relation": "导致",
    "tail": "编译器添加虚函数表",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "虚函数表",
    "relation": "增加",
    "tail": "类的存储空间",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "虚析构函数",
    "relation": "适用条件",
    "tail": "类被用作基类",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "析构函数",
    "relation": "调用顺序",
    "tail": "派生类析构函数先于基类析构函数",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "delete操作",
    "relation": "触发",
    "tail": "析构函数调用",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "基类A",
    "relation": "包含",
    "tail": "虚析构函数",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "派生类B",
    "relation": "继承",
    "tail": "基类A",
    "source_topic": "虚析构函数的作用？"
  },
  {
    "head": "拷贝构造函数",
    "relation": "参数类型要求",
    "tail": "当前类的引用",
    "source_topic": "细看拷贝构造函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "避免",
    "tail": "循环调用",
    "source_topic": "细看拷贝构造函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "参数类型要求",
    "tail": "const引用",
    "source_topic": "细看拷贝构造函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "目的",
    "tail": "用其它对象的数据初始化当前对象",
    "source_topic": "细看拷贝构造函数"
  },
  {
    "head": "非const参数",
    "relation": "限制",
    "tail": "不能传递const对象",
    "source_topic": "细看拷贝构造函数"
  },
  {
    "head": "C++编译环境",
    "relation": "包含",
    "tail": "C++标准库",
    "source_topic": "C++的编译环境"
  },
  {
    "head": "C++编译环境",
    "relation": "包含",
    "tail": "C语言兼容库",
    "source_topic": "C++的编译环境"
  },
  {
    "head": "C++编译环境",
    "relation": "包含",
    "tail": "编译器扩展库",
    "source_topic": "C++的编译环境"
  },
  {
    "head": "C++编译环境",
    "relation": "包含",
    "tail": "编译模块",
    "source_topic": "C++的编译环境"
  },
  {
    "head": "C语言兼容库",
    "relation": "功能相同",
    "tail": "C++标准库中的C语言子库",
    "source_topic": "C++的编译环境"
  },
  {
    "head": "C语言兼容库",
    "relation": "目的",
    "tail": "兼容C语言编译器",
    "source_topic": "C++的编译环境"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "容器",
    "source_topic": "STL 六大组件"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "算法",
    "source_topic": "STL 六大组件"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "迭代器",
    "source_topic": "STL 六大组件"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "仿函数",
    "source_topic": "STL 六大组件"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "适配器",
    "source_topic": "STL 六大组件"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "空间配置器",
    "source_topic": "STL 六大组件"
  },
  {
    "head": "std::stack",
    "relation": "设计原则",
    "tail": "分离弹出和取值操作",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "pop()",
    "relation": "功能",
    "tail": "移除栈顶元素",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "top()",
    "relation": "功能",
    "tail": "获取栈顶元素",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "动态数组",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "std::bad_alloc",
    "relation": "属于",
    "tail": "C++标准库异常",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "pop()",
    "relation": "潜在问题",
    "tail": "数据丢失",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "top()",
    "relation": "解决",
    "tail": "避免数据丢失",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "内存分配",
    "relation": "可能导致",
    "tail": "系统资源不足",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "系统资源不足",
    "relation": "解决",
    "tail": "释放部分内存",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "std::stack",
    "relation": "设计考虑",
    "tail": "异常安全性",
    "source_topic": "stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "红黑树",
    "relation": "属于",
    "tail": "非严格平衡二叉搜索树",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "AVL树",
    "relation": "属于",
    "tail": "严格平衡二叉搜索树",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "元素有序",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "红黑树",
    "relation": "核心特性",
    "tail": "自动排序",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "unordered_map",
    "relation": "底层结构",
    "tail": "哈希表",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "哈希表",
    "relation": "核心特性",
    "tail": "建立比较耗费时间",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "哈希表",
    "relation": "核心特性",
    "tail": "占用内存相比红黑树要高",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "unordered_map",
    "relation": "使用场景",
    "tail": "查找问题优先使用",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "红黑树",
    "relation": "核心特性",
    "tail": "旋转次数少",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "红黑树",
    "relation": "提出背景",
    "tail": "在AVL树的基础上提出",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "map",
    "relation": "选择原因",
    "tail": "红黑树性能稳定",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "AVL树",
    "relation": "导致",
    "tail": "频繁的rebalance",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "AVL树",
    "relation": "导致",
    "tail": "效率下降",
    "source_topic": "map 和 unordered_map 的区别？各自的优缺点？"
  },
  {
    "head": "指针数组",
    "relation": "初始化方法",
    "tail": "传递已存在变量的地址",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "指针数组",
    "relation": "初始化方法",
    "tail": "使用new开辟堆空间",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "指针数组",
    "relation": "初始化方法",
    "tail": "设置为NULL或0",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "new",
    "relation": "导致",
    "tail": "堆内存分配",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "delete",
    "relation": "解决",
    "tail": "释放堆内存",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "指针",
    "relation": "必须操作",
    "tail": "初始化",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "未初始化指针",
    "relation": "导致",
    "tail": "野指针",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "野指针",
    "relation": "导致",
    "tail": "程序运行异常",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "指针数组",
    "relation": "分类",
    "tail": "存放指针的数组",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "指向数组的指针",
    "relation": "分类",
    "tail": "指针",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "堆内存",
    "relation": "特性",
    "tail": "不会自动释放",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "栈内存",
    "relation": "特性",
    "tail": "会自动释放",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "变量内存地址",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "堆内存空间",
    "source_topic": "如何初始化一个指针数组"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "内置类型变量",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "自定义对象",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "成员函数",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "返回值",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数参数",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "常量",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const int *a",
    "relation": "表示",
    "tail": "指向常整型数的指针",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "int * const a",
    "relation": "表示",
    "tail": "指向整型数的常指针",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "int const a",
    "relation": "表示",
    "tail": "常整型数",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const int a",
    "relation": "表示",
    "tail": "常整型数",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "作用",
    "tail": "传递只读信息",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "作用",
    "tail": "帮助优化器生成更紧凑的代码",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "作用",
    "tail": "防止参数被无意修改",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "解决",
    "tail": "参数被意外修改",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "const",
    "relation": "减少",
    "tail": "bug出现",
    "source_topic": "关键字const是什么含意？"
  },
  {
    "head": "动态特性",
    "relation": "属于",
    "tail": "面向对象语言功能",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "动态特性",
    "relation": "支持",
    "tail": "程序的可扩展性",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "虚函数",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "抽象基类",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "动态绑定",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "虚函数",
    "relation": "实现",
    "tail": "动态绑定",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "抽象基类",
    "relation": "定义",
    "tail": "纯虚函数",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "纯虚函数",
    "relation": "导致",
    "tail": "抽象基类不能实例化",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "纯虚函数",
    "relation": "实现",
    "tail": "接口与实现分离",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "Shape类",
    "relation": "属于",
    "tail": "抽象基类",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "Draw函数",
    "relation": "属于",
    "tail": "Shape类",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "Draw函数",
    "relation": "声明为",
    "tail": "虚函数",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "虚函数",
    "relation": "传递",
    "tail": "派生类",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "动态特性",
    "relation": "构成",
    "tail": "C++的动态绑定",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "动态特性",
    "relation": "构成",
    "tail": "C++的多态",
    "source_topic": "什么是动态特性?"
  },
  {
    "head": "子类",
    "relation": "建议声明",
    "tail": "virtual",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "virtual",
    "relation": "目的",
    "tail": "代码清晰",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "基类",
    "relation": "包含",
    "tail": "虚函数",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "虚函数",
    "relation": "作用",
    "tail": "实现多态",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "子类",
    "relation": "继承",
    "tail": "基类",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "C++编译器",
    "relation": "使用",
    "tail": "名称修饰规则",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "C语言编译器",
    "relation": "使用",
    "tail": "C语言名称修饰规则",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "C++程序",
    "relation": "导致",
    "tail": "函数名与C语言不同",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "extern \"C\"",
    "relation": "解决",
    "tail": "函数名不一致问题",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "extern \"C\"",
    "relation": "指定",
    "tail": "C语言连接方式",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "C++编译器",
    "relation": "重命名",
    "tail": "函数名为mangled名称",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "C语言编译器",
    "relation": "重命名",
    "tail": "函数名为原始名称",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "名称修饰",
    "relation": "支持",
    "tail": "函数重载",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "extern \"C\"",
    "relation": "阻止",
    "tail": "名称修饰",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "C++程序",
    "relation": "调用",
    "tail": "C语言编译的函数",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "链接阶段",
    "relation": "需要",
    "tail": "函数名一致",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "extern \"C\"",
    "relation": "确保",
    "tail": "函数名与C语言一致",
    "source_topic": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？"
  },
  {
    "head": "C语言",
    "relation": "不包含",
    "tail": "系统自带的bool类型",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "宏定义",
    "relation": "属于",
    "tail": "C语言",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "宏定义",
    "relation": "实现方式",
    "tail": "定义False和True的值",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "数值定义",
    "relation": "属于",
    "tail": "宏定义",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "数值定义",
    "relation": "定义",
    "tail": "False为0",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "数值定义",
    "relation": "定义",
    "tail": "True为1",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "逻辑判断定义",
    "relation": "属于",
    "tail": "宏定义",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "逻辑判断定义",
    "relation": "定义",
    "tail": "False为(1!=1)",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "逻辑判断定义",
    "relation": "定义",
    "tail": "True为(1==1)",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "枚举定义",
    "relation": "属于",
    "tail": "C语言",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "枚举定义",
    "relation": "实现方式",
    "tail": "定义类型BOOL",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "枚举定义",
    "relation": "定义",
    "tail": "False为枚举值0",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "枚举定义",
    "relation": "定义",
    "tail": "True为枚举值1",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "BOOL",
    "relation": "由",
    "tail": "枚举定义",
    "source_topic": "如何定义Bool变量的TRUE和FALSE的值。"
  },
  {
    "head": "宏定义",
    "relation": "不进行",
    "tail": "类型判断",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "内联函数",
    "relation": "进行",
    "tail": "参数类型判断",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "宏定义",
    "relation": "无法强制转换",
    "tail": "返回值类型",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "内联函数",
    "relation": "可以强制转换",
    "tail": "返回值类型",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "内联函数",
    "relation": "基于",
    "tail": "编译时替换",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "宏定义",
    "relation": "基于",
    "tail": "文本替换",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "ICMP",
    "relation": "属于",
    "tail": "网络层",
    "source_topic": "ICMP是什么协议,处于哪一层?"
  },
  {
    "head": "ICMP",
    "relation": "分类",
    "tail": "IP层协议",
    "source_topic": "ICMP是什么协议,处于哪一层?"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "隐藏",
    "source_topic": "C中static有什么作用"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "保持变量内容的持久",
    "source_topic": "C中static有什么作用"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "默认初始化为0",
    "source_topic": "C中static有什么作用"
  },
  {
    "head": "static变量",
    "relation": "存储位置",
    "tail": "静态数据区",
    "source_topic": "C中static有什么作用"
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "静态数据区",
    "source_topic": "C中static有什么作用"
  },
  {
    "head": "static",
    "relation": "解决",
    "tail": "命名冲突",
    "source_topic": "C中static有什么作用"
  },
  {
    "head": "静态数据区",
    "relation": "默认值",
    "tail": "0×00",
    "source_topic": "C中static有什么作用"
  },
  {
    "head": "GetMemory2",
    "relation": "分配内存",
    "tail": "malloc",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "调用",
    "tail": "GetMemory2",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "strcpy",
    "relation": "操作",
    "tail": "字符串复制",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "printf",
    "relation": "输出",
    "tail": "字符串内容",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "char *",
    "relation": "指向",
    "tail": "动态分配的内存",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "可能导致",
    "tail": "内存泄漏",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "可能导致",
    "tail": "未初始化内存访问",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "可能导致",
    "tail": "空指针解引用",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "使用",
    "tail": "C语言",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "子类",
    "relation": "继承",
    "tail": "父类",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "构造函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "析构函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "拷贝构造函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "operator=函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "友元函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "多态性",
    "relation": "属于",
    "tail": "面向对象程序设计语言基本特征",
    "source_topic": "C++中的什么是多态性? 是如何实现的?"
  },
  {
    "head": "多态性",
    "relation": "实现方式",
    "tail": "派生类",
    "source_topic": "C++中的什么是多态性? 是如何实现的?"
  },
  {
    "head": "多态性",
    "relation": "实现方式",
    "tail": "虚函数",
    "source_topic": "C++中的什么是多态性? 是如何实现的?"
  },
  {
    "head": "基类",
    "relation": "使用",
    "tail": "同样的函数名",
    "source_topic": "C++中的什么是多态性? 是如何实现的?"
  },
  {
    "head": "派生类",
    "relation": "使用",
    "tail": "同样的函数名",
    "source_topic": "C++中的什么是多态性? 是如何实现的?"
  },
  {
    "head": "多态性",
    "relation": "实现方式",
    "tail": "运行时根据类型不同进行操作隔离",
    "source_topic": "C++中的什么是多态性? 是如何实现的?"
  },
  {
    "head": "虚函数",
    "relation": "实现",
    "tail": "多态性",
    "source_topic": "C++中的什么是多态性? 是如何实现的?"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "在函数体内维持变量值不变",
    "source_topic": "关键字static的作用是什么？"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "模块内全局变量的本地访问",
    "source_topic": "关键字static的作用是什么？"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "限制函数在模块内使用",
    "source_topic": "关键字static的作用是什么？"
  },
  {
    "head": "C++",
    "relation": "要求",
    "tail": "包含头文件",
    "source_topic": "define MAX_LEN 500 char arry[MAX_LEN]; cin>>arry; 这段代码有问题吗？若有，请指出并修改；"
  },
  {
    "head": "cin",
    "relation": "依赖",
    "tail": "iostream头文件",
    "source_topic": "define MAX_LEN 500 char arry[MAX_LEN]; cin>>arry; 这段代码有问题吗？若有，请指出并修改；"
  },
  {
    "head": "数组定义",
    "relation": "需要",
    "tail": "头文件包含",
    "source_topic": "define MAX_LEN 500 char arry[MAX_LEN]; cin>>arry; 这段代码有问题吗？若有，请指出并修改；"
  },
  {
    "head": "delete []arry",
    "relation": "释放",
    "tail": "多个同一类型的地址空间",
    "source_topic": "delete []arry 和 delete arry 一样吗？不一样请说明；"
  },
  {
    "head": "delete arry",
    "relation": "释放",
    "tail": "一个某种类型的地址空间",
    "source_topic": "delete []arry 和 delete arry 一样吗？不一样请说明；"
  },
  {
    "head": "volatile",
    "relation": "核心特性",
    "tail": "变量值可能被外部因素改变",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "作用",
    "tail": "防止编译器优化掉变量的重新读取",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "解决",
    "tail": "读取脏数据问题",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "编译器",
    "relation": "优化",
    "tail": "减少存取外部RAM",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile变量",
    "relation": "属于",
    "tail": "C语言",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "使用场景",
    "tail": "并行设备的硬件寄存器",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "嵌入式系统程序员",
    "relation": "需要理解",
    "tail": "volatile",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "for循环",
    "relation": "导致",
    "tail": "多执行逻辑判断",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "for循环",
    "relation": "导致",
    "tail": "打断循环流水线作业",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "for循环",
    "relation": "导致",
    "tail": "编译器无法优化循环",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "for循环",
    "relation": "导致",
    "tail": "降低程序效率",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "包含",
    "tail": "if语句",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "包含",
    "tail": "else语句",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "导致",
    "tail": "程序不简洁",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "解决",
    "tail": "提高循环效率",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "循环效率",
    "relation": "属于",
    "tail": "程序性能优化",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "程序简洁",
    "relation": "属于",
    "tail": "代码可读性",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "volatile",
    "relation": "核心特性",
    "tail": "变量值可能被外部因素改变",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "作用",
    "tail": "防止编译器优化掉变量的重新读取",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "解决",
    "tail": "读取脏数据问题",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "编译器",
    "relation": "优化",
    "tail": "减少存取外部RAM",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "使用场景",
    "tail": "并行设备的硬件寄存器",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "嵌入式系统程序员",
    "relation": "依赖",
    "tail": "volatile变量",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "导致",
    "tail": "系统避免使用寄存器中的备份值",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "volatile",
    "relation": "确保",
    "tail": "每次访问都从内存读取最新值",
    "source_topic": "C语言的volatile的含义是什么。使用时会对编译器有什么暗示。"
  },
  {
    "head": "CString",
    "relation": "不属于",
    "tail": "类型安全类",
    "source_topic": "MFC中CString是类型安全类么？"
  },
  {
    "head": "CString",
    "relation": "支持",
    "tail": "Format成员函数",
    "source_topic": "MFC中CString是类型安全类么？"
  },
  {
    "head": "Format成员函数",
    "relation": "用于",
    "tail": "数据类型转换",
    "source_topic": "MFC中CString是类型安全类么？"
  },
  {
    "head": "内联函数",
    "relation": "实现方式",
    "tail": "编译时替换嵌入",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "内联函数",
    "relation": "适用场景",
    "tail": "代码较少的函数",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "宏定义",
    "relation": "实现方式",
    "tail": "简单替换变量",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "宏定义",
    "relation": "缺陷",
    "tail": "参数不做类型校验",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "内联函数",
    "relation": "区别",
    "tail": "宏定义",
    "source_topic": "内联函数INline和宏定义一起使用的区别。"
  },
  {
    "head": "DB事务处理",
    "relation": "核心特性",
    "tail": "原子性",
    "source_topic": "DB事务处理的四个特性："
  },
  {
    "head": "DB事务处理",
    "relation": "核心特性",
    "tail": "一致性",
    "source_topic": "DB事务处理的四个特性："
  },
  {
    "head": "DB事务处理",
    "relation": "核心特性",
    "tail": "隔离性",
    "source_topic": "DB事务处理的四个特性："
  },
  {
    "head": "DB事务处理",
    "relation": "核心特性",
    "tail": "持久性",
    "source_topic": "DB事务处理的四个特性："
  },
  {
    "head": "char *array[2]",
    "relation": "分类",
    "tail": "存放指针的数组",
    "source_topic": "如何初始化一个指针数组。"
  },
  {
    "head": "char *array[5]",
    "relation": "分类",
    "tail": "存放指针的数组",
    "source_topic": "如何初始化一个指针数组。"
  },
  {
    "head": "参数传递",
    "relation": "分类",
    "tail": "传值",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么"
  },
  {
    "head": "参数传递",
    "relation": "分类",
    "tail": "传指针",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么"
  },
  {
    "head": "参数传递",
    "relation": "分类",
    "tail": "传引用",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么"
  },
  {
    "head": "多态参数传递",
    "relation": "采用",
    "tail": "传引用",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么"
  },
  {
    "head": "多态参数传递",
    "relation": "不采用",
    "tail": "传值",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么"
  },
  {
    "head": "多态参数传递",
    "relation": "不采用",
    "tail": "传指针",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么"
  },
  {
    "head": "BOOL",
    "relation": "与零值比较",
    "tail": "if语句",
    "source_topic": "请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。"
  },
  {
    "head": "float",
    "relation": "与零值比较",
    "tail": "if语句",
    "source_topic": "请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。"
  },
  {
    "head": "指针变量",
    "relation": "与零值比较",
    "tail": "if语句",
    "source_topic": "请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。"
  },
  {
    "head": "零值",
    "relation": "可以是",
    "tail": "0.0",
    "source_topic": "请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。"
  },
  {
    "head": "零值",
    "relation": "可以是",
    "tail": "FALSE",
    "source_topic": "请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。"
  },
  {
    "head": "零值",
    "relation": "可以是",
    "tail": "空指针",
    "source_topic": "请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。"
  },
  {
    "head": "int变量",
    "relation": "与零值比较",
    "tail": "if语句",
    "source_topic": "请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。"
  },
  {
    "head": "子类",
    "relation": "继承",
    "tail": "父类",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "构造函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "析构函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "拷贝构造函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "operator=函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "友元函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "引用",
    "relation": "属于",
    "tail": "计算机编程概念",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "定义为",
    "tail": "目标变量的别名",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "操作方式",
    "tail": "与对变量直接操作效果完全相同",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用声明",
    "relation": "必须",
    "tail": "进行初始化",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用声明",
    "relation": "导致",
    "tail": "目标变量名有两个名称",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "不占",
    "tail": "存储单元",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "不分配",
    "tail": "系统存储单元",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "不能作为",
    "tail": "其他变量名的别名",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "引用",
    "relation": "不能建立",
    "tail": "数组的引用",
    "source_topic": "什么是“引用”？申明和使用“引用”要注意哪些问题？"
  },
  {
    "head": "触发器",
    "relation": "基于",
    "tail": "事件",
    "source_topic": "触发器怎么工作的?"
  },
  {
    "head": "触发器",
    "relation": "触发",
    "tail": "UPDATE",
    "source_topic": "触发器怎么工作的?"
  },
  {
    "head": "触发器",
    "relation": "触发",
    "tail": "INSERT",
    "source_topic": "触发器怎么工作的?"
  },
  {
    "head": "触发器",
    "relation": "触发",
    "tail": "DELETE",
    "source_topic": "触发器怎么工作的?"
  },
  {
    "head": "触发器",
    "relation": "执行",
    "tail": "SQL语句",
    "source_topic": "触发器怎么工作的?"
  },
  {
    "head": "数据库",
    "relation": "自动执行",
    "tail": "触发器",
    "source_topic": "触发器怎么工作的?"
  },
  {
    "head": "C++类",
    "relation": "具备",
    "tail": "封装",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "C++类",
    "relation": "属于",
    "tail": "面向对象设计（OOD）",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "C++类",
    "relation": "属于",
    "tail": "面向对象编程（OOP）",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "面向对象设计（OOD）",
    "relation": "改变",
    "tail": "程序设计模式",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "面向对象设计（OOD）",
    "relation": "改变",
    "tail": "设计思想",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "CSingleLock",
    "relation": "解决",
    "tail": "多个线程对一个数据类的同时访问",
    "source_topic": "CSingleLock是干什么的。"
  },
  {
    "head": "引用",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "C++中引用和指针的区别?"
  },
  {
    "head": "引用",
    "relation": "核心特性",
    "tail": "必须初始化",
    "source_topic": "C++中引用和指针的区别?"
  },
  {
    "head": "引用",
    "relation": "核心特性",
    "tail": "不可为NULL",
    "source_topic": "C++中引用和指针的区别?"
  },
  {
    "head": "引用",
    "relation": "核心特性",
    "tail": "初始化后不可改变",
    "source_topic": "C++中引用和指针的区别?"
  },
  {
    "head": "引用",
    "relation": "底层结构",
    "tail": "指针",
    "source_topic": "C++中引用和指针的区别?"
  },
  {
    "head": "引用",
    "relation": "效率",
    "tail": "指针",
    "source_topic": "C++中引用和指针的区别?"
  },
  {
    "head": "引用",
    "relation": "目的",
    "tail": "最小特权原则",
    "source_topic": "C++中引用和指针的区别?"
  },
  {
    "head": "C++",
    "relation": "定义常量方式",
    "tail": "const关键字",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "#define宏定义",
    "relation": "区别",
    "tail": "无数据类型",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "const关键字",
    "relation": "区别",
    "tail": "有数据类型",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "const关键字",
    "relation": "优势",
    "tail": "静态类型安全检查",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "#define宏定义",
    "relation": "劣势",
    "tail": "字符替换无类型安全检查",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "#define宏定义",
    "relation": "劣势",
    "tail": "边际效应",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "const常量",
    "relation": "支持",
    "tail": "调试",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "#define宏定义",
    "relation": "不支持",
    "tail": "调试",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "值传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "指针传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "引用传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "数据库日志满",
    "relation": "导致",
    "tail": "无法执行写操作",
    "source_topic": "一般数据库若出现日志满了，会出现什么情况，是否还能使用？"
  },
  {
    "head": "数据库日志满",
    "relation": "导致",
    "tail": "只能执行读操作",
    "source_topic": "一般数据库若出现日志满了，会出现什么情况，是否还能使用？"
  },
  {
    "head": "写操作",
    "relation": "需要",
    "tail": "日志记录",
    "source_topic": "一般数据库若出现日志满了，会出现什么情况，是否还能使用？"
  },
  {
    "head": "数据库日志满",
    "relation": "导致",
    "tail": "数据库处于不可用状态",
    "source_topic": "一般数据库若出现日志满了，会出现什么情况，是否还能使用？"
  },
  {
    "head": "C++",
    "relation": "使用",
    "tail": "extern \"C\"",
    "source_topic": "C++里面如何声明constvoidf(void)函数为C程序中的库函数？"
  },
  {
    "head": "extern \"C\"",
    "relation": "解决",
    "tail": "C++与C函数名称不一致问题",
    "source_topic": "C++里面如何声明constvoidf(void)函数为C程序中的库函数？"
  },
  {
    "head": "C++",
    "relation": "不能直接调用",
    "tail": "C程序中的库函数",
    "source_topic": "C++里面如何声明constvoidf(void)函数为C程序中的库函数？"
  },
  {
    "head": "C++类",
    "relation": "默认成员访问权限",
    "tail": "私有",
    "source_topic": "c++中类和c语言中struct的区别（至少两点）"
  },
  {
    "head": "C语言struct",
    "relation": "默认成员访问权限",
    "tail": "共有",
    "source_topic": "c++中类和c语言中struct的区别（至少两点）"
  },
  {
    "head": "C++类",
    "relation": "可以定义",
    "tail": "成员函数",
    "source_topic": "c++中类和c语言中struct的区别（至少两点）"
  },
  {
    "head": "C语言struct",
    "relation": "只能定义",
    "tail": "成员变量",
    "source_topic": "c++中类和c语言中struct的区别（至少两点）"
  },
  {
    "head": "IP组播",
    "relation": "解决",
    "tail": "网络带宽消耗和网络拥挤问题",
    "source_topic": "IP组播有那些好处?"
  },
  {
    "head": "IP组播",
    "relation": "核心特性",
    "tail": "节约网络资源",
    "source_topic": "IP组播有那些好处?"
  },
  {
    "head": "IP组播",
    "relation": "核心特性",
    "tail": "保证服务质量",
    "source_topic": "IP组播有那些好处?"
  },
  {
    "head": "组播",
    "relation": "属于",
    "tail": "网络技术",
    "source_topic": "IP组播有那些好处?"
  },
  {
    "head": "组播",
    "relation": "包含",
    "tail": "单一数据包传输",
    "source_topic": "IP组播有那些好处?"
  },
  {
    "head": "组播",
    "relation": "包含",
    "tail": "多个接收者",
    "source_topic": "IP组播有那些好处?"
  },
  {
    "head": "变量声明",
    "relation": "区别",
    "tail": "变量定义",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量声明",
    "relation": "不分配",
    "tail": "内存空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量定义",
    "relation": "分配",
    "tail": "内存空间",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量声明",
    "relation": "告知",
    "tail": "编译器",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "变量定义",
    "relation": "包含",
    "tail": "变量声明",
    "source_topic": "变量的声明和定义有什么区别？"
  },
  {
    "head": "线程",
    "relation": "提高",
    "tail": "应用程序响应",
    "source_topic": "程序什么时候应该使用线程，什么时候单线程效率高。"
  },
  {
    "head": "并发线程",
    "relation": "用于",
    "tail": "C/S架构的服务器端",
    "source_topic": "程序什么时候应该使用线程，什么时候单线程效率高。"
  },
  {
    "head": "多CPU系统",
    "relation": "使用线程提高",
    "tail": "CPU利用率",
    "source_topic": "程序什么时候应该使用线程，什么时候单线程效率高。"
  },
  {
    "head": "多线程",
    "relation": "改善",
    "tail": "程序结构",
    "source_topic": "程序什么时候应该使用线程，什么时候单线程效率高。"
  },
  {
    "head": "长且复杂的进程",
    "relation": "分解为",
    "tail": "多个线程",
    "source_topic": "程序什么时候应该使用线程，什么时候单线程效率高。"
  },
  {
    "head": "单线程",
    "relation": "适用于",
    "tail": "其他情况",
    "source_topic": "程序什么时候应该使用线程，什么时候单线程效率高。"
  },
  {
    "head": "模板",
    "relation": "属于",
    "tail": "泛型编程",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "泛型编程",
    "relation": "体现",
    "tail": "通用和泛化的思想",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "vector",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "list",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "deque",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "map",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "multimap",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "set",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "multiset",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "sizeof",
    "relation": "计算",
    "tail": "变量或数组在内存中的大小",
    "source_topic": "以下为WindowsNT下的32位C++程序，请计算sizeof的值"
  },
  {
    "head": "Windows NT",
    "relation": "支持",
    "tail": "32位C++程序",
    "source_topic": "以下为WindowsNT下的32位C++程序，请计算sizeof的值"
  },
  {
    "head": "malloc",
    "relation": "分配内存",
    "tail": "void* 指针",
    "source_topic": "以下为WindowsNT下的32位C++程序，请计算sizeof的值"
  },
  {
    "head": "C语言",
    "relation": "支持",
    "tail": "操作符重载",
    "source_topic": "C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？inta=5,b=7,c;c=a+++b;"
  },
  {
    "head": "a+++b",
    "relation": "等价于",
    "tail": "a++ + b",
    "source_topic": "C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？inta=5,b=7,c;c=a+++b;"
  },
  {
    "head": "a++",
    "relation": "操作",
    "tail": "自增运算",
    "source_topic": "C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？inta=5,b=7,c;c=a+++b;"
  },
  {
    "head": "自增运算",
    "relation": "改变",
    "tail": "变量a的值",
    "source_topic": "C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？inta=5,b=7,c;c=a+++b;"
  },
  {
    "head": "编译器",
    "relation": "处理",
    "tail": "合法语法结构",
    "source_topic": "C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？inta=5,b=7,c;c=a+++b;"
  },
  {
    "head": "代码可读性",
    "relation": "影响",
    "tail": "编程风格",
    "source_topic": "C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？inta=5,b=7,c;c=a+++b;"
  },
  {
    "head": "代码可修改性",
    "relation": "影响",
    "tail": "编程风格",
    "source_topic": "C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？inta=5,b=7,c;c=a+++b;"
  },
  {
    "head": "extern\"C\"",
    "relation": "解决",
    "tail": "C++名称修饰问题",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？"
  },
  {
    "head": "extern",
    "relation": "属于",
    "tail": "C/C++语言关键字",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？"
  },
  {
    "head": "extern\"C\"",
    "relation": "用于",
    "tail": "调用被C编译器编译后的函数",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？"
  },
  {
    "head": "内存分配方式",
    "relation": "分类",
    "tail": "静态存储区域分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "内存分配方式",
    "relation": "分类",
    "tail": "栈上分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "内存分配方式",
    "relation": "分类",
    "tail": "堆上分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "程序编译时分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "内存在整个运行期间存在",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "示例",
    "tail": "全局变量",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "函数执行时分配局部变量存储单元",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "函数执行结束时自动释放内存",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "内存分配效率高",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "分配的内存容量有限",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "程序运行时动态申请内存",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "程序员手动释放内存",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存生存期由程序员决定",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "使用灵活",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "问题",
    "tail": "内存管理复杂",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "函数重载",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "函数重载",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "C++编译器",
    "relation": "产生",
    "tail": "带类型修饰的函数名",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "C编译器",
    "relation": "生成",
    "tail": "无类型修饰的函数名",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "extern \"C\"",
    "relation": "解决",
    "tail": "函数名匹配问题",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "extern \"C\"",
    "relation": "指定",
    "tail": "C连接符号",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "局部变量",
    "relation": "延长生命期",
    "tail": "static修饰符",
    "source_topic": "如何让局部变量具有全局生命期。"
  },
  {
    "head": "static修饰符",
    "relation": "作用范围",
    "tail": "局部变量作用域未扩大",
    "source_topic": "如何让局部变量具有全局生命期。"
  },
  {
    "head": "全局生命期",
    "relation": "实现方式",
    "tail": "static修饰符",
    "source_topic": "如何让局部变量具有全局生命期。"
  },
  {
    "head": "静态区变量",
    "relation": "生命期",
    "tail": "全局生命期",
    "source_topic": "如何让局部变量具有全局生命期。"
  },
  {
    "head": "静态区变量",
    "relation": "定义位置",
    "tail": "函数体外",
    "source_topic": "如何让局部变量具有全局生命期。"
  },
  {
    "head": "C++程序",
    "relation": "调用需求",
    "tail": "C编译器编译后的函数",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "C++编译器",
    "relation": "处理方式",
    "tail": "符号库中的名字不同",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "C语言函数",
    "relation": "连接方式",
    "tail": "C连接方式",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "extern\"C\"",
    "relation": "作用",
    "tail": "解决C++程序调用C函数的问题",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "extern\"C\"",
    "relation": "指定方式",
    "tail": "C连接交换",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "strtok",
    "relation": "要求",
    "tail": "被分割的字符串不能是常量",
    "source_topic": "strtok函数在使用上要注意什么问题。"
  },
  {
    "head": "strtok",
    "relation": "要求",
    "tail": "分隔符不能是常量",
    "source_topic": "strtok函数在使用上要注意什么问题。"
  },
  {
    "head": "strtok",
    "relation": "使用方式",
    "tail": "第一次调用时传入字符串指针",
    "source_topic": "strtok函数在使用上要注意什么问题。"
  },
  {
    "head": "strtok",
    "relation": "使用方式",
    "tail": "后续调用时传入NULL",
    "source_topic": "strtok函数在使用上要注意什么问题。"
  },
  {
    "head": "strtok",
    "relation": "注意事项",
    "tail": "避免丢失指针导致分割混乱",
    "source_topic": "strtok函数在使用上要注意什么问题。"
  },
  {
    "head": "define",
    "relation": "属于",
    "tail": "预处理器指令",
    "source_topic": "define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这想看到几件事情："
  },
  {
    "head": "define",
    "relation": "使用规则",
    "tail": "不能以分号结束",
    "source_topic": "define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这想看到几件事情："
  },
  {
    "head": "define",
    "relation": "使用规则",
    "tail": "括号的使用",
    "source_topic": "define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这想看到几件事情："
  },
  {
    "head": "预处理器",
    "relation": "功能",
    "tail": "计算常数表达式的值",
    "source_topic": "define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这想看到几件事情："
  },
  {
    "head": "整型数溢出",
    "relation": "导致",
    "tail": "16位机的整型数溢出",
    "source_topic": "define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这想看到几件事情："
  },
  {
    "head": "长整型符号L",
    "relation": "解决",
    "tail": "整型数溢出",
    "source_topic": "define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这想看到几件事情："
  },
  {
    "head": "UL",
    "relation": "表示",
    "tail": "无符号长整型",
    "source_topic": "define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这想看到几件事情："
  },
  {
    "head": "C语言",
    "relation": "内存分配方式",
    "tail": "静态存储区域分配",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "C++语言",
    "relation": "内存分配方式",
    "tail": "静态存储区域分配",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "在程序编译时分配内存",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "内存在整个程序运行期间都存在",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "全局变量",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "static变量",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "C语言",
    "relation": "内存分配方式",
    "tail": "栈上创建",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "C++语言",
    "relation": "内存分配方式",
    "tail": "栈上创建",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "栈上创建",
    "relation": "特点",
    "tail": "函数执行时分配局部变量存储单元",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "栈上创建",
    "relation": "特点",
    "tail": "函数执行结束时自动释放内存",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "栈上创建",
    "relation": "特点",
    "tail": "内存分配效率高",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "栈上创建",
    "relation": "特点",
    "tail": "内存容量有限",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "C语言",
    "relation": "内存分配方式",
    "tail": "堆上分配",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "C++语言",
    "relation": "内存分配方式",
    "tail": "堆上分配",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "堆上分配",
    "relation": "实现方式",
    "tail": "malloc",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "堆上分配",
    "relation": "实现方式",
    "tail": "new",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "堆上分配",
    "relation": "释放方式",
    "tail": "free",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "堆上分配",
    "relation": "释放方式",
    "tail": "delete",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存分配灵活",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存生存期由程序员控制",
    "source_topic": "说一说C与C++的内存分配方式?"
  },
  {
    "head": "MVC模式",
    "relation": "属于",
    "tail": "观察者模式",
    "source_topic": "你如何理解MVC。简单举例来说明其应用。"
  },
  {
    "head": "MVC模式",
    "relation": "典型应用",
    "tail": "MFC文档视图架构",
    "source_topic": "你如何理解MVC。简单举例来说明其应用。"
  },
  {
    "head": "C++程序",
    "relation": "调用",
    "tail": "被C编译器编译后的函数",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "extern\"C\"",
    "relation": "解决",
    "tail": "编译器不同导致的符号名称差异",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "C++编译器",
    "relation": "不同",
    "tail": "C编译器",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "符号名称差异",
    "relation": "导致",
    "tail": "无法正确调用函数",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明？"
  },
  {
    "head": "重载",
    "relation": "属于",
    "tail": "函数多态性",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "属于",
    "tail": "函数多态性",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "定义",
    "tail": "子类重新定义父类虚函数的方法",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "实现原理",
    "tail": "父类指针动态调用子类虚函数",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "C语言",
    "relation": "定义",
    "tail": "结构体",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++",
    "relation": "定义",
    "tail": "struct",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++",
    "relation": "定义",
    "tail": "class",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C语言的结构体",
    "relation": "功能",
    "tail": "数据的结合",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++的struct",
    "relation": "功能",
    "tail": "数据的结合",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++的class",
    "relation": "功能",
    "tail": "数据的结合",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++的struct",
    "relation": "与",
    "tail": "C++的class",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++的struct",
    "relation": "默认访问属性",
    "tail": "public",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++的class",
    "relation": "默认访问属性",
    "tail": "private",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "#include",
    "relation": "搜索路径",
    "tail": "标准库路径",
    "source_topic": "include和#include\"a.h\"有什么区别?"
  },
  {
    "head": "#include\"a.h\"",
    "relation": "搜索路径",
    "tail": "用户的工作路径",
    "source_topic": "include和#include\"a.h\"有什么区别?"
  },
  {
    "head": "#include",
    "relation": "包含",
    "tail": "开发环境提供的库头文件",
    "source_topic": "＃include和＃include“filename.h”有什么区别？"
  },
  {
    "head": "for循环",
    "relation": "导致",
    "tail": "多执行逻辑判断",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "for循环",
    "relation": "打断",
    "tail": "循环流水线作业",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "循环流水线作业",
    "relation": "导致",
    "tail": "编译器无法优化循环",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "循环结构",
    "relation": "影响",
    "tail": "程序效率",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "包含",
    "tail": "if语句",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "包含",
    "tail": "else语句",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "导致",
    "tail": "逻辑判断次数增加",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "条件判断",
    "relation": "影响",
    "tail": "循环效率",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "for循环",
    "relation": "属于",
    "tail": "程序结构",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "程序结构",
    "relation": "影响",
    "tail": "代码简洁性",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "for循环",
    "relation": "影响",
    "tail": "代码可读性",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "delete[] arry",
    "relation": "释放",
    "tail": "多个同一类型的地址空间",
    "source_topic": "delete[]arry和deletearry一样吗？不一样请说明；"
  },
  {
    "head": "delete arry",
    "relation": "释放",
    "tail": "一个某种类型的地址空间",
    "source_topic": "delete[]arry和deletearry一样吗？不一样请说明；"
  },
  {
    "head": "OOP项目",
    "relation": "体现",
    "tail": "虚函数",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "虚函数",
    "relation": "属于",
    "tail": "C++语言特性",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "UML",
    "relation": "用于描述",
    "tail": "OOP项目",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "UML",
    "relation": "包含",
    "tail": "类图",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "UML",
    "relation": "包含",
    "tail": "继承关系",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "UML",
    "relation": "包含",
    "tail": "多态关系",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "类图",
    "relation": "展示",
    "tail": "对象之间的关系",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "继承关系",
    "relation": "实现",
    "tail": "基类与派生类",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "多态关系",
    "relation": "实现",
    "tail": "虚函数调用",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "虚函数",
    "relation": "支持",
    "tail": "运行时多态",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "OOP项目",
    "relation": "设计原则",
    "tail": "封装",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "OOP项目",
    "relation": "设计原则",
    "tail": "抽象",
    "source_topic": "结合1个你认为比较能体现OOP思想的项目，用UML来描述。"
  },
  {
    "head": "C语言",
    "relation": "定义常量方式",
    "tail": "宏#define",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "C++",
    "relation": "定义常量方式",
    "tail": "const",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "const",
    "relation": "具有",
    "tail": "数据类型",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "宏#define",
    "relation": "缺乏",
    "tail": "数据类型",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "const常量",
    "relation": "支持",
    "tail": "静态类型安全检查",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "宏常量",
    "relation": "缺乏",
    "tail": "静态类型安全检查",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "宏#define",
    "relation": "可能导致",
    "tail": "边际效应",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "const常量",
    "relation": "支持",
    "tail": "调试",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "宏常量",
    "relation": "不支持",
    "tail": "调试",
    "source_topic": "C与C++各自是如何定义常量的?有什么不同?"
  },
  {
    "head": "模板类",
    "relation": "核心特性",
    "tail": "类型无关",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "模板类",
    "relation": "核心特性",
    "tail": "可复用性",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "模板类",
    "relation": "核心特性",
    "tail": "编译时检查数据类型",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "模板类",
    "relation": "核心特性",
    "tail": "类型安全",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "模板类",
    "relation": "核心特性",
    "tail": "平台无关",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "模板类",
    "relation": "核心特性",
    "tail": "可移植性",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "模板类",
    "relation": "适用场景",
    "tail": "动态增长和减小的数据结构",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "模板类",
    "relation": "适用场景",
    "tail": "基本数据类型",
    "source_topic": "C++中为什么用模板类。"
  },
  {
    "head": "动态连接库",
    "relation": "包含",
    "tail": "载入时动态链接",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "动态连接库",
    "relation": "包含",
    "tail": "运行时动态链接",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "载入时动态链接",
    "relation": "需要",
    "tail": "导入库",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "导入库",
    "relation": "提供",
    "tail": "DLL载入信息",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "导入库",
    "relation": "提供",
    "tail": "DLL函数定位",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "运行时动态链接",
    "relation": "通过",
    "tail": "LoadLibrary",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "运行时动态链接",
    "relation": "通过",
    "tail": "LoadLibraryEx",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "运行时动态链接",
    "relation": "使用",
    "tail": "GetProcAddress",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "GetProcAddress",
    "relation": "获取",
    "tail": "DLL函数出口地址",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "运行时动态链接",
    "relation": "避免",
    "tail": "导入库文件",
    "source_topic": "动态连接库的两种方式?"
  },
  {
    "head": "常引用",
    "relation": "使用场景",
    "tail": "保护传递给函数的数据不被修改",
    "source_topic": "在什么时候需要使用“常引用”？"
  },
  {
    "head": "常引用",
    "relation": "使用场景",
    "tail": "利用引用提高程序效率",
    "source_topic": "在什么时候需要使用“常引用”？"
  },
  {
    "head": "GCC3.2.2",
    "relation": "支持",
    "tail": "C++",
    "source_topic": "GCC3.2.2版本中支持哪几种编程语言。"
  },
  {
    "head": "GCC3.2.2",
    "relation": "支持",
    "tail": "Java",
    "source_topic": "GCC3.2.2版本中支持哪几种编程语言。"
  },
  {
    "head": "GCC3.2.2",
    "relation": "支持",
    "tail": "Obj-C",
    "source_topic": "GCC3.2.2版本中支持哪几种编程语言。"
  },
  {
    "head": "GCC3.2.2",
    "relation": "支持",
    "tail": "Ada",
    "source_topic": "GCC3.2.2版本中支持哪几种编程语言。"
  },
  {
    "head": "GCC3.2.2",
    "relation": "支持",
    "tail": "Fortran",
    "source_topic": "GCC3.2.2版本中支持哪几种编程语言。"
  },
  {
    "head": "GCC3.2.2",
    "relation": "支持",
    "tail": "Pascal",
    "source_topic": "GCC3.2.2版本中支持哪几种编程语言。"
  },
  {
    "head": "GCC3.2.2",
    "relation": "支持",
    "tail": "Modula-3",
    "source_topic": "GCC3.2.2版本中支持哪几种编程语言。"
  },
  {
    "head": "strcpy",
    "relation": "实现方式",
    "tail": "字符逐个复制",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "strcpy",
    "relation": "参数",
    "tail": "strDest",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "strcpy",
    "relation": "参数",
    "tail": "strSrc",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "strDest",
    "relation": "类型",
    "tail": "char*",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "strSrc",
    "relation": "类型",
    "tail": "const char*",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "GetMemory",
    "relation": "返回值",
    "tail": "char数组",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "Test",
    "relation": "导致",
    "tail": "乱码",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "char数组",
    "relation": "作用域",
    "tail": "局部变量",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "局部变量",
    "relation": "生命周期",
    "tail": "函数执行期间",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "返回局部变量地址",
    "relation": "导致",
    "tail": "未定义行为",
    "source_topic": "已知strcpy的函数原型：charstrcpy(charstrDest,constchar*strSrc)其中strDest是目的字符串，strSrc是源字符串。不调用C++/C的字符串库函数，请编写函数strcpy。"
  },
  {
    "head": "重载",
    "relation": "属于",
    "tail": "函数多态性",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "属于",
    "tail": "函数多态性",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "定义",
    "tail": "子类重新定义父类虚函数的方法",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "重写",
    "relation": "实现原理",
    "tail": "父类指针动态调用子类虚函数",
    "source_topic": "重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"
  },
  {
    "head": "多重继承",
    "relation": "解决",
    "tail": "向上继承的二义性",
    "source_topic": "多重继承如何消除向上继承的二义性。"
  },
  {
    "head": "虚拟继承",
    "relation": "用于",
    "tail": "消除向上继承的二义性",
    "source_topic": "多重继承如何消除向上继承的二义性。"
  },
  {
    "head": "多表操作",
    "relation": "解决",
    "tail": "事务",
    "source_topic": "对数据库的一张表进行操作,同时要对另一张表进行操作,如何实现?"
  },
  {
    "head": "头文件",
    "relation": "作用",
    "tail": "调用库功能",
    "source_topic": "头文件的作用是什么?"
  },
  {
    "head": "头文件",
    "relation": "作用",
    "tail": "加强类型安全检查",
    "source_topic": "头文件的作用是什么?"
  },
  {
    "head": "GetMemory",
    "relation": "导致",
    "tail": "未初始化指针",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "访问非法内存",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "未初始化指针",
    "relation": "导致",
    "tail": "程序崩溃",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "包含",
    "tail": "GetMemory",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "包含",
    "tail": "strcpy",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "Test",
    "relation": "包含",
    "tail": "printf",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C语言内存分配函数",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "char*",
    "relation": "指向",
    "tail": "字符数组",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "NULL",
    "relation": "表示",
    "tail": "空指针",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "delete[] arry",
    "relation": "释放",
    "tail": "多个同一类型的地址空间",
    "source_topic": "delete[]arry和deletearry一样吗？不一样请说明；"
  },
  {
    "head": "delete arry",
    "relation": "释放",
    "tail": "一个某种类型的地址空间",
    "source_topic": "delete[]arry和deletearry一样吗？不一样请说明；"
  },
  {
    "head": "GetMemory",
    "relation": "导致",
    "tail": "指针未正确赋值",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "未定义行为",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "printf",
    "relation": "可能导致",
    "tail": "输出hello",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "malloc",
    "relation": "返回",
    "tail": "指向分配内存的指针",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "char* str",
    "relation": "初始化",
    "tail": "NULL",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "GetMemory",
    "relation": "参数",
    "tail": "&str",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "strcpy",
    "relation": "参数",
    "tail": "str",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "printf",
    "relation": "参数",
    "tail": "str",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "第一个for循环",
    "relation": "优点",
    "tail": "条件判断只发生在一个循环中",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "第二个for循环",
    "relation": "优点",
    "tail": "条件判断只发生在一个循环中",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "第一个for循环",
    "relation": "缺点",
    "tail": "每次循环都需要进行条件判断",
    "source_topic": "请简述以下两个for循环的优缺点"
  },
  {
    "head": "构造函数",
    "relation": "不能为",
    "tail": "虚函数",
    "source_topic": "构造函数可否是虚汗数，为什么？析构函数呢，可否是纯虚的呢？"
  },
  {
    "head": "析构函数",
    "relation": "可以为",
    "tail": "纯虚函数",
    "source_topic": "构造函数可否是虚汗数，为什么？析构函数呢，可否是纯虚的呢？"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "函数重载",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "函数重载",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "C++编译器",
    "relation": "产生",
    "tail": "带类型修饰的函数名",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "C编译器",
    "relation": "生成",
    "tail": "无类型修饰的函数名",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "extern \"C\"",
    "relation": "解决",
    "tail": "函数名匹配问题",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "extern \"C\"",
    "relation": "指定",
    "tail": "C连接符号",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern\"C\"?"
  },
  {
    "head": "sizeof(a)",
    "relation": "等于",
    "tail": "30",
    "source_topic": "请写出下面代码在32位平台上的运行结果，并说明sizeof的性质："
  },
  {
    "head": "char b",
    "relation": "表示",
    "tail": "一个字符型指针",
    "source_topic": "请写出下面代码在32位平台上的运行结果，并说明sizeof的性质："
  },
  {
    "head": "malloc",
    "relation": "用于",
    "tail": "动态分配内存",
    "source_topic": "请写出下面代码在32位平台上的运行结果，并说明sizeof的性质："
  },
  {
    "head": "sizeof",
    "relation": "返回",
    "tail": "变量或类型所占内存字节数",
    "source_topic": "请写出下面代码在32位平台上的运行结果，并说明sizeof的性质："
  },
  {
    "head": "32位平台",
    "relation": "指针长度为",
    "tail": "32位",
    "source_topic": "请写出下面代码在32位平台上的运行结果，并说明sizeof的性质："
  },
  {
    "head": "char",
    "relation": "占用内存大小为",
    "tail": "1字节",
    "source_topic": "请写出下面代码在32位平台上的运行结果，并说明sizeof的性质："
  },
  {
    "head": "指针",
    "relation": "占用内存大小为",
    "tail": "4字节",
    "source_topic": "请写出下面代码在32位平台上的运行结果，并说明sizeof的性质："
  },
  {
    "head": "信号量",
    "relation": "属于",
    "tail": "低级通信",
    "source_topic": "高级通信包括信号量，——-，——–"
  },
  {
    "head": "管道",
    "relation": "属于",
    "tail": "高级通信",
    "source_topic": "高级通信包括信号量，——-，——–"
  },
  {
    "head": "消息队列",
    "relation": "属于",
    "tail": "高级通信",
    "source_topic": "高级通信包括信号量，——-，——–"
  },
  {
    "head": "共享存储区通信",
    "relation": "属于",
    "tail": "高级通信",
    "source_topic": "高级通信包括信号量，——-，——–"
  },
  {
    "head": "关联",
    "relation": "属于",
    "tail": "UML概念",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "聚合",
    "relation": "属于",
    "tail": "UML概念",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "组合",
    "relation": "属于",
    "tail": "UML概念",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "关联",
    "relation": "表示",
    "tail": "两个类的一般性联系",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "聚合",
    "relation": "表示",
    "tail": "has-a的关系",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "聚合",
    "relation": "具有",
    "tail": "相对松散的关系",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "聚合",
    "relation": "不负责",
    "tail": "被聚合类",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "组合",
    "relation": "表示",
    "tail": "contains-a的关系",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "组合",
    "relation": "具有",
    "tail": "强关联性",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "组合类",
    "relation": "负责",
    "tail": "被组合类",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "组合类",
    "relation": "具有相同生命周期",
    "tail": "被组合类",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "聚合关系",
    "relation": "用符号表示",
    "tail": "空菱形",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "组合关系",
    "relation": "用符号表示",
    "tail": "实心菱形",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "聚合",
    "relation": "实现形式",
    "tail": "classB{A*a;……}",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "组合",
    "relation": "实现形式",
    "tail": "classB{Aa;…}",
    "source_topic": "关联、聚合(Aggregation)以及组合(Composition)的区别？"
  },
  {
    "head": "嵌入式系统",
    "relation": "可能导致",
    "tail": "内存碎片",
    "source_topic": "尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？"
  },
  {
    "head": "嵌入式系统",
    "relation": "存在",
    "tail": "碎片收集的问题",
    "source_topic": "尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？"
  },
  {
    "head": "动态内存分配",
    "relation": "涉及",
    "tail": "变量的生命周期",
    "source_topic": "尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？"
  },
  {
    "head": "malloc",
    "relation": "返回",
    "tail": "合法指针",
    "source_topic": "尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？"
  },
  {
    "head": "指针",
    "relation": "可能被分配",
    "tail": "零字节内存",
    "source_topic": "尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "未定义行为",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "free",
    "relation": "释放",
    "tail": "str",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "str",
    "relation": "指向",
    "tail": "已释放的内存",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "if(str != NULL)",
    "relation": "可能导致",
    "tail": "访问已释放的内存",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "访问已释放的内存",
    "relation": "导致",
    "tail": "未定义行为",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "未定义行为",
    "relation": "可能表现",
    "tail": "输出world",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "未定义行为",
    "relation": "可能表现",
    "tail": "程序崩溃",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "未定义行为",
    "relation": "可能表现",
    "tail": "数据损坏",
    "source_topic": "请问运行Test函数会有什么样的结果？"
  },
  {
    "head": "const_cast",
    "relation": "用途",
    "tail": "去除变量的const属性",
    "source_topic": "Cpp四种强制类型转换"
  },
  {
    "head": "static_cast",
    "relation": "用途",
    "tail": "基本类型间的转换",
    "source_topic": "Cpp四种强制类型转换"
  },
  {
    "head": "dynamic_cast",
    "relation": "用途",
    "tail": "多态之间的类型转换",
    "source_topic": "Cpp四种强制类型转换"
  },
  {
    "head": "static成员",
    "relation": "核心特性",
    "tail": "只有一份拷贝",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员",
    "relation": "核心特性",
    "tail": "被该类的所有对象所共享",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员",
    "relation": "初始化方式",
    "tail": "只能在类外初始化",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员",
    "relation": "存储位置",
    "tail": "全局（静态）存储区",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员",
    "relation": "内存计算",
    "tail": "不计入类的大小",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员",
    "relation": "访问方式",
    "tail": "通过类名直接访问",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员",
    "relation": "访问方式",
    "tail": "通过对象访问",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员函数",
    "relation": "访问限制",
    "tail": "只能访问static成员变量",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员函数",
    "relation": "特性",
    "tail": "没有this指针",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "static成员函数",
    "relation": "归属",
    "tail": "不属于任何对象",
    "source_topic": "类的static成员的特点"
  },
  {
    "head": "引用",
    "relation": "只能在定义的时候初始化",
    "tail": "指针",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "引用",
    "relation": "值不能改变不能为空",
    "tail": "指针",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "指针",
    "relation": "可以在任何时候赋值",
    "tail": "引用",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "指针",
    "relation": "可以为nullptr",
    "tail": "引用",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "sizeof引用",
    "relation": "返回",
    "tail": "引用对象的大小",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "sizeof指针",
    "relation": "返回",
    "tail": "指针本身的大小",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "对引用取地址",
    "relation": "得到",
    "tail": "引用对象的地址",
    "source_topic": "指针和引用的区别"
  },
  {
    "head": "Cpp内存",
    "relation": "包含",
    "tail": "栈区",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "Cpp内存",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "Cpp内存",
    "relation": "包含",
    "tail": "全局区",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "Cpp内存",
    "relation": "包含",
    "tail": "文字常量区",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "Cpp内存",
    "relation": "包含",
    "tail": "程序代码区",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "栈区",
    "relation": "由编译器自动分配释放",
    "tail": "Cpp内存",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "堆区",
    "relation": "由程序员分配释放",
    "tail": "Cpp内存",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "全局变量",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "静态变量",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "文字常量区",
    "relation": "存储",
    "tail": "常量字符串",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "程序代码区",
    "relation": "存储",
    "tail": "函数体的二进制代码",
    "source_topic": "谈谈对Cpp内存的理解"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C/C++标准库函数",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C/C++标准库函数",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "new",
    "relation": "功能",
    "tail": "动态内存分配和初始化",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "delete",
    "relation": "功能",
    "tail": "清理与释放内存",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "malloc",
    "relation": "功能",
    "tail": "动态内存分配",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "free",
    "relation": "功能",
    "tail": "释放内存",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "new/delete",
    "relation": "区别",
    "tail": "不是库函数",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "malloc/free",
    "relation": "区别",
    "tail": "是库函数",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "new",
    "relation": "适用对象",
    "tail": "非内部数据类型的对象",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "delete",
    "relation": "适用对象",
    "tail": "非内部数据类型的对象",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "构造函数",
    "relation": "执行时机",
    "tail": "对象创建时",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "析构函数",
    "relation": "执行时机",
    "tail": "对象消亡前",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "new",
    "relation": "执行任务",
    "tail": "调用构造函数",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "delete",
    "relation": "执行任务",
    "tail": "调用析构函数",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "malloc/free",
    "relation": "限制",
    "tail": "无法执行构造函数和析构函数",
    "source_topic": "谈谈new、delete、malloc、free"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "类的成员变量",
    "source_topic": "const关键字"
  },
  {
    "head": "const",
    "relation": "表示",
    "tail": "成员常量",
    "source_topic": "const关键字"
  },
  {
    "head": "const",
    "relation": "限制",
    "tail": "成员变量不能被修改",
    "source_topic": "const关键字"
  },
  {
    "head": "const",
    "relation": "构成",
    "tail": "函数重载",
    "source_topic": "const关键字"
  },
  {
    "head": "const 对象",
    "relation": "只能调用",
    "tail": "const 函数",
    "source_topic": "const关键字"
  },
  {
    "head": "非 const 对象",
    "relation": "优先调用",
    "tail": "非 const 函数",
    "source_topic": "const关键字"
  },
  {
    "head": "const",
    "relation": "需要",
    "tail": "定义和声明处都修饰",
    "source_topic": "const关键字"
  },
  {
    "head": "int const *p",
    "relation": "等价于",
    "tail": "const int *p",
    "source_topic": "const关键字"
  },
  {
    "head": "int const *p",
    "relation": "表示",
    "tail": "value是常数",
    "source_topic": "const关键字"
  },
  {
    "head": "int * const p",
    "relation": "表示",
    "tail": "常指针",
    "source_topic": "const关键字"
  },
  {
    "head": "vector",
    "relation": "属于",
    "tail": "动态扩容数组",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "unordered_map",
    "relation": "底层结构",
    "tail": "hash表",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "map",
    "relation": "分类",
    "tail": "key-value数据",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "multimap",
    "relation": "分类",
    "tail": "key-value数据",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "unordered_map",
    "relation": "分类",
    "tail": "key-value数据",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "自动排序去重",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "multimap",
    "relation": "核心特性",
    "tail": "允许重复键",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "unordered_map",
    "relation": "核心特性",
    "tail": "无序存储",
    "source_topic": "知道STL吗，挑两个你最常用的容器说一说"
  },
  {
    "head": "C++编译器",
    "relation": "定义",
    "tail": "__cplusplus",
    "source_topic": "怎么确定一个程序是C编译的还是C++编译的"
  },
  {
    "head": "C编译器",
    "relation": "定义",
    "tail": "_STDC_",
    "source_topic": "怎么确定一个程序是C编译的还是C++编译的"
  },
  {
    "head": "_STDC_",
    "relation": "表示",
    "tail": "ANSI C标准",
    "source_topic": "怎么确定一个程序是C编译的还是C++编译的"
  },
  {
    "head": "C++文件",
    "relation": "被编译",
    "tail": "C++编译器",
    "source_topic": "怎么确定一个程序是C编译的还是C++编译的"
  },
  {
    "head": "C文件",
    "relation": "被编译",
    "tail": "C编译器",
    "source_topic": "怎么确定一个程序是C编译的还是C++编译的"
  },
  {
    "head": "预处理",
    "relation": "产生",
    "tail": "ii文件",
    "source_topic": "一个文件从源码到可执行文件所经历的过程"
  },
  {
    "head": "编译",
    "relation": "产生",
    "tail": "汇编文件",
    "source_topic": "一个文件从源码到可执行文件所经历的过程"
  },
  {
    "head": "汇编",
    "relation": "产生",
    "tail": "目标文件",
    "source_topic": "一个文件从源码到可执行文件所经历的过程"
  },
  {
    "head": "链接",
    "relation": "产生",
    "tail": "可执行文件",
    "source_topic": "一个文件从源码到可执行文件所经历的过程"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "auto",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "nullptr",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "for循环新语法",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "std::array",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "std::thread",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "std::atomic",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "std::shared_ptr",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "C++",
    "relation": "引入",
    "tail": "std::weak_ptr",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "std::function",
    "relation": "属于",
    "tail": "C++新特性",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "std::bind",
    "relation": "属于",
    "tail": "C++新特性",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "lambda表达式",
    "relation": "属于",
    "tail": "C++新特性",
    "source_topic": "了解C++新特性吗"
  },
  {
    "head": "纯虚函数",
    "relation": "属于",
    "tail": "抽象类",
    "source_topic": "什么是纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "定义方式",
    "tail": "只声明不定义",
    "source_topic": "什么是纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "使用方式",
    "tail": "在派生类中重写",
    "source_topic": "什么是纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "特性",
    "tail": "不能实例化出对象",
    "source_topic": "什么是纯虚函数"
  },
  {
    "head": "构造函数",
    "relation": "不可以为",
    "tail": "虚函数",
    "source_topic": "构造函数和析构函数可以为虚函数吗"
  },
  {
    "head": "析构函数",
    "relation": "可以为",
    "tail": "虚函数",
    "source_topic": "构造函数和析构函数可以为虚函数吗"
  },
  {
    "head": "析构函数",
    "relation": "有时候必须声明为",
    "tail": "虚函数",
    "source_topic": "构造函数和析构函数可以为虚函数吗"
  },
  {
    "head": "#include",
    "relation": "查找顺序",
    "tail": "系统默认的头文件目录",
    "source_topic": "头文件<>和\"\"的区别"
  },
  {
    "head": "#include",
    "relation": "性能影响",
    "tail": "更快查找系统提供的库函数",
    "source_topic": "头文件<>和\"\"的区别"
  },
  {
    "head": "MyString",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "包含",
    "tail": "拷贝构造函数",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "包含",
    "tail": "赋值操作符重载",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "包含",
    "tail": "析构函数",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "构造函数",
    "relation": "实现",
    "tail": "动态内存分配",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "构造函数",
    "relation": "处理",
    "tail": "默认初始化",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "构造函数",
    "relation": "处理",
    "tail": "字符串初始化",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "实现",
    "tail": "深拷贝",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "拷贝构造函数",
    "relation": "处理",
    "tail": "复制字符串内容",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "赋值操作符重载",
    "relation": "实现",
    "tail": "避免自赋值",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "赋值操作符重载",
    "relation": "处理",
    "tail": "释放原有内存",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "赋值操作符重载",
    "relation": "处理",
    "tail": "分配新内存",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "赋值操作符重载",
    "relation": "处理",
    "tail": "复制字符串内容",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "析构函数",
    "relation": "处理",
    "tail": "释放动态内存",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "使用",
    "tail": "char指针",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "依赖",
    "tail": "new操作符",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "依赖",
    "tail": "delete操作符",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "依赖",
    "tail": "strcpy函数",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "MyString",
    "relation": "依赖",
    "tail": "strlen函数",
    "source_topic": "编写string的构造函数、拷贝构造函数、赋值操作符重载和析构函数"
  },
  {
    "head": "Linux进程",
    "relation": "支持",
    "tail": "管道",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux进程",
    "relation": "支持",
    "tail": "有名管道",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux进程",
    "relation": "支持",
    "tail": "信号",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux进程",
    "relation": "支持",
    "tail": "信号量",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux进程",
    "relation": "支持",
    "tail": "共享内存",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux进程",
    "relation": "支持",
    "tail": "消息队列",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux进程",
    "relation": "支持",
    "tail": "套接字",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux线程",
    "relation": "支持",
    "tail": "互斥体",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux线程",
    "relation": "支持",
    "tail": "信号量",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Linux线程",
    "relation": "支持",
    "tail": "条件变量",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows进程",
    "relation": "支持",
    "tail": "管道",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows进程",
    "relation": "支持",
    "tail": "共享内存",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows进程",
    "relation": "支持",
    "tail": "消息队列",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows进程",
    "relation": "支持",
    "tail": "信号量",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows进程",
    "relation": "支持",
    "tail": "套接字",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows线程",
    "relation": "支持",
    "tail": "临界区",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows线程",
    "relation": "支持",
    "tail": "互斥量",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows线程",
    "relation": "支持",
    "tail": "信号量",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "Windows线程",
    "relation": "支持",
    "tail": "事件",
    "source_topic": "进程和线程间的通信方式"
  },
  {
    "head": "死锁",
    "relation": "导致",
    "tail": "系统卡死",
    "source_topic": "死锁产生的原因和死锁的条件"
  },
  {
    "head": "死锁",
    "relation": "产生原因",
    "tail": "系统资源的竞争",
    "source_topic": "死锁产生的原因和死锁的条件"
  },
  {
    "head": "死锁",
    "relation": "产生原因",
    "tail": "进程推进顺序非法",
    "source_topic": "死锁产生的原因和死锁的条件"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "互斥条件",
    "source_topic": "死锁产生的原因和死锁的条件"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "不剥夺条件",
    "source_topic": "死锁产生的原因和死锁的条件"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "请求和保持条件",
    "source_topic": "死锁产生的原因和死锁的条件"
  },
  {
    "head": "死锁",
    "relation": "必要条件",
    "tail": "循环等待条件",
    "source_topic": "死锁产生的原因和死锁的条件"
  },
  {
    "head": "单线程",
    "relation": "采用",
    "tail": "I/O复用",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "I/O复用",
    "relation": "包含",
    "tail": "epoll",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "I/O复用",
    "relation": "包含",
    "tail": "select",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "epoll",
    "relation": "基于",
    "tail": "红黑树",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "epoll",
    "relation": "解决",
    "tail": "高并发",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "select",
    "relation": "限制",
    "tail": "1024连接",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "单线程",
    "relation": "采用",
    "tail": "事件驱动模型",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "事件驱动模型",
    "relation": "基于",
    "tail": "异步回调",
    "source_topic": "如何采用单线程处理高并发"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "新建(NEW)",
    "source_topic": "线程的状态"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "可运行(RUNNABLE)",
    "source_topic": "线程的状态"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "运行(RUNNING)",
    "source_topic": "线程的状态"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "阻塞(BLOCKED)",
    "source_topic": "线程的状态"
  },
  {
    "head": "线程",
    "relation": "包含",
    "tail": "死亡(DEAD)",
    "source_topic": "线程的状态"
  },
  {
    "head": "进程",
    "relation": "包含",
    "tail": "运行状态",
    "source_topic": "进程的状态"
  },
  {
    "head": "进程",
    "relation": "包含",
    "tail": "就绪状态",
    "source_topic": "进程的状态"
  },
  {
    "head": "进程",
    "relation": "包含",
    "tail": "阻塞状态",
    "source_topic": "进程的状态"
  },
  {
    "head": "进程",
    "relation": "包含",
    "tail": "创建状态",
    "source_topic": "进程的状态"
  },
  {
    "head": "进程",
    "relation": "包含",
    "tail": "结束状态",
    "source_topic": "进程的状态"
  },
  {
    "head": "阻塞状态",
    "relation": "核心特性",
    "tail": "进程正在等待某一事件而暂停运行",
    "source_topic": "进程的状态"
  },
  {
    "head": "brk",
    "relation": "属于",
    "tail": "系统调用",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "mmap",
    "relation": "属于",
    "tail": "系统调用",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "进程",
    "relation": "分配内存方式",
    "tail": "brk",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "进程",
    "relation": "分配内存方式",
    "tail": "mmap",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "brk",
    "relation": "操作对象",
    "tail": "数据段",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "mmap",
    "relation": "分配位置",
    "tail": "虚拟地址空间",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "mmap",
    "relation": "分配区域",
    "tail": "文件映射区域",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "brk和mmap",
    "relation": "分配类型",
    "tail": "虚拟内存",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "缺页中断",
    "relation": "触发时机",
    "tail": "第一次访问已分配的虚拟地址空间",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "操作系统",
    "relation": "处理方式",
    "tail": "分配物理内存",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "操作系统",
    "relation": "建立关系",
    "tail": "虚拟内存与物理内存的映射",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "malloc",
    "relation": "底层实现",
    "tail": "brk",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "malloc",
    "relation": "底层实现",
    "tail": "mmap",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "free",
    "relation": "底层实现",
    "tail": "munmap",
    "source_topic": "系统调用brk和mmap"
  },
  {
    "head": "页式管理",
    "relation": "属于",
    "tail": "内存管理机制",
    "source_topic": "说说三种内存管理机制"
  },
  {
    "head": "段式管理",
    "relation": "属于",
    "tail": "内存管理机制",
    "source_topic": "说说三种内存管理机制"
  },
  {
    "head": "分段分页管理",
    "relation": "属于",
    "tail": "内存管理机制",
    "source_topic": "说说三种内存管理机制"
  },
  {
    "head": "大端",
    "relation": "定义",
    "tail": "低地址存放高位，高地址存放低位",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "小端",
    "relation": "定义",
    "tail": "低地址存放低位，高地址存放高位",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "C++代码",
    "relation": "用于检测",
    "tail": "大端和小端",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "union",
    "relation": "属于",
    "tail": "C++语言特性",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "char",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "int",
    "relation": "属于",
    "tail": "C++基本数据类型",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "if(tmp.a)",
    "relation": "判断",
    "tail": "小端",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "cout",
    "relation": "输出",
    "tail": "小端",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "else",
    "relation": "判断",
    "tail": "大端",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "cout",
    "relation": "输出",
    "tail": "大端",
    "source_topic": "大端和小端，用C++代码怎么确定"
  },
  {
    "head": "UDP",
    "relation": "属于",
    "tail": "传输层协议",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "属于",
    "tail": "传输层协议",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "核心特性",
    "tail": "无连接",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "面向连接",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "核心特性",
    "tail": "尽最大可能交付",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "提供可靠交付",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "核心特性",
    "tail": "没有拥塞控制",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "有拥塞控制",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "核心特性",
    "tail": "面向报文",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "面向字节流",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "支持通信方式",
    "tail": "一对一",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "支持通信方式",
    "tail": "一对多",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "支持通信方式",
    "tail": "多对一",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "支持通信方式",
    "tail": "多对多",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "支持通信方式",
    "tail": "点对点",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "提供流量控制",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "提供全双工通信",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "可靠性",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "UDP",
    "relation": "核心特性",
    "tail": "传输无保障",
    "source_topic": "TCP和UDP的区别"
  },
  {
    "head": "TCP三次握手",
    "relation": "包含",
    "tail": "LISTEN状态",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "TCP三次握手",
    "relation": "包含",
    "tail": "SYN报文",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "TCP三次握手",
    "relation": "包含",
    "tail": "ACK报文",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "TCP三次握手",
    "relation": "包含",
    "tail": "初始序号",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "TCP三次握手",
    "relation": "包含",
    "tail": "确认号",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "SYN报文",
    "relation": "核心特性",
    "tail": "SYN=1",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "ACK报文",
    "relation": "核心特性",
    "tail": "ACK=1",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "TCP三次握手",
    "relation": "保证",
    "tail": "连接建立",
    "source_topic": "TCP三次握手"
  },
  {
    "head": "第三次握手",
    "relation": "防止",
    "tail": "服务器打开多个连接",
    "source_topic": "三次握手的原因"
  },
  {
    "head": "TCP四次挥手",
    "relation": "包含",
    "tail": "连接释放报文",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "TCP四次挥手",
    "relation": "包含",
    "tail": "半关闭状态",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "TCP四次挥手",
    "relation": "包含",
    "tail": "TIME-WAIT状态",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "TCP四次挥手",
    "relation": "包含",
    "tail": "最大报文存活时间 (MSL)",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "连接释放报文",
    "relation": "包含",
    "tail": "FIN=1",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "半关闭状态",
    "relation": "允许",
    "tail": "B向A发送数据",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "半关闭状态",
    "relation": "禁止",
    "tail": "A向B发送数据",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "TIME-WAIT状态",
    "relation": "需要等待",
    "tail": "2 MSL",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "TCP四次挥手",
    "relation": "解决",
    "tail": "连接释放",
    "source_topic": "TCP四次挥手"
  },
  {
    "head": "TCP四次挥手",
    "relation": "导致",
    "tail": "CLOSE-WAIT状态",
    "source_topic": "四次挥手的原因"
  },
  {
    "head": "CLOSE-WAIT状态",
    "relation": "用于",
    "tail": "服务器端完成数据传输",
    "source_topic": "四次挥手的原因"
  },
  {
    "head": "服务器端",
    "relation": "发送",
    "tail": "FIN连接释放报文",
    "source_topic": "四次挥手的原因"
  },
  {
    "head": "TIME_WAIT",
    "relation": "属于",
    "tail": "TCP连接状态",
    "source_topic": "TIME_WAIT"
  },
  {
    "head": "TIME_WAIT",
    "relation": "导致",
    "tail": "等待2MSL时间",
    "source_topic": "TIME_WAIT"
  },
  {
    "head": "等待2MSL时间",
    "relation": "解决",
    "tail": "确保最后一个确认报文能够到达",
    "source_topic": "TIME_WAIT"
  },
  {
    "head": "HTTP",
    "relation": "属于",
    "tail": "应用层协议",
    "source_topic": "Http协议"
  },
  {
    "head": "HTTP",
    "relation": "基于",
    "tail": "TCP",
    "source_topic": "Http协议"
  },
  {
    "head": "HTTP",
    "relation": "具有",
    "tail": "无状态特性",
    "source_topic": "Http协议"
  },
  {
    "head": "HTTP",
    "relation": "包含",
    "tail": "请求与响应模式",
    "source_topic": "Http协议"
  },
  {
    "head": "HTTP1.1",
    "relation": "提供",
    "tail": "持续连接机制",
    "source_topic": "Http协议"
  },
  {
    "head": "Web应用",
    "relation": "基于",
    "tail": "HTTP协议",
    "source_topic": "Http协议"
  },
  {
    "head": "快排",
    "relation": "属于",
    "tail": "排序算法",
    "source_topic": "几种常见的排序算法"
  },
  {
    "head": "插入",
    "relation": "属于",
    "tail": "排序算法",
    "source_topic": "几种常见的排序算法"
  },
  {
    "head": "选择",
    "relation": "属于",
    "tail": "排序算法",
    "source_topic": "几种常见的排序算法"
  },
  {
    "head": "链表",
    "relation": "属于",
    "tail": "基本数据结构",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "链表",
    "relation": "构成",
    "tail": "高级结构",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "判断链表有环",
    "relation": "使用",
    "tail": "快慢指针",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "快慢指针",
    "relation": "判断",
    "tail": "链表有环",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "转置链表",
    "relation": "时间复杂度",
    "tail": "O(n)",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "转置链表",
    "relation": "空间复杂度",
    "tail": "O(1)",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "转置链表",
    "relation": "使用",
    "tail": "三个指针",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "三个指针",
    "relation": "操作",
    "tail": "改变next指针指向",
    "source_topic": "链表的一些性质和操作"
  },
  {
    "head": "二分法",
    "relation": "属于",
    "tail": "查找算法",
    "source_topic": "常见的查找算法"
  },
  {
    "head": "最长公共子序列",
    "relation": "属于",
    "tail": "动态规划",
    "source_topic": "动态规划"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "在函数体内维持变量值不变",
    "source_topic": "关键字 static 的作用是什么？"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "模块内全局变量的本地访问",
    "source_topic": "关键字 static 的作用是什么？"
  },
  {
    "head": "static",
    "relation": "作用",
    "tail": "限制函数在模块内使用",
    "source_topic": "关键字 static 的作用是什么？"
  },
  {
    "head": "引用",
    "relation": "必须被初始化",
    "tail": "指针",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "引用",
    "relation": "初始化后不可改变",
    "tail": "指针",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "引用",
    "relation": "不存在指向空值",
    "tail": "指针",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "指针",
    "relation": "可以改变所指对象",
    "tail": "引用",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "指针",
    "relation": "存在指向空值",
    "tail": "引用",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "指针",
    "relation": "间接操作对象",
    "tail": "引用",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "引用",
    "relation": "直接操作目标变量",
    "tail": "指针",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "引用",
    "relation": "推荐使用场景",
    "tail": "流操作符>",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "引用",
    "relation": "推荐使用场景",
    "tail": "赋值操作符=",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "引用",
    "relation": "推荐使用场景",
    "tail": "拷贝构造函数的参数",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "引用",
    "relation": "推荐使用场景",
    "tail": "赋值操作符=的参数",
    "source_topic": "“引用”与指针的区别是什么？"
  },
  {
    "head": "实时系统",
    "relation": "核心特性",
    "tail": "实时性",
    "source_topic": "描述实时系统的基本特性"
  },
  {
    "head": "实时系统",
    "relation": "核心特性",
    "tail": "可靠性",
    "source_topic": "描述实时系统的基本特性"
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "静态数据区",
    "source_topic": "全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"
  },
  {
    "head": "局部变量",
    "relation": "存储位置",
    "tail": "堆栈",
    "source_topic": "全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"
  },
  {
    "head": "堆栈溢出",
    "relation": "导致",
    "tail": "没有回收垃圾资源",
    "source_topic": "堆栈溢出一般是由什么原因导致的？"
  },
  {
    "head": "堆栈溢出",
    "relation": "导致",
    "tail": "层次太深的递归调用",
    "source_topic": "堆栈溢出一般是由什么原因导致的？"
  },
  {
    "head": "冒泡排序算法",
    "relation": "时间复杂度",
    "tail": "O(n^2)",
    "source_topic": "冒泡排序算法的时间复杂度是什么？"
  },
  {
    "head": "constructor",
    "relation": "不能声明为",
    "tail": "虚函数",
    "source_topic": "什么函数不能声明为虚函数？"
  },
  {
    "head": "队列",
    "relation": "核心特性",
    "tail": "先进先出",
    "source_topic": "队列和栈有什么区别？"
  },
  {
    "head": "switch()",
    "relation": "限制",
    "tail": "实型",
    "source_topic": "不能做 switch()的参数类型"
  },
  {
    "head": "局部变量",
    "relation": "屏蔽",
    "tail": "全局变量",
    "source_topic": "局部变量能否和全局变量重名？"
  },
  {
    "head": "局部变量",
    "relation": "作用域限制",
    "tail": "循环体内",
    "source_topic": "局部变量能否和全局变量重名？"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "引用头文件",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "extern关键字",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "引用头文件",
    "relation": "错误检测阶段",
    "tail": "编译期间",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "extern关键字",
    "relation": "错误检测阶段",
    "tail": "连接期间",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "全局变量",
    "relation": "定义方式",
    "tail": "头文件",
    "source_topic": "全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？"
  },
  {
    "head": "头文件",
    "relation": "包含",
    "tail": "多个.C文件",
    "source_topic": "全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？"
  },
  {
    "head": "static声明",
    "relation": "作用",
    "tail": "限制全局变量作用域",
    "source_topic": "全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？"
  },
  {
    "head": "static声明",
    "relation": "解决",
    "tail": "多文件中同名全局变量冲突",
    "source_topic": "全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？"
  },
  {
    "head": "全局变量",
    "relation": "初始化规则",
    "tail": "只能在一个.C文件中赋初值",
    "source_topic": "全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？"
  },
  {
    "head": "链接器",
    "relation": "处理",
    "tail": "多文件中同名静态全局变量",
    "source_topic": "全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？"
  },
  {
    "head": "static全局变量",
    "relation": "作用域限制",
    "tail": "定义该变量的源文件内",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "非静态全局变量",
    "relation": "作用域",
    "tail": "整个源程序",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "static全局变量",
    "relation": "防止被引用",
    "tail": "其他文件单元",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "static局部变量",
    "relation": "初始化特性",
    "tail": "只被初始化一次",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "普通局部变量",
    "relation": "初始化特性",
    "tail": "每次函数调用时初始化",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "static局部变量",
    "relation": "值保留",
    "tail": "下一次依据上一次结果值",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "static函数",
    "relation": "作用域限制",
    "tail": "当前源文件",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "普通函数",
    "relation": "作用域",
    "tail": "可在当前源文件以外使用",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "static函数",
    "relation": "内存特性",
    "tail": "在内存中只有一份",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "普通函数",
    "relation": "内存特性",
    "tail": "在每个被调用中维持一份拷贝",
    "source_topic": "statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数 static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？"
  },
  {
    "head": "C/C++程序内存分配",
    "relation": "包含",
    "tail": "栈区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "C/C++程序内存分配",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "C/C++程序内存分配",
    "relation": "包含",
    "tail": "全局区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "C/C++程序内存分配",
    "relation": "包含",
    "tail": "文字常量区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "C/C++程序内存分配",
    "relation": "包含",
    "tail": "程序代码区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "栈区",
    "relation": "由编译器自动分配释放",
    "tail": "函数的参数值",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "栈区",
    "relation": "由编译器自动分配释放",
    "tail": "局部变量的值",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "堆区",
    "relation": "由程序员分配释放",
    "tail": "动态内存",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "堆区",
    "relation": "由操作系统回收",
    "tail": "未被释放的内存",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "全局变量",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "全局区",
    "relation": "存储",
    "tail": "静态变量",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "全局区",
    "relation": "包含",
    "tail": "初始化的全局变量",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "全局区",
    "relation": "包含",
    "tail": "未初始化的全局变量",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "文字常量区",
    "relation": "存储",
    "tail": "常量字符串",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "程序代码区",
    "relation": "存储",
    "tail": "函数体的二进制代码",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "char *p3",
    "relation": "指向",
    "tail": "文字常量区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "malloc",
    "relation": "分配内存",
    "tail": "堆区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "strcpy",
    "relation": "复制字符串",
    "tail": "文字常量区",
    "source_topic": "程序的内存分配"
  },
  {
    "head": "C语言",
    "relation": "堆内存申请函数",
    "tail": "malloc",
    "source_topic": "解释堆和栈的区别"
  },
  {
    "head": "C++语言",
    "relation": "堆内存申请运算符",
    "tail": "new",
    "source_topic": "解释堆和栈的区别"
  },
  {
    "head": "Virtual Alloc",
    "relation": "内存分配方式",
    "tail": "直接在进程地址空间中保留内存",
    "source_topic": "解释堆和栈的区别"
  },
  {
    "head": "Virtual Alloc",
    "relation": "效率特性",
    "tail": "速度快且灵活",
    "source_topic": "解释堆和栈的区别"
  },
  {
    "head": "静态变量",
    "relation": "存储位置",
    "tail": "不在栈中",
    "source_topic": "解释堆和栈的区别"
  },
  {
    "head": "局部变量",
    "relation": "存储位置",
    "tail": "在栈中",
    "source_topic": "解释堆和栈的区别"
  },
  {
    "head": "预编译",
    "relation": "属于",
    "tail": "预处理",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "预编译",
    "relation": "处理",
    "tail": "代码文本替换工作",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "预编译",
    "relation": "处理",
    "tail": "预编译指令",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "预编译指令",
    "relation": "包括",
    "tail": "include",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "预编译指令",
    "relation": "包括",
    "tail": "define",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "预编译指令",
    "relation": "包括",
    "tail": "条件编译",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "C编译系统",
    "relation": "执行",
    "tail": "预处理",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "C预处理功能",
    "relation": "包含",
    "tail": "宏定义",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "C预处理功能",
    "relation": "包含",
    "tail": "文件包含",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "C预处理功能",
    "relation": "包含",
    "tail": "条件编译",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "预编译",
    "relation": "解决",
    "tail": "代码重复",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "预编译",
    "relation": "解决",
    "tail": "模块间包含文件一致性",
    "source_topic": "什么是预编译,何时需要预编译?"
  },
  {
    "head": "const",
    "relation": "核心特性",
    "tail": "只读",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "const int a",
    "relation": "等价于",
    "tail": "int const a",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "const int *a",
    "relation": "核心特性",
    "tail": "指向常整型数的指针",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "int * const a",
    "relation": "核心特性",
    "tail": "指向整型数的常指针",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "const",
    "relation": "作用",
    "tail": "为读代码的人传达有用信息",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "const",
    "relation": "作用",
    "tail": "帮助优化器生成更紧凑的代码",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "const",
    "relation": "作用",
    "tail": "保护不希望被改变的参数",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "const",
    "relation": "解决",
    "tail": "参数被无意修改",
    "source_topic": "关键字 const 是什么含意？"
  },
  {
    "head": "volatile",
    "relation": "核心特性",
    "tail": "变量值可能被意想不到地改变",
    "source_topic": "关键字 volatile 有什么含意 并给出三个不同的例子。"
  },
  {
    "head": "volatile",
    "relation": "应用场景",
    "tail": "并行设备的硬件寄存器",
    "source_topic": "关键字 volatile 有什么含意 并给出三个不同的例子。"
  },
  {
    "head": "const",
    "relation": "应用场景",
    "tail": "只读状态寄存器",
    "source_topic": "关键字 volatile 有什么含意 并给出三个不同的例子。"
  },
  {
    "head": "正确的代码",
    "relation": "解决",
    "tail": "确保读取的值一致以计算平方",
    "source_topic": "关键字 volatile 有什么含意 并给出三个不同的例子。"
  },
  {
    "head": "层次模型",
    "relation": "属于",
    "tail": "基本数据模型",
    "source_topic": "三种基本的数据模型"
  },
  {
    "head": "网状模型",
    "relation": "属于",
    "tail": "基本数据模型",
    "source_topic": "三种基本的数据模型"
  },
  {
    "head": "关系模型",
    "relation": "属于",
    "tail": "基本数据模型",
    "source_topic": "三种基本的数据模型"
  },
  {
    "head": "结构",
    "relation": "区别",
    "tail": "联合",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "联合",
    "relation": "共用",
    "tail": "地址空间",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "结构",
    "relation": "不同地址",
    "tail": "成员",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "联合",
    "relation": "重写",
    "tail": "成员",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "结构",
    "relation": "独立",
    "tail": "成员赋值",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "全局变量",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "包含",
    "tail": "static变量",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "栈上创建",
    "relation": "包含",
    "tail": "函数内局部变量的存储单元",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "栈上创建",
    "relation": "特点",
    "tail": "函数执行结束时自动释放",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "栈上创建",
    "relation": "实现方式",
    "tail": "内置于处理器的指令集",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "别称",
    "tail": "动态内存分配",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "申请方式",
    "tail": "malloc",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "申请方式",
    "tail": "new",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "释放方式",
    "tail": "free",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "释放方式",
    "tail": "delete",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存生存期由程序员决定",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "使用非常灵活",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "堆上分配",
    "relation": "问题",
    "tail": "内存管理问题最多",
    "source_topic": "描述内存分配方式以及它们的区别?"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "常量",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数参数",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数返回值",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "提供",
    "tail": "类型安全检查",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "受到保护",
    "tail": "强制保护",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "预防",
    "tail": "意外的变动",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "提高",
    "tail": "程序的健壮性",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "宏常量",
    "relation": "缺乏",
    "tail": "数据类型",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "const",
    "relation": "支持",
    "tail": "调试",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "宏常量",
    "relation": "不支持",
    "tail": "调试",
    "source_topic": "请说出 const 与#define 相比，有何优点？"
  },
  {
    "head": "数组",
    "relation": "存储位置",
    "tail": "静态存储区或栈",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "指针",
    "relation": "存储位置",
    "tail": "可指向任意类型的内存块",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "数组",
    "relation": "可修改性",
    "tail": "元素内容可修改",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算对象",
    "tail": "数组的容量（字节数）",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算对象",
    "tail": "指针变量的字节数",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "数组",
    "relation": "作为函数参数",
    "tail": "退化为同类型的指针",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "数组",
    "relation": "底层结构",
    "tail": "连续内存块",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "指针",
    "relation": "底层结构",
    "tail": "内存地址",
    "source_topic": "简述数组与指针的区别？"
  },
  {
    "head": "BOOL",
    "relation": "比较方式",
    "tail": "if ( !a )",
    "source_topic": "分别写出 BOOL,int,float,指针类型的变量 a 与“零”的比较语句。"
  },
  {
    "head": "BOOL",
    "relation": "比较方式",
    "tail": "if ( a )",
    "source_topic": "分别写出 BOOL,int,float,指针类型的变量 a 与“零”的比较语句。"
  },
  {
    "head": "int",
    "relation": "比较方式",
    "tail": "if ( a == 0 )",
    "source_topic": "分别写出 BOOL,int,float,指针类型的变量 a 与“零”的比较语句。"
  },
  {
    "head": "float",
    "relation": "比较方式",
    "tail": "if ( a - EXP )",
    "source_topic": "分别写出 BOOL,int,float,指针类型的变量 a 与“零”的比较语句。"
  },
  {
    "head": "__cplusplus",
    "relation": "属于",
    "tail": "预定义宏",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "预定义宏",
    "relation": "用于",
    "tail": "条件编译",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "条件编译",
    "relation": "实现",
    "tail": "判断程序语言",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "cout",
    "relation": "属于",
    "tail": "C++标准库输出流",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "C++标准库输出流",
    "relation": "用于",
    "tail": "输出字符串",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "C语言",
    "relation": "不包含",
    "tail": "__cplusplus",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "C++语言",
    "relation": "包含",
    "tail": "__cplusplus",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "判断程序语言",
    "relation": "通过",
    "tail": "预定义宏__cplusplus",
    "source_topic": "如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？"
  },
  {
    "head": "队列",
    "relation": "实现方式",
    "tail": "两个栈",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "入队操作",
    "relation": "实现方式",
    "tail": "将新元素push入栈A",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "出队操作",
    "relation": "步骤",
    "tail": "判断栈B是否为空",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "出队操作",
    "relation": "步骤",
    "tail": "将栈B的栈顶元素pop出",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "队列",
    "relation": "时间复杂度",
    "tail": "平摊O(1)",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "栈A",
    "relation": "功能",
    "tail": "存储入队元素",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "栈B",
    "relation": "功能",
    "tail": "辅助实现队列的先进先出特性",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "死循环",
    "relation": "实现方式",
    "tail": "while(1)",
    "source_topic": "嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？"
  },
  {
    "head": "死循环",
    "relation": "实现方式",
    "tail": "for(;😉",
    "source_topic": "嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？"
  },
  {
    "head": "死循环",
    "relation": "实现方式",
    "tail": "goto",
    "source_topic": "嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？"
  },
  {
    "head": "位操作",
    "relation": "属于",
    "tail": "计算机技术",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "设置 bit 3",
    "relation": "实现方式",
    "tail": "位或操作（|=）",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "清除 bit 3",
    "relation": "实现方式",
    "tail": "位与非操作（&=~）",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "BIT3",
    "relation": "定义方式",
    "tail": "位掩码（0x1 << 3）",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位掩码",
    "relation": "用途",
    "tail": "位操作",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "C语言",
    "relation": "包含",
    "tail": "bit fields",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "bit fields",
    "relation": "缺点",
    "tail": "不可移植性",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "bit fields",
    "relation": "缺点",
    "tail": "不可重用性",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "嵌入式系统",
    "relation": "需求",
    "tail": "位操作",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位操作",
    "relation": "应用场景",
    "tail": "寄存器操作",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位操作",
    "relation": "应用场景",
    "tail": "变量操作",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位或操作（|=）",
    "relation": "作用",
    "tail": "设置特定位",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位与非操作（&=~）",
    "relation": "作用",
    "tail": "清除特定位",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位操作",
    "relation": "解决方式",
    "tail": "使用位掩码和 #defines",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位掩码",
    "relation": "核心特性",
    "tail": "可移植性",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "位掩码",
    "relation": "核心特性",
    "tail": "可重用性",
    "source_topic": "位操作（Bit manipulation）"
  },
  {
    "head": "嵌入式系统",
    "relation": "要求",
    "tail": "访问固定内存位置",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "ANSI编译器",
    "relation": "允许",
    "tail": "整型数强制转换为指针",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "整型数",
    "relation": "强制转换为",
    "tail": "指针",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "访问固定内存位置",
    "relation": "实现方式",
    "tail": "将整型数强制转换为指针并赋值",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "指针",
    "relation": "指向",
    "tail": "绝对地址0x67a9",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "整型变量",
    "relation": "设置值",
    "tail": "0xaa66",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "访问固定内存位置",
    "relation": "实现方式",
    "tail": "使用常量指针赋值",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "常量指针",
    "relation": "指向",
    "tail": "绝对地址0x67a9",
    "source_topic": "访问固定的内存位置（Accessing fixed memory locations）"
  },
  {
    "head": "浮点运算",
    "relation": "不可重入",
    "tail": "许多处理器/编译器",
    "source_topic": "中断（Interrupts）"
  },
  {
    "head": "中断服务子程序(ISR)",
    "relation": "应避免使用",
    "tail": "浮点运算",
    "source_topic": "中断（Interrupts）"
  },
  {
    "head": "中断服务子程序(ISR)",
    "relation": "应避免使用",
    "tail": "printf函数",
    "source_topic": "中断（Interrupts）"
  },
  {
    "head": "printf函数",
    "relation": "存在",
    "tail": "重入问题",
    "source_topic": "中断（Interrupts）"
  },
  {
    "head": "printf函数",
    "relation": "存在",
    "tail": "性能问题",
    "source_topic": "中断（Interrupts）"
  },
  {
    "head": "__interrupt关键字",
    "relation": "用于定义",
    "tail": "中断服务子程序(ISR)",
    "source_topic": "中断（Interrupts）"
  },
  {
    "head": "中断服务子程序(ISR)",
    "relation": "应该具备",
    "tail": "短而高效",
    "source_topic": "中断（Interrupts）"
  },
  {
    "head": "动态内存分配",
    "relation": "可能导致",
    "tail": "内存碎片",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "动态内存分配",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "内存碎片",
    "relation": "属于",
    "tail": "内存管理问题",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "变量的持行时间",
    "relation": "属于",
    "tail": "内存管理问题",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "碎片收集",
    "relation": "属于",
    "tail": "内存管理问题",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "malloc(0)",
    "relation": "返回",
    "tail": "合法指针",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "动态内存分配",
    "relation": "应用于",
    "tail": "嵌入式系统",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "Select机制",
    "relation": "基于",
    "tail": "轮询",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "Select机制",
    "relation": "限制",
    "tail": "1024连接",
    "source_topic": "动态内存分配（Dynamic memory allocation）"
  },
  {
    "head": "typedef",
    "relation": "属于",
    "tail": "C语言",
    "source_topic": "Typedef"
  },
  {
    "head": "typedef",
    "relation": "功能",
    "tail": "声明已有数据类型的同义字",
    "source_topic": "Typedef"
  },
  {
    "head": "预处理器",
    "relation": "功能",
    "tail": "定义数据类型的同义字",
    "source_topic": "Typedef"
  },
  {
    "head": "typedef",
    "relation": "优势",
    "tail": "避免类型定义歧义",
    "source_topic": "Typedef"
  },
  {
    "head": "dPS",
    "relation": "定义",
    "tail": "struct s *",
    "source_topic": "Typedef"
  },
  {
    "head": "tPS",
    "relation": "定义",
    "tail": "struct s *",
    "source_topic": "Typedef"
  },
  {
    "head": "dPS p1",
    "relation": "定义",
    "tail": "指向结构s的指针",
    "source_topic": "Typedef"
  },
  {
    "head": "p2",
    "relation": "定义",
    "tail": "实际的结构",
    "source_topic": "Typedef"
  },
  {
    "head": "tPS p3,p4",
    "relation": "定义",
    "tail": "两个指向结构s的指针",
    "source_topic": "Typedef"
  },
  {
    "head": "int a",
    "relation": "属于",
    "tail": "整型数",
    "source_topic": "用变量 a 给出下面的定义"
  },
  {
    "head": "int *a",
    "relation": "属于",
    "tail": "指向整型数的指针",
    "source_topic": "用变量 a 给出下面的定义"
  },
  {
    "head": "int a[10]",
    "relation": "属于",
    "tail": "有10个整型数的数组",
    "source_topic": "用变量 a 给出下面的定义"
  },
  {
    "head": "int *a[10]",
    "relation": "属于",
    "tail": "有10个指向整型数的指针的数组",
    "source_topic": "用变量 a 给出下面的定义"
  },
  {
    "head": "int (*a)[10]",
    "relation": "属于",
    "tail": "指向有10个整型数的数组的指针",
    "source_topic": "用变量 a 给出下面的定义"
  },
  {
    "head": "SWAP宏",
    "relation": "实现方式",
    "tail": "算术交换",
    "source_topic": "写一个“标准”宏"
  },
  {
    "head": "算术交换",
    "relation": "属于",
    "tail": "宏定义",
    "source_topic": "写一个“标准”宏"
  },
  {
    "head": "SWAP宏",
    "relation": "功能",
    "tail": "交换两个参数的值",
    "source_topic": "写一个“标准”宏"
  },
  {
    "head": "DOUBLE(5)",
    "relation": "计算结果",
    "tail": "30",
    "source_topic": "define MIN(A,B) ((A) < (B))? (A) : (B))"
  },
  {
    "head": "DOUBLE(5)",
    "relation": "计算结果",
    "tail": "50",
    "source_topic": "define MIN(A,B) ((A) < (B))? (A) : (B))"
  },
  {
    "head": "DOUBLE(x)",
    "relation": "定义",
    "tail": "x+x",
    "source_topic": "define MIN(A,B) ((A) < (B))? (A) : (B))"
  },
  {
    "head": "DOUBLE(x)",
    "relation": "定义",
    "tail": "((x)+(x))",
    "source_topic": "define MIN(A,B) ((A) < (B))? (A) : (B))"
  },
  {
    "head": "宏定义",
    "relation": "用途",
    "tail": "计算数组元素个数",
    "source_topic": "define MIN(A,B) ((A) < (B))? (A) : (B))"
  },
  {
    "head": "static变量",
    "relation": "作用域限制",
    "tail": "本模块",
    "source_topic": "A.c 和 B.c 两个 c 文件中使用了两个相同名字的 static 变量,编译的时候会不会有问题? 这两个 static 变量会保存到哪里（栈还是堆或者其他的）?"
  },
  {
    "head": "static变量",
    "relation": "存储位置",
    "tail": "数据区",
    "source_topic": "A.c 和 B.c 两个 c 文件中使用了两个相同名字的 static 变量,编译的时候会不会有问题? 这两个 static 变量会保存到哪里（栈还是堆或者其他的）?"
  },
  {
    "head": "static变量",
    "relation": "命名处理",
    "tail": "编译器区分",
    "source_topic": "A.c 和 B.c 两个 c 文件中使用了两个相同名字的 static 变量,编译的时候会不会有问题? 这两个 static 变量会保存到哪里（栈还是堆或者其他的）?"
  },
  {
    "head": "extern关键字",
    "relation": "作用",
    "tail": "使变量在其他模块有意义",
    "source_topic": "A.c 和 B.c 两个 c 文件中使用了两个相同名字的 static 变量,编译的时候会不会有问题? 这两个 static 变量会保存到哪里（栈还是堆或者其他的）?"
  },
  {
    "head": "单向链表",
    "relation": "操作方式",
    "tail": "复制下一个节点的值",
    "source_topic": "一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指 向的节点？"
  },
  {
    "head": "单向链表",
    "relation": "操作方式",
    "tail": "修改当前节点的next指针",
    "source_topic": "一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指 向的节点？"
  },
  {
    "head": "单向链表",
    "relation": "操作方式",
    "tail": "删除原next节点",
    "source_topic": "一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指 向的节点？"
  },
  {
    "head": "STL",
    "relation": "属于",
    "tail": "标准模版库",
    "source_topic": "介绍一下STL，详细说明STL如何实现vector。"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "容器",
    "source_topic": "介绍一下STL，详细说明STL如何实现vector。"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "算法",
    "source_topic": "介绍一下STL，详细说明STL如何实现vector。"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "迭代器",
    "source_topic": "介绍一下STL，详细说明STL如何实现vector。"
  },
  {
    "head": "vector",
    "relation": "属于",
    "tail": "动态数组",
    "source_topic": "介绍一下STL，详细说明STL如何实现vector。"
  },
  {
    "head": "vector",
    "relation": "实现方式",
    "tail": "动态数组",
    "source_topic": "介绍一下STL，详细说明STL如何实现vector。"
  },
  {
    "head": "LNK2001",
    "relation": "导致",
    "tail": "未解析的外部符号",
    "source_topic": "如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。"
  },
  {
    "head": "未解析的外部符号",
    "relation": "原因",
    "tail": "引用的函数、变量不存在",
    "source_topic": "如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。"
  },
  {
    "head": "未解析的外部符号",
    "relation": "原因",
    "tail": "引用的函数、变量拼写不正确",
    "source_topic": "如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。"
  },
  {
    "head": "未解析的外部符号",
    "relation": "原因",
    "tail": "引用的函数、变量使用错误",
    "source_topic": "如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。"
  },
  {
    "head": "未解析的外部符号",
    "relation": "原因",
    "tail": "使用了不同版本的连接库",
    "source_topic": "如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。"
  },
  {
    "head": "LNK2005",
    "relation": "属于",
    "tail": "重复定义错误",
    "source_topic": "如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。"
  },
  {
    "head": "LNK2005",
    "relation": "解决",
    "tail": "检查代码中是否存在重复定义",
    "source_topic": "如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。"
  },
  {
    "head": "委派",
    "relation": "属于",
    "tail": "OOD",
    "source_topic": "继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。"
  },
  {
    "head": "委派",
    "relation": "属于",
    "tail": "OOP",
    "source_topic": "继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。"
  },
  {
    "head": "模板",
    "relation": "用于生成",
    "tail": "一组类",
    "source_topic": "继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。"
  },
  {
    "head": "对象的类型",
    "relation": "不影响",
    "tail": "类中函数的行为",
    "source_topic": "继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。"
  },
  {
    "head": "对象的类型",
    "relation": "影响",
    "tail": "类中函数的行为",
    "source_topic": "继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。"
  },
  {
    "head": "引用",
    "relation": "必须初始化",
    "tail": "有效对象",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "指针",
    "relation": "无需初始化",
    "tail": "定义时",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "引用",
    "relation": "二进制实现",
    "tail": "指针",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "引用",
    "relation": "不存在空引用",
    "tail": "特性",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "指针",
    "relation": "可能存在空指针",
    "tail": "特性",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "引用",
    "relation": "安全性",
    "tail": "比指针高",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "常量指针",
    "relation": "可能存在空指针",
    "tail": "特性",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "引用",
    "relation": "效率",
    "tail": "指针",
    "source_topic": "指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？"
  },
  {
    "head": "参数传递",
    "relation": "分类",
    "tail": "传值",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；"
  },
  {
    "head": "参数传递",
    "relation": "分类",
    "tail": "传指针",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；"
  },
  {
    "head": "参数传递",
    "relation": "分类",
    "tail": "传引用",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；"
  },
  {
    "head": "多态参数传递",
    "relation": "采用",
    "tail": "传引用",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；"
  },
  {
    "head": "多态参数传递",
    "relation": "不采用",
    "tail": "传值",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；"
  },
  {
    "head": "多态参数传递",
    "relation": "不采用",
    "tail": "传指针",
    "source_topic": "参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；"
  },
  {
    "head": "设计模式",
    "relation": "属于",
    "tail": "面向对象软件领域",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "设计模式",
    "relation": "区别",
    "tail": "框架",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "设计模式",
    "relation": "问题域",
    "tail": "面向对象的问题域",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "框架",
    "relation": "问题域",
    "tail": "特定业务的问题域",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "设计模式",
    "relation": "抽象程度",
    "tail": "比框架更为抽象",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "设计模式",
    "relation": "生成方式",
    "tail": "碰到具体问题后产生代码",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "框架",
    "relation": "生成方式",
    "tail": "已经可以用代码表示",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "设计模式",
    "relation": "体系结构元素",
    "tail": "比框架更小的体系结构元素",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "框架",
    "relation": "包含",
    "tail": "多个设计模式",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "设计模式",
    "relation": "类比",
    "tail": "武术中的基本招式",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "框架",
    "relation": "类比",
    "tail": "武术中的套路",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "设计模式",
    "relation": "理论程度",
    "tail": "已经上升到理论程度",
    "source_topic": "介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）"
  },
  {
    "head": "C语言",
    "relation": "定义结构",
    "tail": "数据的结合",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++",
    "relation": "结构定义",
    "tail": "struct",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++",
    "relation": "结构定义",
    "tail": "class",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++ struct",
    "relation": "功能等同",
    "tail": "C++ class",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++ struct",
    "relation": "默认访问属性",
    "tail": "public",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "C++ class",
    "relation": "默认访问属性",
    "tail": "private",
    "source_topic": "C++和C定义结构的分别是什么。"
  },
  {
    "head": "构造函数",
    "relation": "不能为",
    "tail": "虚函数",
    "source_topic": "构造函数可否是虚汗数，为什么？析构函数呢，可否是纯虚的呢？"
  },
  {
    "head": "析构函数",
    "relation": "可以为",
    "tail": "纯虚函数",
    "source_topic": "构造函数可否是虚汗数，为什么？析构函数呢，可否是纯虚的呢？"
  },
  {
    "head": "深拷贝",
    "relation": "核心特性",
    "tail": "拷贝资源和指针",
    "source_topic": "拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。"
  },
  {
    "head": "浅拷贝",
    "relation": "核心特性",
    "tail": "拷贝指针但不拷贝资源",
    "source_topic": "拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。"
  },
  {
    "head": "浅拷贝",
    "relation": "导致",
    "tail": "对同一份资源析构两次",
    "source_topic": "拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。"
  },
  {
    "head": "对同一份资源析构两次",
    "relation": "导致",
    "tail": "程序崩溃",
    "source_topic": "拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。"
  },
  {
    "head": "临时对象",
    "relation": "核心特性",
    "tail": "开销比局部对象小些",
    "source_topic": "拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。"
  },
  {
    "head": "子类",
    "relation": "无需显式声明",
    "tail": "虚函数",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "虚函数",
    "relation": "属于",
    "tail": "基类",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "显式声明虚函数",
    "relation": "提升",
    "tail": "代码清晰度",
    "source_topic": "基类的有1个虚函数，子类还需要申明为virtual吗？为什么。"
  },
  {
    "head": "C++类",
    "relation": "具备",
    "tail": "封装",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "OOD",
    "relation": "改变",
    "tail": "程序设计模式",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "OOP",
    "relation": "改变",
    "tail": "设计思想",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "OOP",
    "relation": "具有",
    "tail": "重大和深远的意义",
    "source_topic": "C也可以通过精心封装某些函数功能实现重用，那C++的类有什么优点吗，难道仅仅是为实现重用。"
  },
  {
    "head": "子类",
    "relation": "继承",
    "tail": "父类",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "构造函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "析构函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "拷贝构造函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "operator=",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "子类",
    "relation": "不能继承",
    "tail": "友元函数",
    "source_topic": "C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。"
  },
  {
    "head": "模板",
    "relation": "属于",
    "tail": "泛型编程",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "泛型编程",
    "relation": "体现",
    "tail": "通用和泛化的思想",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "vector",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "list",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "deque",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "map",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "multimap",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "set",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "STL",
    "relation": "包含",
    "tail": "multiset",
    "source_topic": "介绍一下模板和容器。如何实现？（也许会让你当场举例实现）"
  },
  {
    "head": "MVC模式",
    "relation": "属于",
    "tail": "观察者模式",
    "source_topic": "你如何理解MVC。简单举例来说明其应用。"
  },
  {
    "head": "MVC模式",
    "relation": "应用实例",
    "tail": "MFC文档视图架构",
    "source_topic": "你如何理解MVC。简单举例来说明其应用。"
  },
  {
    "head": "多重继承",
    "relation": "解决",
    "tail": "向上继承的二义性",
    "source_topic": "多重继承如何消除向上继承的二义性。"
  },
  {
    "head": "虚拟继承",
    "relation": "用于",
    "tail": "消除向上继承的二义性",
    "source_topic": "多重继承如何消除向上继承的二义性。"
  },
  {
    "head": "并行计算",
    "relation": "属于",
    "tail": "计算机系统计算手段",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "并行计算",
    "relation": "基本思想",
    "tail": "使用多个处理器协同求解同一问题",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "并行计算",
    "relation": "分解问题",
    "tail": "将问题分解成若干部分",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "并行计算系统",
    "relation": "可以是",
    "tail": "超级计算机",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "并行计算系统",
    "relation": "可以是",
    "tail": "计算机构成的集群",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "并行计算",
    "relation": "分类",
    "tail": "时间上的并行",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "并行计算",
    "relation": "分类",
    "tail": "空间上的并行",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "时间上的并行",
    "relation": "实现方式",
    "tail": "流水线技术",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "空间上的并行",
    "relation": "实现方式",
    "tail": "多个处理机并发执行计算",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "空间上的并行",
    "relation": "连接方式",
    "tail": "通过网络连接处理机",
    "source_topic": "什么是并行计算?"
  },
  {
    "head": "10.110.12.29",
    "relation": "属于",
    "tail": "10.110.12.0/27",
    "source_topic": "与10.110.12.29mask 255.255.255.224属于同一网段的主机IP地址有哪些？"
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "target",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "prerequisites",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "command",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "显示规则",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "隐晦规则",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "变量定义",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "文件指示",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "包含",
    "tail": "注释",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "command",
    "relation": "必须以",
    "tail": "Tab键开始",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "显示规则",
    "relation": "说明",
    "tail": "生成目标文件",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "显示规则",
    "relation": "包含",
    "tail": "生成的文件",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "显示规则",
    "relation": "包含",
    "tail": "依赖文件",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "显示规则",
    "relation": "包含",
    "tail": "生成的命令",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "隐晦规则",
    "relation": "基于",
    "tail": "自动推导功能",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "变量定义",
    "relation": "属于",
    "tail": "Makefile",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "文件指示",
    "relation": "用于",
    "tail": "引用其他Makefile",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "文件指示",
    "relation": "用于",
    "tail": "指定Makefile有效部分",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "文件指示",
    "relation": "用于",
    "tail": "定义多行命令",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "注释",
    "relation": "使用",
    "tail": "行注释",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "Makefile",
    "relation": "要求",
    "tail": "命令以Tab键开始",
    "source_topic": "讲一讲Makefile的内容."
  },
  {
    "head": "内联函数",
    "relation": "解决",
    "tail": "函数调用的效率问题",
    "source_topic": "讲一讲C++的内联函数"
  },
  {
    "head": "内联函数",
    "relation": "适用场景",
    "tail": "1-5行的小函数",
    "source_topic": "讲一讲C++的内联函数"
  },
  {
    "head": "内联函数",
    "relation": "限制",
    "tail": "不允许使用循环语句",
    "source_topic": "讲一讲C++的内联函数"
  },
  {
    "head": "内联函数",
    "relation": "限制",
    "tail": "不允许使用开关语句",
    "source_topic": "讲一讲C++的内联函数"
  },
  {
    "head": "内联函数",
    "relation": "定义位置",
    "tail": "必须出现在第一次调用之前",
    "source_topic": "讲一讲C++的内联函数"
  },
  {
    "head": "内联函数",
    "relation": "定义位置",
    "tail": "类说明内部定义的函数",
    "source_topic": "讲一讲C++的内联函数"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "数组",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "deque",
    "relation": "底层结构",
    "tail": "双端队列",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "list",
    "relation": "底层结构",
    "tail": "双向链表",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "set",
    "relation": "底层结构",
    "tail": "排序数据结构",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "排序二元组集合",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "vector",
    "relation": "限制",
    "tail": "只能在前面增加数据",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "deque",
    "relation": "功能相似",
    "tail": "vector",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "list",
    "relation": "核心特性",
    "tail": "游标一次移动一步",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "set",
    "relation": "核心特性",
    "tail": "数据值唯一",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "键值唯一",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "通过键值查找元素",
    "source_topic": "vector, deque, list, set, map底层数据结构 vector（向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。"
  },
  {
    "head": "宏定义",
    "relation": "提高",
    "tail": "程序可读性",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "宏定义",
    "relation": "提高",
    "tail": "程序运行效率",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "带参宏定义",
    "relation": "避免",
    "tail": "函数出栈与入栈操作",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "宏定义",
    "relation": "处理",
    "tail": "预处理器",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "宏定义",
    "relation": "实现",
    "tail": "字符串操作",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "宏定义",
    "relation": "导致",
    "tail": "代码冗余",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "宏定义",
    "relation": "影响",
    "tail": "程序可读性",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "宏定义",
    "relation": "存在",
    "tail": "安全隐患",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "带参宏定义",
    "relation": "不检查",
    "tail": "参数合法性",
    "source_topic": "宏定义的优缺点"
  },
  {
    "head": "深度优先搜索",
    "relation": "属于",
    "tail": "图遍历算法",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "实现方式",
    "tail": "递归",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "实现方式",
    "tail": "非递归",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "遍历步骤",
    "tail": "访问顶点v",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "遍历步骤",
    "tail": "回溯到未被访问的顶点并继续遍历",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "遍历条件",
    "tail": "图中所有顶点均被访问",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "邻接矩阵",
    "tail": "int maze[][]",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "访问标记",
    "tail": "visited数组",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "visited数组",
    "relation": "标记含义",
    "tail": "0表示结点尚未入栈，也未访问",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "visited数组",
    "relation": "标记含义",
    "tail": "1表示结点入栈",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "visited数组",
    "relation": "标记含义",
    "tail": "2表示结点被访问",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "深度优先搜索",
    "relation": "数据结构",
    "tail": "LinkedList",
    "source_topic": "bfs和dfs如何遍历"
  },
  {
    "head": "CPU",
    "relation": "通过",
    "tail": "内存管理单元",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "内存管理单元",
    "relation": "属于",
    "tail": "CPU",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "TLB",
    "relation": "属于",
    "tail": "内存管理单元",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "TLB",
    "relation": "作用",
    "tail": "加速虚拟地址到物理地址的转换",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "虚拟地址",
    "relation": "转换为",
    "tail": "物理地址",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "内存管理单元",
    "relation": "实现",
    "tail": "页表",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "页表",
    "relation": "用于",
    "tail": "虚拟地址到物理地址的转换",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "CPU",
    "relation": "使用",
    "tail": "虚拟地址",
    "source_topic": "CPU如果访问内存?"
  },
  {
    "head": "find",
    "relation": "使用",
    "tail": "HashMap",
    "source_topic": "找出在A数组中，B数组中没有的数字，在B数组中，A数组中没有的数字"
  },
  {
    "head": "HashMap",
    "relation": "实现",
    "tail": "存储数组元素",
    "source_topic": "找出在A数组中，B数组中没有的数字，在B数组中，A数组中没有的数字"
  },
  {
    "head": "find",
    "relation": "处理",
    "tail": "数组元素比较",
    "source_topic": "找出在A数组中，B数组中没有的数字，在B数组中，A数组中没有的数字"
  },
  {
    "head": "find",
    "relation": "属于",
    "tail": "Java算法",
    "source_topic": "找出在A数组中，B数组中没有的数字，在B数组中，A数组中没有的数字"
  },
  {
    "head": "find",
    "relation": "输出",
    "tail": "在B数组中A不存在的数字",
    "source_topic": "找出在A数组中，B数组中没有的数字，在B数组中，A数组中没有的数字"
  },
  {
    "head": "extern \"C\"",
    "relation": "解决",
    "tail": "名字匹配问题",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "extern \"C\"",
    "relation": "实现",
    "tail": "C++与C的混合编程",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "C++编译器",
    "relation": "产生",
    "tail": "_foo_int_int",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "C编译器",
    "relation": "产生",
    "tail": "_foo",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "C语言",
    "relation": "不支持",
    "tail": "函数重载",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "C++语言",
    "relation": "支持",
    "tail": "函数重载",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "extern",
    "relation": "表明",
    "tail": "函数和全局变量作用范围",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "extern \"C\"",
    "relation": "修饰",
    "tail": "变量和函数",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "extern \"C\"",
    "relation": "按照",
    "tail": "C语言方式编译和连接",
    "source_topic": "在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？"
  },
  {
    "head": "预编译头文件保护符",
    "relation": "作用",
    "tail": "防止头文件被多次包含",
    "source_topic": "头文件中的ifndef/define/endif有什么作用？"
  },
  {
    "head": "C语言",
    "relation": "属于",
    "tail": "结构化语言",
    "source_topic": "评价一下C/C++各自的特点"
  },
  {
    "head": "C语言",
    "relation": "基于",
    "tail": "算法和数据结构",
    "source_topic": "评价一下C/C++各自的特点"
  },
  {
    "head": "C语言",
    "relation": "关注点",
    "tail": "通过过程或函数从输入得到输出",
    "source_topic": "评价一下C/C++各自的特点"
  },
  {
    "head": "C++",
    "relation": "属于",
    "tail": "面向对象语言",
    "source_topic": "评价一下C/C++各自的特点"
  },
  {
    "head": "C++",
    "relation": "基于",
    "tail": "类、对象和继承",
    "source_topic": "评价一下C/C++各自的特点"
  },
  {
    "head": "C++",
    "relation": "关注点",
    "tail": "构造对象模型以契合对应问题",
    "source_topic": "评价一下C/C++各自的特点"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "常量",
    "source_topic": "const 有什么用途？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数的返回值",
    "source_topic": "const 有什么用途？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数的形参",
    "source_topic": "const 有什么用途？"
  },
  {
    "head": "const",
    "relation": "修饰",
    "tail": "函数的定义体",
    "source_topic": "const 有什么用途？"
  },
  {
    "head": "const",
    "relation": "定义",
    "tail": "类的const成员函数",
    "source_topic": "const 有什么用途？"
  },
  {
    "head": "const",
    "relation": "作用",
    "tail": "预防意外的变动",
    "source_topic": "const 有什么用途？"
  },
  {
    "head": "const",
    "relation": "提升",
    "tail": "程序的健壮性",
    "source_topic": "const 有什么用途？"
  },
  {
    "head": "const",
    "relation": "用途更广",
    "tail": "define",
    "source_topic": "const和#define有什么区别？"
  },
  {
    "head": "const常量",
    "relation": "具有",
    "tail": "数据类型",
    "source_topic": "const和#define有什么区别？"
  },
  {
    "head": "宏常量",
    "relation": "没有",
    "tail": "数据类型",
    "source_topic": "const和#define有什么区别？"
  },
  {
    "head": "const常量",
    "relation": "支持",
    "tail": "类型安全检查",
    "source_topic": "const和#define有什么区别？"
  },
  {
    "head": "宏常量",
    "relation": "不支持",
    "tail": "类型安全检查",
    "source_topic": "const和#define有什么区别？"
  },
  {
    "head": "const常量",
    "relation": "支持",
    "tail": "调试",
    "source_topic": "const和#define有什么区别？"
  },
  {
    "head": "宏常量",
    "relation": "不支持",
    "tail": "调试",
    "source_topic": "const和#define有什么区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算",
    "tail": "栈中分配的内存大小",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "sizeof",
    "relation": "不计算",
    "tail": "static变量占得内存",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "32位系统",
    "relation": "指针大小",
    "tail": "4个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "64位系统",
    "relation": "指针大小",
    "tail": "8个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "char型",
    "relation": "占用字节数",
    "tail": "1个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "int",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "short int",
    "relation": "占用字节数",
    "tail": "2个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "long int",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "float",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "double",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "string",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "空类",
    "relation": "占用字节数",
    "tail": "1个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "单一继承的空类",
    "relation": "占用字节数",
    "tail": "1个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "虚继承",
    "relation": "涉及",
    "tail": "虚指针",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "虚继承",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "字符数组",
    "relation": "考虑",
    "tail": "末尾的空字符",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "结构体对象长度",
    "relation": "对齐单位",
    "tail": "结构体内最长的数据元素的长度",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "结构体对象长度",
    "relation": "对齐方式",
    "tail": "整数倍",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "处理器位数",
    "relation": "影响",
    "tail": "结构体对象长度对齐单位",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "unsigned",
    "relation": "影响",
    "tail": "最高位的意义",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "unsigned",
    "relation": "不影响",
    "tail": "数据长度",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "unsigned int",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "自定义类型",
    "relation": "sizeof取值",
    "tail": "类型原型的sizeof",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "sizeof",
    "relation": "要求",
    "tail": "类型名加括号",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "sizeof",
    "relation": "允许",
    "tail": "变量名不加括号",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "sizeof",
    "relation": "基于",
    "tail": "运算符",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "结构类型",
    "relation": "返回",
    "tail": "实际的大小",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "静态数组",
    "relation": "返回",
    "tail": "数组的全部大小",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "sizeof",
    "relation": "不能返回",
    "tail": "动态数组的尺寸",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "sizeof",
    "relation": "不能返回",
    "tail": "外部数组的尺寸",
    "source_topic": "关于sizeof小结的。"
  },
  {
    "head": "sizeof",
    "relation": "返回值类型",
    "tail": "size_t",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "返回值类型",
    "tail": "unsigned int",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "运算符",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "参数类型",
    "tail": "任意类型或变量、函数",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "参数类型",
    "tail": "char*",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "参数要求",
    "tail": "以’\\0’结尾",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "数组处理",
    "tail": "不退化为指针",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "数组处理",
    "tail": "退化为指针",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算时机",
    "tail": "编译时",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "计算时机",
    "tail": "运行时",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "sizeof",
    "relation": "返回值含义",
    "tail": "内存大小",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "strlen",
    "relation": "返回值含义",
    "tail": "字符串中字符的个数",
    "source_topic": "sizeof与strlen的区别？"
  },
  {
    "head": "指针",
    "relation": "功能",
    "tail": "间接操作对象",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "功能",
    "tail": "间接操作对象",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "特性",
    "tail": "定义时可以不初始化",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "特性",
    "tail": "定义时必须初始化",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "特性",
    "tail": "一经绑定，持续保持与对象的绑定",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针赋值",
    "relation": "行为",
    "tail": "重新指向另一个对象",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用赋值",
    "relation": "行为",
    "tail": "修改对象本身",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "指针",
    "relation": "支持",
    "tail": "类型转换",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "分类",
    "tail": "const引用",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "引用",
    "relation": "分类",
    "tail": "非const引用",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "非const引用",
    "relation": "限制",
    "tail": "只能绑定同类型对象",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "const引用",
    "relation": "支持",
    "tail": "绑定不同但相关类型的对象",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "const引用",
    "relation": "支持",
    "tail": "绑定右值",
    "source_topic": "指针和引用的区别？"
  },
  {
    "head": "数组",
    "relation": "创建位置",
    "tail": "全局数据区",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "指针",
    "relation": "指向能力",
    "tail": "任意类型的内存块",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组",
    "relation": "内容修改",
    "tail": "允许修改",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "指针",
    "relation": "内容修改",
    "tail": "指向常量字符串时不允许修改",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算对象",
    "tail": "数组的容量（字节数）",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "sizeof",
    "relation": "计算对象",
    "tail": "指针变量的字节数",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "数组",
    "relation": "函数参数传递",
    "tail": "退化为同类型的指针",
    "source_topic": "数组和指针的区别？"
  },
  {
    "head": "空指针",
    "relation": "定义",
    "tail": "被赋值为NULL的指针",
    "source_topic": "空指针和悬垂指针的区别？"
  },
  {
    "head": "空指针",
    "relation": "区别",
    "tail": "可以被多次delete",
    "source_topic": "空指针和悬垂指针的区别？"
  },
  {
    "head": "悬垂指针",
    "relation": "区别",
    "tail": "再次删除时程序会变得非常不稳定",
    "source_topic": "空指针和悬垂指针的区别？"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C/C++标准库函数",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C/C++标准库函数",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "malloc",
    "relation": "用于",
    "tail": "动态申请内存",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "free",
    "relation": "用于",
    "tail": "动态释放内存",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "new",
    "relation": "用于",
    "tail": "动态申请内存",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "delete",
    "relation": "用于",
    "tail": "动态释放内存",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "malloc",
    "relation": "需要指定",
    "tail": "内存字节数",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "new",
    "relation": "支持",
    "tail": "默认初始化",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "new",
    "relation": "支持",
    "tail": "指定初始化",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "malloc",
    "relation": "不支持",
    "tail": "构造函数执行",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "malloc",
    "relation": "不支持",
    "tail": "析构函数调用",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "free",
    "relation": "不支持",
    "tail": "析构函数调用",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "new",
    "relation": "执行",
    "tail": "构造函数",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "delete",
    "relation": "执行",
    "tail": "析构函数",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "类类型对象",
    "relation": "需要",
    "tail": "构造函数执行",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "类类型对象",
    "relation": "需要",
    "tail": "析构函数调用",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "malloc/free",
    "relation": "无法满足",
    "tail": "类类型对象内存管理",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "new/delete",
    "relation": "解决",
    "tail": "类类型对象内存管理",
    "source_topic": "C++中有malloc/free，为什么还有new/delete？"
  },
  {
    "head": "智能指针",
    "relation": "属于",
    "tail": "内存管理技术",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "智能指针",
    "relation": "实现技术",
    "tail": "引用计数",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "引用计数",
    "relation": "跟踪",
    "tail": "共享同一指针的对象数量",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "智能指针类",
    "relation": "包含",
    "tail": "计数器",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "智能指针",
    "relation": "解决",
    "tail": "指针成员管理问题",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "智能指针",
    "relation": "减少",
    "tail": "内存泄漏风险",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "智能指针",
    "relation": "核心特性",
    "tail": "自动释放资源",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "智能指针",
    "relation": "管理",
    "tail": "指针成员",
    "source_topic": "什么是智能指针？"
  },
  {
    "head": "面向对象技术",
    "relation": "基本特征",
    "tail": "封装",
    "source_topic": "面向对象技术的基本概念是什么，三个基本特征是什么？"
  },
  {
    "head": "C++空类",
    "relation": "默认包含",
    "tail": "默认构造函数",
    "source_topic": "C++空类默认有哪些成员函数？"
  },
  {
    "head": "C++空类",
    "relation": "默认包含",
    "tail": "析构函数",
    "source_topic": "C++空类默认有哪些成员函数？"
  },
  {
    "head": "C++空类",
    "relation": "默认包含",
    "tail": "复制构造函数",
    "source_topic": "C++空类默认有哪些成员函数？"
  },
  {
    "head": "C++空类",
    "relation": "默认包含",
    "tail": "赋值函数",
    "source_topic": "C++空类默认有哪些成员函数？"
  },
  {
    "head": "static静态成员变量",
    "relation": "属于",
    "tail": "类级别变量",
    "source_topic": "哪一种成员变量可以在一个类的实例之间共享？"
  },
  {
    "head": "基类析构函数",
    "relation": "导致",
    "tail": "资源泄漏",
    "source_topic": "继承层次中，为什么基类析构函数是虚函数？"
  },
  {
    "head": "基类析构函数",
    "relation": "解决",
    "tail": "调用派生类析构函数",
    "source_topic": "继承层次中，为什么基类析构函数是虚函数？"
  },
  {
    "head": "C++",
    "relation": "处理",
    "tail": "析构函数调用",
    "source_topic": "继承层次中，为什么基类析构函数是虚函数？"
  },
  {
    "head": "构造函数",
    "relation": "不能为",
    "tail": "虚函数",
    "source_topic": "为什么构造函数不能为虚函数？"
  },
  {
    "head": "虚函数",
    "relation": "采用",
    "tail": "虚调用方法",
    "source_topic": "为什么构造函数不能为虚函数？"
  },
  {
    "head": "虚调用",
    "relation": "需要",
    "tail": "准确类型信息",
    "source_topic": "为什么构造函数不能为虚函数？"
  },
  {
    "head": "对象创建",
    "relation": "需要知道",
    "tail": "对象准确类型",
    "source_topic": "为什么构造函数不能为虚函数？"
  },
  {
    "head": "虚函数",
    "relation": "导致",
    "tail": "系统开销",
    "source_topic": "如果虚函数是有效的，那为什么不把所有函数设为虚函数？"
  },
  {
    "head": "虚函数",
    "relation": "需要维护",
    "tail": "虚函数表",
    "source_topic": "如果虚函数是有效的，那为什么不把所有函数设为虚函数？"
  },
  {
    "head": "覆盖",
    "relation": "属于",
    "tail": "面向对象编程",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "重载",
    "relation": "不属于",
    "tail": "面向对象编程",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "覆盖",
    "relation": "实现方式",
    "tail": "虚函数",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "重载",
    "relation": "实现方式",
    "tail": "相同作用域中多个同名函数",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "重载",
    "relation": "确定时机",
    "tail": "编译时",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "覆盖",
    "relation": "确定时机",
    "tail": "运行时",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "重载",
    "relation": "参数差异",
    "tail": "形参表不同",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "覆盖",
    "relation": "参数差异",
    "tail": "参数表相同",
    "source_topic": "重载和覆盖有什么区别？"
  },
  {
    "head": "公有继承",
    "relation": "允许访问",
    "tail": "基类的公有成员",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "公有继承",
    "relation": "允许访问",
    "tail": "基类的受保护成员",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "公有继承",
    "relation": "允许访问",
    "tail": "派生类的成员函数",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "私有继承",
    "relation": "限制访问",
    "tail": "基类的成员",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "私有继承",
    "relation": "仅允许访问",
    "tail": "直接派生类的成员",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "受保护继承",
    "relation": "限制访问",
    "tail": "基类的成员",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "受保护继承",
    "relation": "仅允许访问",
    "tail": "直接派生类的成员",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "公有继承",
    "relation": "限制修改",
    "tail": "基类的受保护成员",
    "source_topic": "公有继承、受保护继承、私有继承"
  },
  {
    "head": "构造函数初始化列表",
    "relation": "适用情况",
    "tail": "const成员",
    "source_topic": "有哪几种情况只能用构造函数初始化列表而不能用赋值初始化？"
  },
  {
    "head": "构造函数初始化列表",
    "relation": "适用情况",
    "tail": "引用成员",
    "source_topic": "有哪几种情况只能用构造函数初始化列表而不能用赋值初始化？"
  },
  {
    "head": "虚指针",
    "relation": "属于",
    "tail": "虚函数的实现细节",
    "source_topic": "什么是虚指针？"
  },
  {
    "head": "虚指针",
    "relation": "指向",
    "tail": "虚函数表",
    "source_topic": "什么是虚指针？"
  },
  {
    "head": "C++",
    "relation": "阻止",
    "tail": "类被实例化",
    "source_topic": "C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"
  },
  {
    "head": "构造函数",
    "relation": "声明为",
    "tail": "private",
    "source_topic": "C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"
  },
  {
    "head": "构造函数",
    "relation": "用于",
    "tail": "限制类外部创建对象",
    "source_topic": "C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"
  },
  {
    "head": "全局对象",
    "relation": "构造函数执行时机",
    "tail": "main函数之前",
    "source_topic": "main函数执行之前会执行什么？执行之后还能执行代码吗？"
  },
  {
    "head": "atexit函数",
    "relation": "调用时机",
    "tail": "在main函数内部调用",
    "source_topic": "main函数执行之前会执行什么？执行之后还能执行代码吗？"
  },
  {
    "head": "main函数",
    "relation": "执行后",
    "tail": "可以执行代码",
    "source_topic": "main函数执行之前会执行什么？执行之后还能执行代码吗？"
  },
  {
    "head": "进程",
    "relation": "属于/分类",
    "tail": "程序的一次执行",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "线程",
    "relation": "属于/分类",
    "tail": "进程中的执行单元",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "进程",
    "relation": "包含/组成",
    "tail": "线程",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "进程",
    "relation": "核心特性",
    "tail": "进程间是独立的",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "进程",
    "relation": "核心特性",
    "tail": "内存空间独立",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "进程",
    "relation": "核心特性",
    "tail": "上下文环境独立",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "线程",
    "relation": "核心特性",
    "tail": "运行在进程中",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "线程",
    "relation": "核心特性",
    "tail": "共享内存空间",
    "source_topic": "请描述进程和线程的区别？"
  },
  {
    "head": "进程间通信",
    "relation": "包含",
    "tail": "信号",
    "source_topic": "进程间如何通信？"
  },
  {
    "head": "进程间通信",
    "relation": "包含",
    "tail": "信号量",
    "source_topic": "进程间如何通信？"
  },
  {
    "head": "进程间通信",
    "relation": "包含",
    "tail": "消息队列",
    "source_topic": "进程间如何通信？"
  },
  {
    "head": "进程间通信",
    "relation": "包含",
    "tail": "共享内存",
    "source_topic": "进程间如何通信？"
  },
  {
    "head": "多进程",
    "relation": "导致",
    "tail": "每个进程都有自己的内存空间",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "多线程",
    "relation": "导致",
    "tail": "多线程间共享内存空间",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "线程",
    "relation": "核心特性",
    "tail": "执行开销小",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "进程",
    "relation": "核心特性",
    "tail": "不利于资源管理和保护",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "线程",
    "relation": "核心特性",
    "tail": "产生的速度快",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "线程",
    "relation": "核心特性",
    "tail": "线程间通信快",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "线程",
    "relation": "核心特性",
    "tail": "切换快",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "线程",
    "relation": "核心特性",
    "tail": "资源利用率比较好",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "多线程",
    "relation": "需要",
    "tail": "同步机制",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "进程",
    "relation": "核心特性",
    "tail": "可跨越机器迁移",
    "source_topic": "在网络编程中涉及并发服务器，使用多进程与多线程的区别？"
  },
  {
    "head": "TCP",
    "relation": "属于",
    "tail": "传输控制协议",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "提供",
    "tail": "面向连接",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "提供",
    "tail": "可靠的字节流服务",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "超时重发",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "丢弃重复数据",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "检验数据",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "包含",
    "tail": "流量控制",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "UDP",
    "relation": "属于",
    "tail": "用户数据报协议",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "UDP",
    "relation": "提供",
    "tail": "面向数据报的传输层协议",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "UDP",
    "relation": "不提供",
    "tail": "可靠性",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "UDP",
    "relation": "采用",
    "tail": "无连接",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "可靠性",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "UDP",
    "relation": "核心特性",
    "tail": "不可靠性",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "核心特性",
    "tail": "面向连接",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "UDP",
    "relation": "核心特性",
    "tail": "无连接",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "负载",
    "tail": "较高",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "采用",
    "tail": "虚电路",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "需要",
    "tail": "建立连接",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "UDP",
    "relation": "不需要",
    "tail": "建立连接",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "发送方确认",
    "tail": "接收方是否收到数据段",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "采用",
    "tail": "3次握手协议",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "采用",
    "tail": "窗口技术",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "TCP",
    "relation": "采用",
    "tail": "流控制",
    "source_topic": "TCP和UDP有什么区别。"
  },
  {
    "head": "栈区",
    "relation": "负责存储",
    "tail": "函数的参数值",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "栈区",
    "relation": "负责存储",
    "tail": "局部变量的值",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "全局区",
    "relation": "负责存储",
    "tail": "全局变量",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "全局区",
    "relation": "负责存储",
    "tail": "静态变量",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "全局区",
    "relation": "初始化的和未初始化的",
    "tail": "分开放",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "文字常量区",
    "relation": "负责存储",
    "tail": "常量字符串",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "文字常量区",
    "relation": "自动释放",
    "tail": "程序结束",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "程序代码区",
    "relation": "存储",
    "tail": "函数体的二进制代码",
    "source_topic": "经常要操作的内存分为那几个类别？"
  },
  {
    "head": "char *p",
    "relation": "位于",
    "tail": "堆栈",
    "source_topic": "全局变量放在数据段，内部变量static int count；"
  },
  {
    "head": "char *p",
    "relation": "指向",
    "tail": "数据段",
    "source_topic": "全局变量放在数据段，内部变量static int count；"
  },
  {
    "head": "char *p",
    "relation": "通过",
    "tail": "new char",
    "source_topic": "全局变量放在数据段，内部变量static int count；"
  },
  {
    "head": "static成员",
    "relation": "优点",
    "tail": "避免名字冲突",
    "source_topic": "类使用static成员的优点，如何访问？"
  },
  {
    "head": "static成员",
    "relation": "优点",
    "tail": "实施封装",
    "source_topic": "类使用static成员的优点，如何访问？"
  },
  {
    "head": "static成员",
    "relation": "优点",
    "tail": "清晰显示程序员意图",
    "source_topic": "类使用static成员的优点，如何访问？"
  },
  {
    "head": "static数据成员",
    "relation": "初始化方式",
    "tail": "类定义体外部定义",
    "source_topic": "类使用static成员的优点，如何访问？"
  },
  {
    "head": "static数据成员",
    "relation": "初始化方式",
    "tail": "定义时初始化",
    "source_topic": "类使用static成员的优点，如何访问？"
  },
  {
    "head": "static数据成员",
    "relation": "访问形式",
    "tail": "类对象名.静态数据成员名",
    "source_topic": "类使用static成员的优点，如何访问？"
  },
  {
    "head": "static数据成员",
    "relation": "访问形式",
    "tail": "类类型名::静态数据成员名",
    "source_topic": "类使用static成员的优点，如何访问？"
  },
  {
    "head": "static数据成员",
    "relation": "独立于",
    "tail": "类的任意对象",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "static数据成员",
    "relation": "不与",
    "tail": "类的对象相关联",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "static数据成员",
    "relation": "初始化方式",
    "tail": "定义时初始化",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "static成员函数",
    "relation": "没有",
    "tail": "this形参",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "static成员函数",
    "relation": "可以直接访问",
    "tail": "所属类的static成员",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "static成员函数",
    "relation": "不能直接使用",
    "tail": "非static成员",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "static成员函数",
    "relation": "不能被声明为",
    "tail": "const",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "static成员函数",
    "relation": "不能被声明为",
    "tail": "虚函数",
    "source_topic": "static数据成员和static成员函数"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "引用头文件",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "extern关键字",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "引用头文件",
    "relation": "错误检测阶段",
    "tail": "编译期间",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "extern关键字",
    "relation": "错误检测阶段",
    "tail": "连接期间",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "static",
    "relation": "改变",
    "tail": "存储形式",
    "source_topic": "static关键字的作用。"
  },
  {
    "head": "static",
    "relation": "改变",
    "tail": "连接方式",
    "source_topic": "static关键字的作用。"
  },
  {
    "head": "static",
    "relation": "作用于",
    "tail": "局部变量",
    "source_topic": "static关键字的作用。"
  },
  {
    "head": "static",
    "relation": "作用于",
    "tail": "全局变量",
    "source_topic": "static关键字的作用。"
  },
  {
    "head": "局部变量",
    "relation": "默认连接方式",
    "tail": "内部连接",
    "source_topic": "static关键字的作用。"
  },
  {
    "head": "全局变量",
    "relation": "默认存储形式",
    "tail": "静态存储",
    "source_topic": "static关键字的作用。"
  },
  {
    "head": "虚函数表",
    "relation": "属于",
    "tail": "编译期建立的结构",
    "source_topic": "多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?"
  },
  {
    "head": "虚函数表",
    "relation": "包含",
    "tail": "虚拟函数的入口地址数组",
    "source_topic": "多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?"
  },
  {
    "head": "虚函数表指针",
    "relation": "初始化时间",
    "tail": "运行期",
    "source_topic": "多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?"
  },
  {
    "head": "虚函数表指针",
    "relation": "初始化时机",
    "tail": "构造函数被调用时",
    "source_topic": "多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?"
  },
  {
    "head": "虚函数表指针",
    "relation": "作用",
    "tail": "实现多态的关键",
    "source_topic": "多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?"
  },
  {
    "head": "子类覆盖函数",
    "relation": "无需",
    "tail": "virtual关键字",
    "source_topic": "一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?"
  },
  {
    "head": "父类",
    "relation": "包含",
    "tail": "virtual函数",
    "source_topic": "一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?"
  },
  {
    "head": "子类",
    "relation": "继承",
    "tail": "父类的变量",
    "source_topic": "一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?"
  },
  {
    "head": "父类的私有变量",
    "relation": "不包含",
    "tail": "子类空间",
    "source_topic": "一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?"
  },
  {
    "head": "strcpy",
    "relation": "操作对象",
    "tail": "字符串",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "sprintf",
    "relation": "操作对象",
    "tail": "字符串",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "sprintf",
    "relation": "操作对象",
    "tail": "任意基本类型的数据",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "操作对象",
    "tail": "内存块",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "strcpy",
    "relation": "使用方便程度",
    "tail": "方便",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "sprintf",
    "relation": "效率",
    "tail": "不高",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "sprintf",
    "relation": "使用方便程度",
    "tail": "麻烦",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "效率",
    "tail": "高效",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "使用方便程度",
    "tail": "不便",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "strcpy",
    "relation": "适用场景",
    "tail": "字符串拷贝",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "适用场景",
    "tail": "结构或数组的拷贝",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "参数需求",
    "tail": "起始地址和内存长度信息",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "strcpy",
    "relation": "参数需求",
    "tail": "源字符串和目的字符串",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "sprintf",
    "relation": "参数需求",
    "tail": "格式符",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "strcpy",
    "relation": "性能",
    "tail": "与 memcpy 相当",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "限制",
    "tail": "需要指定内存长度",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "strcpy",
    "relation": "限制",
    "tail": "仅适用于字符串",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "sprintf",
    "relation": "限制",
    "tail": "需要格式化转换",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "优势",
    "tail": "适用于任意数据类型",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "strcpy",
    "relation": "优势",
    "tail": "调用方便",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "memcpy",
    "relation": "优势",
    "tail": "高效",
    "source_topic": "完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？"
  },
  {
    "head": "进程内存空间",
    "relation": "包含",
    "tail": "代码区",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "进程内存空间",
    "relation": "包含",
    "tail": "静态数据区",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "进程内存空间",
    "relation": "包含",
    "tail": "动态数据区",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "动态数据区",
    "relation": "属于",
    "tail": "堆栈",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "静态数据区",
    "relation": "分配",
    "tail": "全局变量",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "静态数据区",
    "relation": "分配",
    "tail": "静态变量",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "动态数据区",
    "relation": "分配",
    "tail": "本地变量",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "本地变量",
    "relation": "访问方式",
    "tail": "基地址和偏移量",
    "source_topic": "应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "值传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "指针传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "C++函数",
    "relation": "传递方式包含",
    "tail": "引用传递",
    "source_topic": "C++函数中值的传递方式有哪几种?"
  },
  {
    "head": "全局变量初始化",
    "relation": "不属于",
    "tail": "main()函数引起的动作",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例."
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "全局变量初始化",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例."
  },
  {
    "head": "类A",
    "relation": "包含",
    "tail": "构造函数",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例."
  },
  {
    "head": "构造函数",
    "relation": "执行",
    "tail": "全局变量a的初始化",
    "source_topic": "C++里面是不是所有的动作都是main()引起的？如果不是，请举例."
  },
  {
    "head": "const int* a",
    "relation": "等同于",
    "tail": "int const* a",
    "source_topic": "下列哪两个是等同的"
  },
  {
    "head": "内联函数",
    "relation": "进行",
    "tail": "参数类型检查",
    "source_topic": "内联函数在编译时是否做参数类型检查？"
  },
  {
    "head": "全局变量",
    "relation": "生命周期不同",
    "tail": "主程序",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "分配位置",
    "tail": "全局数据区",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "生命周期不同",
    "tail": "局部函数或循环体",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "分配位置",
    "tail": "栈区",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "使用方式不同",
    "tail": "程序各部分均可使用",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "使用方式不同",
    "tail": "局部使用",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "操作系统和编译器",
    "relation": "识别依据",
    "tail": "内存分配位置",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "全局变量",
    "relation": "加载时机",
    "tail": "程序开始运行时",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "局部变量",
    "relation": "加载时机",
    "tail": "函数或循环体运行时",
    "source_topic": "全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"
  },
  {
    "head": "static全局变量",
    "relation": "区别",
    "tail": "普通全局变量",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "static全局变量",
    "relation": "初始化特性",
    "tail": "只初始化一次",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "static全局变量",
    "relation": "作用域限制",
    "tail": "防止在其他文件单元中被引用",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "static局部变量",
    "relation": "区别",
    "tail": "普通局部变量",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "static局部变量",
    "relation": "初始化特性",
    "tail": "只被初始化一次",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "static局部变量",
    "relation": "值保留特性",
    "tail": "下一次依据上一次结果值",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "static函数",
    "relation": "区别",
    "tail": "普通函数",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "static函数",
    "relation": "内存特性",
    "tail": "在内存中只有一份",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "普通函数",
    "relation": "内存特性",
    "tail": "在每个被调用中维持一份拷贝",
    "source_topic": "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "head": "C语言",
    "relation": "实现方式",
    "tail": "宏定义",
    "source_topic": "对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "inline",
    "source_topic": "对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?"
  },
  {
    "head": "排序算法",
    "relation": "要求",
    "tail": "时间复杂度为O(n)",
    "source_topic": "有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。"
  },
  {
    "head": "排序算法",
    "relation": "要求",
    "tail": "空间复杂度为O(1)",
    "source_topic": "有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。"
  },
  {
    "head": "排序算法",
    "relation": "使用",
    "tail": "交换",
    "source_topic": "有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。"
  },
  {
    "head": "交换",
    "relation": "限制",
    "tail": "一次只能交换两个数",
    "source_topic": "有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。"
  },
  {
    "head": "C++",
    "relation": "实现",
    "tail": "排序算法",
    "source_topic": "有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。"
  },
  {
    "head": "数组",
    "relation": "排序",
    "tail": "排序算法",
    "source_topic": "有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。"
  },
  {
    "head": "排序算法",
    "relation": "属于",
    "tail": "全栈技术",
    "source_topic": "有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。"
  },
  {
    "head": "struct s",
    "relation": "内存对齐导致",
    "tail": "sizeof(s) = 8",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "int* a",
    "relation": "评测方式",
    "tail": "sizeof(a) = 4",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "struct bits",
    "relation": "位域规则",
    "tail": "最多相加不大于8位占1个位置",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "char a:8",
    "relation": "位域大小",
    "tail": "占1个位置",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "char b:4",
    "relation": "位域大小",
    "tail": "占1个位置",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "char c:2",
    "relation": "位域大小",
    "tail": "占1个位置",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "char d:3",
    "relation": "位域大小",
    "tail": "占1个位置",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "union V",
    "relation": "包含",
    "tail": "struct X",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "v.c",
    "relation": "赋值",
    "tail": "100",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "class A",
    "relation": "默认占位符",
    "tail": "sizeof(A) = 1",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "class A",
    "relation": "包含",
    "tail": "virtual test()",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "class B",
    "relation": "继承",
    "tail": "class A",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "class B",
    "relation": "包含虚函数",
    "tail": "sizeof(B) = 4",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "DATE",
    "relation": "包含",
    "tail": "long i",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "DATE",
    "relation": "包含",
    "tail": "int k[5]",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "DATE",
    "relation": "包含",
    "tail": "char c",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "DATE",
    "relation": "大小",
    "tail": "20",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "struct data",
    "relation": "包含",
    "tail": "int cat",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "struct data",
    "relation": "包含",
    "tail": "DATE cow",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "struct data",
    "relation": "包含",
    "tail": "double dog",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "struct data",
    "relation": "大小",
    "tail": "32",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "DATE max",
    "relation": "大小",
    "tail": "20",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "malloc",
    "relation": "分配内存",
    "tail": "void *pp",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "sizeof",
    "relation": "限制",
    "tail": "无法检测动态分配的数组大小",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "sizeof",
    "relation": "限制",
    "tail": "无法检测外部数组大小",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "char str[100]",
    "relation": "传递参数",
    "tail": "Func(str)",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "Func",
    "relation": "评测方式",
    "tail": "sizeof(str) = 4",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "外部数组",
    "relation": "传递参数",
    "tail": "sizeof(str) = 4",
    "source_topic": "sizeof相关系列问题, const相关系列问题"
  },
  {
    "head": "memcpy",
    "relation": "实现",
    "tail": "内存拷贝",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "memcpy",
    "relation": "包含",
    "tail": "覆盖情况处理",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "memcpy",
    "relation": "包含",
    "tail": "循环展开",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "循环展开",
    "relation": "目的",
    "tail": "提高执行效率",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "memcpy",
    "relation": "包含",
    "tail": "从源地址复制数据到目标地址",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "memcpy",
    "relation": "使用",
    "tail": "指针操作",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "memcpy",
    "relation": "处理",
    "tail": "内存区域重叠",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "memcpy",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "写函数完成内存的拷贝"
  },
  {
    "head": "reserve",
    "relation": "属于",
    "tail": "链表操作",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "reserve",
    "relation": "实现方式",
    "tail": "迭代反转",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "list_node",
    "relation": "包含",
    "tail": "data",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "list_node",
    "relation": "包含",
    "tail": "next",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "reserve",
    "relation": "处理",
    "tail": "单链表",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "reserve",
    "relation": "使用",
    "tail": "指针操作",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "reserve",
    "relation": "解决",
    "tail": "链表逆序",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "list_node",
    "relation": "属于",
    "tail": "C++结构体",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "reserve",
    "relation": "依赖",
    "tail": "链表头节点",
    "source_topic": "将一个单链表逆序"
  },
  {
    "head": "循环链表",
    "relation": "包含",
    "tail": "节点对换",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "循环链表",
    "relation": "包含",
    "tail": "节点删除",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "双向循环链表",
    "relation": "底层结构",
    "tail": "节点指针",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "单项循环链表",
    "relation": "底层结构",
    "tail": "节点指针",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "节点删除",
    "relation": "实现方式",
    "tail": "指针重定向",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "节点删除",
    "relation": "实现方式",
    "tail": "内存释放",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "双向循环链表",
    "relation": "实现方式",
    "tail": "prev指针",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "双向循环链表",
    "relation": "实现方式",
    "tail": "next指针",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "单项循环链表",
    "relation": "实现方式",
    "tail": "next指针",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "节点删除",
    "relation": "解决",
    "tail": "内存泄漏",
    "source_topic": "循环链表的节点对换和删除。"
  },
  {
    "head": "双向循环链表",
    "relation": "包含",
    "tail": "结点定义",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "结点定义",
    "relation": "属于",
    "tail": "C++结构体",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "双向循环链表",
    "relation": "包含",
    "tail": "data字段",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "双向循环链表",
    "relation": "包含",
    "tail": "front指针",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "双向循环链表",
    "relation": "包含",
    "tail": "next指针",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DeteleNode函数",
    "relation": "参数",
    "tail": "Node *pHeader",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DeteleNode函数",
    "relation": "参数",
    "tail": "DataType Value",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DeteleNode函数",
    "relation": "功能",
    "tail": "删除链表中data值相同的结点",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DE函数",
    "relation": "参数",
    "tail": "Node *pHeadA",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DE函数",
    "relation": "参数",
    "tail": "Node *pHeadB",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DeteleNode函数",
    "relation": "处理",
    "tail": "头指针",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DeteleNode函数",
    "relation": "处理",
    "tail": "结点删除",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DeteleNode函数",
    "relation": "处理",
    "tail": "front指针",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DeteleNode函数",
    "relation": "处理",
    "tail": "next指针",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DE函数",
    "relation": "调用",
    "tail": "DeteleNode函数",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DE函数",
    "relation": "处理",
    "tail": "双向循环链表A",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "DE函数",
    "relation": "处理",
    "tail": "双向循环链表B",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "双向循环链表",
    "relation": "结构",
    "tail": "循环链表",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "双向循环链表",
    "relation": "结构",
    "tail": "双向链表",
    "source_topic": "有双向循环链表结点定义为："
  },
  {
    "head": "线性表",
    "relation": "合并方式",
    "tail": "merge()",
    "source_topic": "线形表a、b为两个有序升序的线形表，编写一程序，使两个有序线形表合并成一个有序升序线形表h；"
  },
  {
    "head": "merge()",
    "relation": "属于",
    "tail": "STL函数",
    "source_topic": "线形表a、b为两个有序升序的线形表，编写一程序，使两个有序线形表合并成一个有序升序线形表h；"
  },
  {
    "head": "static变量",
    "relation": "维持",
    "tail": "函数调用过程中值不变",
    "source_topic": "static有什么用途？（请至少说明两种）"
  },
  {
    "head": "static变量",
    "relation": "限制访问范围",
    "tail": "模块内全局变量",
    "source_topic": "static有什么用途？（请至少说明两种）"
  },
  {
    "head": "static函数",
    "relation": "限制调用范围",
    "tail": "模块内其它函数",
    "source_topic": "static有什么用途？（请至少说明两种）"
  },
  {
    "head": "重载操作符",
    "relation": "使用",
    "tail": "引用",
    "source_topic": "引用与指针有什么区别？"
  },
  {
    "head": "重载操作符",
    "relation": "实现",
    "tail": "串试操作",
    "source_topic": "引用与指针有什么区别？"
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "全局静态存储区",
    "source_topic": "全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"
  },
  {
    "head": "局部变量",
    "relation": "存储位置",
    "tail": "堆栈",
    "source_topic": "全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"
  },
  {
    "head": "static变量",
    "relation": "核心特性",
    "tail": "在程序运行期内一直有效",
    "source_topic": "static变量和static 函数各有什么特点？"
  },
  {
    "head": "static变量",
    "relation": "核心特性",
    "tail": "定义在函数外时在编译单元内可见",
    "source_topic": "static变量和static 函数各有什么特点？"
  },
  {
    "head": "static函数",
    "relation": "核心特性",
    "tail": "在编译单元内可见",
    "source_topic": "static变量和static 函数各有什么特点？"
  },
  {
    "head": "static全局变量",
    "relation": "限制",
    "tail": "其他文件单元中被引用",
    "source_topic": "static全局变量与普通的全局变量有什么区别？"
  },
  {
    "head": "static全局变量",
    "relation": "核心特性",
    "tail": "只初始化一次",
    "source_topic": "static全局变量与普通的全局变量有什么区别？"
  },
  {
    "head": "static函数",
    "relation": "内存分配区别",
    "tail": "普通函数",
    "source_topic": "static函数与普通函数有什么区别："
  },
  {
    "head": "static函数",
    "relation": "内存唯一性",
    "tail": "内存中只有一份",
    "source_topic": "static函数与普通函数有什么区别："
  },
  {
    "head": "普通函数",
    "relation": "内存唯一性",
    "tail": "每个被调用中维持一份拷贝",
    "source_topic": "static函数与普通函数有什么区别："
  },
  {
    "head": "程序的局部变量",
    "relation": "存储位置",
    "tail": "堆栈",
    "source_topic": "static函数与普通函数有什么区别："
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "静态区",
    "source_topic": "static函数与普通函数有什么区别："
  },
  {
    "head": "constructor",
    "relation": "不能声明为",
    "tail": "虚函数",
    "source_topic": "什么函数不能声明为虚函数？"
  },
  {
    "head": "共享内存",
    "relation": "属于",
    "tail": "进程间通信方式",
    "source_topic": "进程间通信的方式有?"
  },
  {
    "head": "管道",
    "relation": "属于",
    "tail": "进程间通信方式",
    "source_topic": "进程间通信的方式有?"
  },
  {
    "head": "Socket",
    "relation": "属于",
    "tail": "进程间通信方式",
    "source_topic": "进程间通信的方式有?"
  },
  {
    "head": "消息队列",
    "relation": "属于",
    "tail": "进程间通信方式",
    "source_topic": "进程间通信的方式有?"
  },
  {
    "head": "DDE",
    "relation": "属于",
    "tail": "进程间通信方式",
    "source_topic": "进程间通信的方式有?"
  },
  {
    "head": "const char *p",
    "relation": "修饰对象",
    "tail": "指针所指向的变量",
    "source_topic": "const 符号常量；"
  },
  {
    "head": "char const *p",
    "relation": "修饰对象",
    "tail": "指针所指向的变量",
    "source_topic": "const 符号常量；"
  },
  {
    "head": "char * const p",
    "relation": "修饰对象",
    "tail": "指针本身",
    "source_topic": "const 符号常量；"
  },
  {
    "head": "const",
    "relation": "位置影响",
    "tail": "星号左侧修饰指针所指向的变量",
    "source_topic": "const 符号常量；"
  },
  {
    "head": "const",
    "relation": "位置影响",
    "tail": "星号右侧修饰指针本身",
    "source_topic": "const 符号常量；"
  },
  {
    "head": "C语言struct",
    "relation": "不包含",
    "tail": "成员函数",
    "source_topic": "c和c++中的struct有什么不同？"
  },
  {
    "head": "C++ struct",
    "relation": "包含",
    "tail": "成员函数",
    "source_topic": "c和c++中的struct有什么不同？"
  },
  {
    "head": "C++ struct",
    "relation": "默认访问权限",
    "tail": "public",
    "source_topic": "c和c++中的struct有什么不同？"
  },
  {
    "head": "C++ class",
    "relation": "默认访问权限",
    "tail": "private",
    "source_topic": "c和c++中的struct有什么不同？"
  },
  {
    "head": "子类",
    "relation": "必须实现",
    "tail": "纯虚函数",
    "source_topic": "纯虚函数如何定义？使用时应注意什么？"
  },
  {
    "head": "数组",
    "relation": "存储方式",
    "tail": "顺序存储",
    "source_topic": "数组和链表的区别"
  },
  {
    "head": "数组",
    "relation": "大小特性",
    "tail": "固定大小",
    "source_topic": "数组和链表的区别"
  },
  {
    "head": "链表",
    "relation": "存储方式",
    "tail": "随机存储",
    "source_topic": "数组和链表的区别"
  },
  {
    "head": "链表",
    "relation": "大小特性",
    "tail": "动态改变",
    "source_topic": "数组和链表的区别"
  },
  {
    "head": "线程",
    "relation": "属于",
    "tail": "进程",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "进程",
    "relation": "包含",
    "tail": "资源集合",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "程序启动",
    "relation": "创建",
    "tail": "主线程",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "线程",
    "relation": "拥有",
    "tail": "独立堆栈",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "DLL",
    "relation": "不拥有",
    "tail": "独立堆栈",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "DLL",
    "relation": "使用",
    "tail": "线程堆栈",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "动态分配内存",
    "relation": "建议",
    "tail": "在DLL中释放",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "内存释放",
    "relation": "可能导致",
    "tail": "程序崩溃",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "内存分配",
    "relation": "执行",
    "tail": "DLL中动态分配",
    "source_topic": "线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?"
  },
  {
    "head": "判断x是否为2的若干次幂",
    "relation": "实现方式",
    "tail": "位运算",
    "source_topic": "一语句实现x是否为2的若干次幂的判断"
  },
  {
    "head": "位运算",
    "relation": "具体操作",
    "tail": "i & (i - 1)",
    "source_topic": "一语句实现x是否为2的若干次幂的判断"
  },
  {
    "head": "i & (i - 1)",
    "relation": "应用领域",
    "tail": "二进制判断",
    "source_topic": "一语句实现x是否为2的若干次幂的判断"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "位运算操作",
    "source_topic": "一语句实现x是否为2的若干次幂的判断"
  },
  {
    "head": "cout",
    "relation": "属于",
    "tail": "C++标准库输出流",
    "source_topic": "一语句实现x是否为2的若干次幂的判断"
  },
  {
    "head": "boolalpha",
    "relation": "属于",
    "tail": "C++标准库流操纵符",
    "source_topic": "一语句实现x是否为2的若干次幂的判断"
  },
  {
    "head": "func1",
    "relation": "是",
    "tail": "虚函数",
    "source_topic": "859.计算结果"
  },
  {
    "head": "func2",
    "relation": "是",
    "tail": "虚函数",
    "source_topic": "859.计算结果"
  },
  {
    "head": "static变量",
    "relation": "保存",
    "tail": "上次结果",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "sum函数",
    "relation": "包含",
    "tail": "static int b=3",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "sum函数",
    "relation": "包含",
    "tail": "auto int c=0",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "sum函数",
    "relation": "执行",
    "tail": "c+=1",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "sum函数",
    "relation": "执行",
    "tail": "b+=2",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "sum函数",
    "relation": "返回",
    "tail": "a+b+c",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "main函数",
    "relation": "包含",
    "tail": "for循环",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "for循环",
    "relation": "执行",
    "tail": "sum(a)",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "sum函数",
    "relation": "调用",
    "tail": "printf",
    "source_topic": "写出程序运行结果"
  },
  {
    "head": "func",
    "relation": "功能",
    "tail": "统计二进制数值中1的个数",
    "source_topic": "求函数返回值，输入x=9999;"
  },
  {
    "head": "x&(x-1)",
    "relation": "原理",
    "tail": "清除最低位的1",
    "source_topic": "求函数返回值，输入x=9999;"
  },
  {
    "head": "循环",
    "relation": "目的",
    "tail": "统计二进制中1的个数",
    "source_topic": "求函数返回值，输入x=9999;"
  },
  {
    "head": "x = x&(x-1)",
    "relation": "作用",
    "tail": "每次循环清除一个1",
    "source_topic": "求函数返回值，输入x=9999;"
  },
  {
    "head": "9999",
    "relation": "二进制表示",
    "tail": "10011100001111",
    "source_topic": "求函数返回值，输入x=9999;"
  },
  {
    "head": "Josephu",
    "relation": "实现方式",
    "tail": "循环链表",
    "source_topic": "用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"
  },
  {
    "head": "Josephu",
    "relation": "使用操作",
    "tail": "取余操作",
    "source_topic": "用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"
  },
  {
    "head": "Josephu",
    "relation": "实现方式",
    "tail": "循环链表",
    "source_topic": "用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"
  },
  {
    "head": "Josephu",
    "relation": "使用操作",
    "tail": "取余操作",
    "source_topic": "用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"
  },
  {
    "head": "vector",
    "relation": "属于",
    "tail": "C++标准库容器",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "pop_heap",
    "relation": "属于",
    "tail": "C++标准库算法",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "push_heap",
    "relation": "属于",
    "tail": "C++标准库算法",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "greater()",
    "relation": "属于",
    "tail": "C++标准库比较函数",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "rand()",
    "relation": "属于",
    "tail": "C++标准库随机函数",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "fixdown",
    "relation": "属于",
    "tail": "堆排序算法操作",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "堆排序算法",
    "relation": "解决",
    "tail": "寻找最大K个元素问题",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "堆区",
    "relation": "属于",
    "tail": "JVM内存",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "vector",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "有10亿个浮点数，求出其中最大的10000个 ,用了标准库的，不让用的话，只能自己写堆函数"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "加减法交换变量",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "异或运算交换变量",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "异或运算交换变量",
    "relation": "优点",
    "tail": "无需第三方变量",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "加减法交换变量",
    "relation": "优点",
    "tail": "无需第三方变量",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "加减法交换变量",
    "relation": "缺点",
    "tail": "可能溢出",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "异或运算交换变量",
    "relation": "缺点",
    "tail": "需要确保变量类型支持异或操作",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "复合赋值交换变量",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "复合赋值交换变量",
    "relation": "优点",
    "tail": "简洁",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "复合赋值交换变量",
    "relation": "缺点",
    "tail": "可能溢出",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "循环输出组合",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "循环输出组合",
    "relation": "用途",
    "tail": "找出所有和为给定整数的组合",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "循环输出组合",
    "relation": "限制条件",
    "tail": "相加的数不能重复",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "使用scanf输入整数",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "使用printf输出结果",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "使用if-else判断奇偶性",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "C++",
    "relation": "实现方式",
    "tail": "使用for循环遍历",
    "source_topic": "在不用第三方参数的情况下，交换两个参数的值 感觉比较:( , bt 而且还是基础题。"
  },
  {
    "head": "find_orderk",
    "relation": "使用",
    "tail": "快速排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "find_orderk",
    "relation": "使用",
    "tail": "堆排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "find_orderk",
    "relation": "使用",
    "tail": "sort_heap",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "find_orderk",
    "relation": "使用",
    "tail": "make_heap",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "find_orderk",
    "relation": "使用",
    "tail": "Pop_heap",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "快速排序",
    "relation": "时间复杂度",
    "tail": "O(nlgn)",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "堆排序",
    "relation": "时间复杂度",
    "tail": "O(nlgn)",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "sort_heap",
    "relation": "属于",
    "tail": "堆排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "make_heap",
    "relation": "属于",
    "tail": "堆排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "Pop_heap",
    "relation": "属于",
    "tail": "堆排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "快速排序",
    "relation": "优于",
    "tail": "冒泡排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "冒泡排序",
    "relation": "时间复杂度",
    "tail": "O(n^2)",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "partial_sort",
    "relation": "实现方式",
    "tail": "堆排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "partial_sort",
    "relation": "优于",
    "tail": "全排序",
    "source_topic": "写一段程序，找出数组中第k大小的数，输出数所在的位置。"
  },
  {
    "head": "1000!",
    "relation": "计算方法",
    "tail": "统计能被5整除的数的个数",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "1000!",
    "relation": "计算方法",
    "tail": "统计能被25整除的数的个数",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "1000!",
    "relation": "计算方法",
    "tail": "统计能被125整除的数的个数",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "1000!",
    "relation": "计算方法",
    "tail": "统计能被625整除的数的个数",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "1000!末尾的零的个数",
    "relation": "等于",
    "tail": "n1+n2+n3+n4",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "find5函数",
    "relation": "功能",
    "tail": "计算一个数能被5整除的次数",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "main函数",
    "relation": "包含",
    "tail": "循环从5到NUM，每次增加5",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "main函数",
    "relation": "包含",
    "tail": "调用find5函数",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "main函数",
    "relation": "包含",
    "tail": "输出结果",
    "source_topic": "求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;"
  },
  {
    "head": "test3",
    "relation": "实现",
    "tail": "二进制输出",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "实现",
    "tail": "十六进制输出",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "使用",
    "tail": "malloc",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "使用",
    "tail": "char数组",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "处理",
    "tail": "long型数值",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "包含",
    "tail": "buffer",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "buffer",
    "relation": "初始化",
    "tail": "0x",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "buffer",
    "relation": "设置",
    "tail": "终止符",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "使用",
    "tail": "循环",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "循环",
    "relation": "处理",
    "tail": "位操作",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "使用",
    "tail": "条件判断",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "条件判断",
    "relation": "处理",
    "tail": "数值范围",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3",
    "relation": "使用",
    "tail": "字符转换",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "字符转换",
    "relation": "处理",
    "tail": "十进制到十六进制",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "字符转换",
    "relation": "处理",
    "tail": "十进制到二进制",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "atoii",
    "relation": "实现",
    "tail": "字符串到整数转换",
    "source_topic": "将一个数字字符串转换为数字.\"1234\" -->1234"
  },
  {
    "head": "test3函数",
    "relation": "实现",
    "tail": "二进制输出",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "实现",
    "tail": "十六进制输出",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "使用",
    "tail": "malloc函数",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "使用",
    "tail": "字符数组",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "处理",
    "tail": "long型数值",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "包含",
    "tail": "buffer初始化",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "包含",
    "tail": "temp指针赋值",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "包含",
    "tail": "循环处理每一位数值",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "test3函数",
    "relation": "包含",
    "tail": "字符转换逻辑",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "字符转换逻辑",
    "relation": "处理",
    "tail": "二进制数值",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "字符转换逻辑",
    "relation": "处理",
    "tail": "十六进制数值",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "字符转换逻辑",
    "relation": "使用",
    "tail": "条件判断",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "字符转换逻辑",
    "relation": "使用",
    "tail": "ASCII码转换",
    "source_topic": "编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列库函数"
  },
  {
    "head": "动态内存",
    "relation": "用于",
    "tail": "存储交集元素",
    "source_topic": "给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存dongtai，并且返回交集个数"
  },
  {
    "head": "数组",
    "relation": "需要",
    "tail": "排序以比较交集",
    "source_topic": "给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存dongtai，并且返回交集个数"
  },
  {
    "head": "set_difference",
    "relation": "属于",
    "tail": "C++标准库函数",
    "source_topic": "给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存dongtai，并且返回交集个数"
  },
  {
    "head": "set_difference",
    "relation": "用于",
    "tail": "计算两个集合的交集",
    "source_topic": "给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存dongtai，并且返回交集个数"
  },
  {
    "head": "set",
    "relation": "属于",
    "tail": "C++标准库容器",
    "source_topic": "给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存dongtai，并且返回交集个数"
  },
  {
    "head": "set",
    "relation": "实现",
    "tail": "基于红黑树",
    "source_topic": "给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存dongtai，并且返回交集个数"
  },
  {
    "head": "部分排序",
    "relation": "时间复杂度",
    "tail": "Nlog10",
    "source_topic": "象搜索的输入信息是一个字符串，统计300万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过255byte,内存使用只有1G,"
  },
  {
    "head": "字符串统计",
    "relation": "限制",
    "tail": "1G内存",
    "source_topic": "象搜索的输入信息是一个字符串，统计300万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过255byte,内存使用只有1G,"
  },
  {
    "head": "字符串",
    "relation": "长度限制",
    "tail": "255字节",
    "source_topic": "象搜索的输入信息是一个字符串，统计300万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过255byte,内存使用只有1G,"
  },
  {
    "head": "优先队列",
    "relation": "实现",
    "tail": "最大堆",
    "source_topic": "象搜索的输入信息是一个字符串，统计300万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过255byte,内存使用只有1G,"
  },
  {
    "head": "最大堆",
    "relation": "维护",
    "tail": "前k个最大元素",
    "source_topic": "象搜索的输入信息是一个字符串，统计300万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过255byte,内存使用只有1G,"
  },
  {
    "head": "队列",
    "relation": "实现方式",
    "tail": "两个栈",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "栈A",
    "relation": "操作",
    "tail": "push新元素",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "栈B",
    "relation": "操作",
    "tail": "pop栈顶元素",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "出队",
    "relation": "依赖",
    "tail": "栈B非空",
    "source_topic": "用两个栈实现一个队列的功能？要求给出算法和思路！"
  },
  {
    "head": "malloc",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "下面的代码有什么问题？"
  },
  {
    "head": "realloc",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "下面的代码有什么问题？"
  },
  {
    "head": "内存泄漏",
    "relation": "解决",
    "tail": "释放分配的内存",
    "source_topic": "下面的代码有什么问题？"
  },
  {
    "head": "C++",
    "relation": "包含",
    "tail": "动态内存管理",
    "source_topic": "下面的代码有什么问题？"
  },
  {
    "head": "动态内存管理",
    "relation": "包含",
    "tail": "malloc",
    "source_topic": "下面的代码有什么问题？"
  },
  {
    "head": "动态内存管理",
    "relation": "包含",
    "tail": "realloc",
    "source_topic": "下面的代码有什么问题？"
  },
  {
    "head": "sscanf",
    "relation": "导致",
    "tail": "未定义行为",
    "source_topic": "下面的代码有什么问题？并请给出正确的写法。"
  },
  {
    "head": "sscanf",
    "relation": "需要",
    "tail": "指定字符串最大长度",
    "source_topic": "下面的代码有什么问题？并请给出正确的写法。"
  },
  {
    "head": "sscanf",
    "relation": "参数",
    "tail": "str",
    "source_topic": "下面的代码有什么问题？并请给出正确的写法。"
  },
  {
    "head": "scanf",
    "relation": "正确用法",
    "tail": "使用指针参数",
    "source_topic": "下面的代码有什么问题？并请给出正确的写法。"
  },
  {
    "head": "sscanf",
    "relation": "区别",
    "tail": "处理字符串长度",
    "source_topic": "下面的代码有什么问题？并请给出正确的写法。"
  },
  {
    "head": "sscanf",
    "relation": "与",
    "tail": "缓冲区溢出",
    "source_topic": "下面的代码有什么问题？并请给出正确的写法。"
  },
  {
    "head": "sscanf",
    "relation": "可能导致",
    "tail": "缓冲区溢出",
    "source_topic": "下面的代码有什么问题？并请给出正确的写法。"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "数组越界",
    "source_topic": "下面代码有什么错误?"
  },
  {
    "head": "char string[10]",
    "relation": "包含",
    "tail": "字符数组",
    "source_topic": "下面代码有什么错误?"
  },
  {
    "head": "char *str1",
    "relation": "指向",
    "tail": "字符串字面量",
    "source_topic": "下面代码有什么错误?"
  },
  {
    "head": "字符串字面量",
    "relation": "存储",
    "tail": "只读内存区域",
    "source_topic": "下面代码有什么错误?"
  },
  {
    "head": "strcpy",
    "relation": "操作",
    "tail": "字符数组",
    "source_topic": "下面代码有什么错误?"
  },
  {
    "head": "字符数组",
    "relation": "长度",
    "tail": "10",
    "source_topic": "下面代码有什么错误?"
  },
  {
    "head": "字符串字面量",
    "relation": "长度",
    "tail": "11",
    "source_topic": "下面代码有什么错误?"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "数组越界",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "str1",
    "relation": "未置",
    "tail": "字符串结束符",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "字符串结束符",
    "relation": "属于",
    "tail": "C语言字符串处理",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "数组越界",
    "relation": "属于",
    "tail": "内存安全问题",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "数组越界",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "strcpy",
    "relation": "依赖",
    "tail": "字符串结束标志",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "字符串结束标志",
    "relation": "定义",
    "tail": "/0",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "strncpy",
    "relation": "解决",
    "tail": "数组越界",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "memcpy",
    "relation": "解决",
    "tail": "数组越界",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "static int",
    "relation": "导致",
    "tail": "不可重入",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "for循环条件",
    "relation": "导致",
    "tail": "无限循环",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "i后++",
    "relation": "导致",
    "tail": "循环条件始终为真",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "MAX_SRM",
    "relation": "等于",
    "tail": "256",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "SRM_no",
    "relation": "最大值",
    "tail": "256",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "函数get_SRM_no",
    "relation": "导致",
    "tail": "永远返回NULL_SRM",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "GetMemory",
    "relation": "导致",
    "tail": "str始终为NULL",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "strcpy",
    "relation": "导致",
    "tail": "程序崩溃",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "str",
    "relation": "未被修改",
    "tail": "Test函数中",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "动态内存分配",
    "relation": "未被传递",
    "tail": "GetMemory函数",
    "source_topic": "下面代码有什么问题?"
  },
  {
    "head": "unsigned char",
    "relation": "取值范围",
    "tail": "0..255",
    "source_topic": "下面这个程序执行后会有什么错误或者效果:"
  },
  {
    "head": "for循环",
    "relation": "导致",
    "tail": "死循环",
    "source_topic": "下面这个程序执行后会有什么错误或者效果:"
  },
  {
    "head": "数组越界访问",
    "relation": "导致",
    "tail": "未定义行为",
    "source_topic": "下面这个程序执行后会有什么错误或者效果:"
  },
  {
    "head": "数组A",
    "relation": "下标范围",
    "tail": "0..MAX-1",
    "source_topic": "下面这个程序执行后会有什么错误或者效果:"
  },
  {
    "head": "死循环",
    "relation": "原因",
    "tail": "i溢出后循环条件始终成立",
    "source_topic": "下面这个程序执行后会有什么错误或者效果:"
  },
  {
    "head": "malloc",
    "relation": "导致",
    "tail": "内存泄漏",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "字符串倒序",
    "relation": "需要",
    "tail": "终止符",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "char* src",
    "relation": "指向",
    "tail": "字符串常量",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "strlen",
    "relation": "返回",
    "tail": "字符串长度",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "指针操作",
    "relation": "需要",
    "tail": "正确初始化",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "指针操作",
    "relation": "需要",
    "tail": "正确释放内存",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "C语言",
    "relation": "使用",
    "tail": "malloc",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "C语言",
    "relation": "使用",
    "tail": "指针操作",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "C语言",
    "relation": "使用",
    "tail": "字符串处理函数",
    "source_topic": "请找出下面代码中的所以错误"
  },
  {
    "head": "三维数组初始化",
    "relation": "导致",
    "tail": "内存页失效",
    "source_topic": "请问下面程序有什么错误?"
  },
  {
    "head": "循环嵌套顺序",
    "relation": "影响",
    "tail": "内存访问效率",
    "source_topic": "请问下面程序有什么错误?"
  },
  {
    "head": "数组访问模式",
    "relation": "导致",
    "tail": "大量内存页失效",
    "source_topic": "请问下面程序有什么错误?"
  },
  {
    "head": "内存页失效",
    "relation": "属于",
    "tail": "内存管理问题",
    "source_topic": "请问下面程序有什么错误?"
  },
  {
    "head": "内存访问效率",
    "relation": "属于",
    "tail": "性能优化范畴",
    "source_topic": "请问下面程序有什么错误?"
  },
  {
    "head": "char",
    "relation": "占用字节数",
    "tail": "1个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "short int",
    "relation": "占用字节数",
    "tail": "2个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "int",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "unsigned int",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "float",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "double",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "long",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "unsigned long",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "long long",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "指针变量",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "char",
    "relation": "占用字节数",
    "tail": "1个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "short int",
    "relation": "占用字节数",
    "tail": "2个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "int",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "unsigned int",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "float",
    "relation": "占用字节数",
    "tail": "4个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "double",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "long",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "unsigned long",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "long long",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "指针变量",
    "relation": "占用字节数",
    "tail": "8个字节",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "64位操作系统",
    "relation": "影响",
    "tail": "指针变量占用字节数",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "64位操作系统",
    "relation": "影响",
    "tail": "long占用字节数",
    "source_topic": "位，64位系统中，各种常用内置数据类型占用的字节数？"
  },
  {
    "head": "野指针",
    "relation": "定义",
    "tail": "未初始化的指针",
    "source_topic": "悬空指针与野指针区别"
  },
  {
    "head": "malloc",
    "relation": "功能",
    "tail": "动态分配内存",
    "source_topic": "悬空指针与野指针区别"
  },
  {
    "head": "free",
    "relation": "功能",
    "tail": "释放动态分配的内存",
    "source_topic": "悬空指针与野指针区别"
  },
  {
    "head": "悬空指针",
    "relation": "解决方法",
    "tail": "将指针设置为NULL",
    "source_topic": "悬空指针与野指针区别"
  },
  {
    "head": "指针",
    "relation": "初始化",
    "tail": "未初始化时成为野指针",
    "source_topic": "悬空指针与野指针区别"
  },
  {
    "head": "vector",
    "relation": "底层结构",
    "tail": "数组",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "map",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "multimap",
    "relation": "底层结构",
    "tail": "红黑树",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "unordered_map",
    "relation": "底层结构",
    "tail": "哈希表",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "不允许重复元素",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "unordered_map",
    "relation": "核心特性",
    "tail": "不允许重复元素",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "multimap",
    "relation": "核心特性",
    "tail": "允许重复元素",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "元素自动有序",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "multimap",
    "relation": "核心特性",
    "tail": "元素自动有序",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "map",
    "relation": "核心特性",
    "tail": "插入、删除效率高",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "multimap",
    "relation": "核心特性",
    "tail": "插入、删除效率高",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "unordered_map",
    "relation": "核心特性",
    "tail": "元素无序",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "unordered_map",
    "relation": "核心特性",
    "tail": "查找效率高",
    "source_topic": "vector、map、multimap底层数据结构"
  },
  {
    "head": "C++内存分区",
    "relation": "包含",
    "tail": "栈区",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "栈区",
    "relation": "存放",
    "tail": "函数参数",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "栈区",
    "relation": "存放",
    "tail": "局部变量",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "栈区",
    "relation": "由系统自动分配释放",
    "tail": "C++内存分区",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "C++内存分区",
    "relation": "包含",
    "tail": "堆区",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "堆区",
    "relation": "由用户通过",
    "tail": "malloc",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "堆区",
    "relation": "由用户通过",
    "tail": "new",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "堆区",
    "relation": "手动释放",
    "tail": "C++内存分区",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "C++内存分区",
    "relation": "包含",
    "tail": "全局/静态区",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "全局/静态区",
    "relation": "存放",
    "tail": "全局变量",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "全局/静态区",
    "relation": "存放",
    "tail": "静态变量",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "全局/静态区",
    "relation": "由系统释放",
    "tail": "程序结束后",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "C++内存分区",
    "relation": "包含",
    "tail": "字符串常量区",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "字符串常量区",
    "relation": "由系统释放",
    "tail": "程序结束后",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "C++内存分区",
    "relation": "包含",
    "tail": "代码区",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "代码区",
    "relation": "存放",
    "tail": "程序的二进制代码",
    "source_topic": "C++的内存分区"
  },
  {
    "head": "结构",
    "relation": "成员存储方式",
    "tail": "所有成员都存在且地址不同",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "联合",
    "relation": "赋值影响",
    "tail": "对一个成员赋值会重写其他成员",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "结构",
    "relation": "赋值影响",
    "tail": "对不同成员赋值互不影响",
    "source_topic": "结构与联合有和区别？"
  },
  {
    "head": "引用传递",
    "relation": "效果相同",
    "tail": "指针传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "避免副本",
    "tail": "一般变量传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "直接操作",
    "tail": "实参变量或对象",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "一般变量传递",
    "relation": "产生副本",
    "tail": "实参变量",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "一般变量传递",
    "relation": "分配存储单元",
    "tail": "形参",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "对象传递",
    "relation": "调用",
    "tail": "拷贝构造函数",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "效率更高",
    "tail": "一般变量传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "节省空间",
    "tail": "一般变量传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "指针传递",
    "relation": "需要运算",
    "tail": "*指针变量名",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "指针传递",
    "relation": "使用复杂",
    "tail": "引用传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "更清晰",
    "tail": "指针传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "引用传递",
    "relation": "更易用",
    "tail": "指针传递",
    "source_topic": "将“引用”作为函数参数有哪些特点？"
  },
  {
    "head": "虚函数",
    "relation": "定义方式",
    "tail": "virtual关键字",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "虚函数",
    "relation": "作用",
    "tail": "提供接口界面",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "虚函数",
    "relation": "允许",
    "tail": "派生类重新定义",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "作用",
    "tail": "为派生类保留函数名字",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "功能",
    "tail": "不能直接调用",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "纯虚函数",
    "relation": "继承后状态",
    "tail": "仍为虚函数",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "定义条件",
    "tail": "至少有一个纯虚函数",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "包含",
    "tail": "纯虚函数",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "包含",
    "tail": "虚函数",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "用途",
    "tail": "作为基类派生其他类",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "限制",
    "tail": "不能直接创建对象实例",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "抽象类",
    "relation": "支持",
    "tail": "运行时多态性",
    "source_topic": "多态，虚函数，纯虚函数"
  },
  {
    "head": "delete",
    "relation": "配套",
    "tail": "new",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "配套",
    "tail": "new[]",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "功能差异",
    "tail": "调用一次析构函数",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "功能差异",
    "tail": "调用每个成员的析构函数",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "释放内存",
    "tail": "数组元素",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "释放内存",
    "tail": "单个对象",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "适用场景",
    "tail": "new[]分配的内存",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "适用场景",
    "tail": "new分配的内存",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "调用",
    "tail": "operator delete",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "new[]",
    "relation": "分配内存",
    "tail": "数组",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "new",
    "relation": "分配内存",
    "tail": "单个对象",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "内建简单数据类型",
    "relation": "功能相同",
    "tail": "delete和delete[]",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "自定义复杂数据类型",
    "relation": "不能互用",
    "tail": "delete和delete[]",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete",
    "relation": "认为指向",
    "tail": "单个对象",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "delete[]",
    "relation": "认为指向",
    "tail": "数组",
    "source_topic": "delete与 delete []区别"
  },
  {
    "head": "new",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "属于",
    "tail": "C++运算符",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "C标准库函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "调用",
    "tail": "析构函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "free",
    "relation": "不调用",
    "tail": "析构函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "不调用",
    "tail": "构造函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "对应",
    "tail": "delete",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "对应",
    "tail": "free",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "用于",
    "tail": "动态内存分配",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "用于",
    "tail": "动态内存释放",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "用于",
    "tail": "动态内存分配",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "free",
    "relation": "用于",
    "tail": "动态内存释放",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "负责",
    "tail": "执行构造函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "负责",
    "tail": "执行析构函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "不负责",
    "tail": "执行构造函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "free",
    "relation": "不负责",
    "tail": "执行析构函数",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "与",
    "tail": "delete",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "malloc",
    "relation": "与",
    "tail": "free",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "new",
    "relation": "不同于",
    "tail": "malloc",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "delete",
    "relation": "不同于",
    "tail": "free",
    "source_topic": "new、delete、malloc、free关系"
  },
  {
    "head": "数组",
    "relation": "核心特性",
    "tail": "元素在内存中连续存放",
    "source_topic": "链表和数组存储线性表的比较"
  },
  {
    "head": "数组",
    "relation": "核心特性",
    "tail": "支持下标直接访问元素",
    "source_topic": "链表和数组存储线性表的比较"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "元素在内存中不连续存放",
    "source_topic": "链表和数组存储线性表的比较"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "动态可伸缩，可增加或删减结点",
    "source_topic": "链表和数组存储线性表的比较"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "插入和删除操作简单",
    "source_topic": "链表和数组存储线性表的比较"
  },
  {
    "head": "数组",
    "relation": "核心特性",
    "tail": "大小固定，无法改变",
    "source_topic": "链表和数组存储线性表的比较"
  },
  {
    "head": "数组",
    "relation": "导致",
    "tail": "插入和删除操作需要移动元素",
    "source_topic": "链表和数组存储线性表的比较"
  },
  {
    "head": "链表",
    "relation": "属于",
    "tail": "存储结构",
    "source_topic": "C语言中链表的特点"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "动态内存分配",
    "source_topic": "C语言中链表的特点"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "可伸缩性",
    "source_topic": "C语言中链表的特点"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "节省内存",
    "source_topic": "C语言中链表的特点"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "逻辑连续性",
    "source_topic": "C语言中链表的特点"
  },
  {
    "head": "链表",
    "relation": "核心特性",
    "tail": "内存不连续性",
    "source_topic": "C语言中链表的特点"
  },
  {
    "head": "链表",
    "relation": "限制",
    "tail": "立即访问",
    "source_topic": "C语言中链表的特点"
  },
  {
    "head": "链表",
    "relation": "属于",
    "tail": "线性表的存储结构",
    "source_topic": "C语言中链表定义及结构"
  },
  {
    "head": "链表",
    "relation": "组成",
    "tail": "结点",
    "source_topic": "C语言中链表定义及结构"
  },
  {
    "head": "结点",
    "relation": "包含",
    "tail": "数据域",
    "source_topic": "C语言中链表定义及结构"
  },
  {
    "head": "结点",
    "relation": "包含",
    "tail": "指针域",
    "source_topic": "C语言中链表定义及结构"
  },
  {
    "head": "指针域",
    "relation": "指向",
    "tail": "后继结点",
    "source_topic": "C语言中链表定义及结构"
  },
  {
    "head": "尾结点",
    "relation": "指针域置为",
    "tail": "NULL",
    "source_topic": "C语言中链表定义及结构"
  },
  {
    "head": "构造函数",
    "relation": "产生",
    "tail": "临时对象",
    "source_topic": "C++中的临时对象"
  },
  {
    "head": "临时对象",
    "relation": "生命期限制",
    "tail": "一条语句的时间",
    "source_topic": "C++中的临时对象"
  },
  {
    "head": "临时对象",
    "relation": "作用域限制",
    "tail": "一条语句中",
    "source_topic": "C++中的临时对象"
  },
  {
    "head": "临时对象",
    "relation": "属于",
    "tail": "C++灰色地带",
    "source_topic": "C++中的临时对象"
  },
  {
    "head": "析构函数",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "C++中的析构函数"
  },
  {
    "head": "析构函数",
    "relation": "功能相反",
    "tail": "构造函数",
    "source_topic": "C++中的析构函数"
  },
  {
    "head": "析构函数",
    "relation": "定义形式",
    "tail": "~ClassName()",
    "source_topic": "C++中的析构函数"
  },
  {
    "head": "析构函数",
    "relation": "调用时机",
    "tail": "对象销毁时自动调用",
    "source_topic": "C++中的析构函数"
  },
  {
    "head": "局部对象",
    "relation": "构造触发时机",
    "tail": "程序执行流到达对象的定义语句",
    "source_topic": "C++中对象的构造的顺序"
  },
  {
    "head": "堆对象",
    "relation": "构造触发时机",
    "tail": "程序执行流到达 new 语句",
    "source_topic": "C++中对象的构造的顺序"
  },
  {
    "head": "new 创建对象",
    "relation": "触发",
    "tail": "构造函数调用",
    "source_topic": "C++中对象的构造的顺序"
  },
  {
    "head": "全局对象",
    "relation": "构造顺序特性",
    "tail": "构造顺序不确定",
    "source_topic": "C++中对象的构造的顺序"
  },
  {
    "head": "全局对象",
    "relation": "构造顺序依赖",
    "tail": "不同编译器的规则",
    "source_topic": "C++中对象的构造的顺序"
  },
  {
    "head": "初始化",
    "relation": "属于",
    "tail": "C++对象创建过程",
    "source_topic": "C++中赋值和初始化的区别"
  },
  {
    "head": "赋值",
    "relation": "属于",
    "tail": "C++对象操作过程",
    "source_topic": "C++中赋值和初始化的区别"
  },
  {
    "head": "初始化列表",
    "relation": "用于",
    "tail": "类成员初始化",
    "source_topic": "C++中赋值和初始化的区别"
  },
  {
    "head": "初始化列表",
    "relation": "执行顺序",
    "tail": "先于构造函数体",
    "source_topic": "C++中赋值和初始化的区别"
  },
  {
    "head": "const成员变量",
    "relation": "必须使用",
    "tail": "初始化列表",
    "source_topic": "C++中赋值和初始化的区别"
  },
  {
    "head": "const成员变量",
    "relation": "特性",
    "tail": "只读变量",
    "source_topic": "C++中赋值和初始化的区别"
  },
  {
    "head": "C++类成员初始化",
    "relation": "包含",
    "tail": "初始化列表",
    "source_topic": "C++类成员的初始化"
  },
  {
    "head": "初始化列表",
    "relation": "用于",
    "tail": "对成员变量进行初始化",
    "source_topic": "C++类成员的初始化"
  },
  {
    "head": "C++类成员初始化",
    "relation": "包含",
    "tail": "语法规则",
    "source_topic": "C++类成员的初始化"
  },
  {
    "head": "C++类成员初始化",
    "relation": "包含",
    "tail": "注意事项",
    "source_topic": "C++类成员的初始化"
  },
  {
    "head": "C++",
    "relation": "需要深拷贝",
    "tail": "对象中有成员指代了系统中的资源",
    "source_topic": "C++什么时候需要进行深拷贝"
  },
  {
    "head": "C++",
    "relation": "需要深拷贝",
    "tail": "成员指向了动态内存空间",
    "source_topic": "C++什么时候需要进行深拷贝"
  },
  {
    "head": "C++",
    "relation": "需要深拷贝",
    "tail": "成员打开了外存中的文件",
    "source_topic": "C++什么时候需要进行深拷贝"
  },
  {
    "head": "C++",
    "relation": "需要深拷贝",
    "tail": "成员使用了系统中的网络端口",
    "source_topic": "C++什么时候需要进行深拷贝"
  },
  {
    "head": "自定义拷贝构造函数",
    "relation": "必然需要实现",
    "tail": "深拷贝",
    "source_topic": "C++什么时候需要进行深拷贝"
  },
  {
    "head": "拷贝构造函数",
    "relation": "兼容",
    "tail": "C语言初始化方式",
    "source_topic": "拷贝构造函数的意义"
  },
  {
    "head": "拷贝构造函数",
    "relation": "初始化",
    "tail": "新对象",
    "source_topic": "拷贝构造函数的意义"
  },
  {
    "head": "初始化",
    "relation": "区别于",
    "tail": "赋值",
    "source_topic": "拷贝构造函数的意义"
  },
  {
    "head": "赋值",
    "relation": "使用运算符",
    "tail": "=\"",
    "source_topic": "拷贝构造函数的意义"
  },
  {
    "head": "拷贝构造函数",
    "relation": "保证",
    "tail": "初始化行为符合预期逻辑",
    "source_topic": "拷贝构造函数的意义"
  },
  {
    "head": "对象定义",
    "relation": "调用",
    "tail": "构造函数",
    "source_topic": "C++中对象的声明和定义"
  },
  {
    "head": "对象声明",
    "relation": "不调用",
    "tail": "构造函数",
    "source_topic": "C++中对象的声明和定义"
  },
  {
    "head": "对象定义",
    "relation": "申请",
    "tail": "对象的空间",
    "source_topic": "C++中对象的声明和定义"
  },
  {
    "head": "对象声明",
    "relation": "告知",
    "tail": "编译器",
    "source_topic": "C++中对象的声明和定义"
  },
  {
    "head": "C++构造函数",
    "relation": "支持",
    "tail": "参数定义",
    "source_topic": "C++中带参数的构造函数"
  },
  {
    "head": "C++构造函数",
    "relation": "允许",
    "tail": "重载",
    "source_topic": "C++中带参数的构造函数"
  },
  {
    "head": "C++构造函数重载",
    "relation": "遵循",
    "tail": "C++重载规则",
    "source_topic": "C++中带参数的构造函数"
  },
  {
    "head": "构造函数",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "C++中的构造函数"
  },
  {
    "head": "构造函数",
    "relation": "没有返回类型",
    "tail": "C++",
    "source_topic": "C++中的构造函数"
  },
  {
    "head": "构造函数",
    "relation": "自动调用",
    "tail": "对象定义",
    "source_topic": "C++中的构造函数"
  },
  {
    "head": "C++对象",
    "relation": "初始化为",
    "tail": "随机值",
    "source_topic": "C++对象初始化"
  },
  {
    "head": "C++对象",
    "relation": "初始化为",
    "tail": "0值",
    "source_topic": "C++对象初始化"
  },
  {
    "head": "静态存储区创建对象",
    "relation": "初始化为",
    "tail": "0值",
    "source_topic": "C++对象初始化"
  },
  {
    "head": "栈上创建对象",
    "relation": "初始化为",
    "tail": "随机值",
    "source_topic": "C++对象初始化"
  },
  {
    "head": "堆上创建对象",
    "relation": "初始化为",
    "tail": "随机值",
    "source_topic": "C++对象初始化"
  },
  {
    "head": "C++面向对象",
    "relation": "引入",
    "tail": "日常生活中习惯的思维方式",
    "source_topic": "C++面向对象的意义"
  },
  {
    "head": "C++面向对象",
    "relation": "映射",
    "tail": "需求中的概念",
    "source_topic": "C++面向对象的意义"
  },
  {
    "head": "C++面向对象",
    "relation": "构建",
    "tail": "可复用的软件系统",
    "source_topic": "C++面向对象的意义"
  },
  {
    "head": "C++面向对象",
    "relation": "提高",
    "tail": "软件产品的可维护性和可扩展性",
    "source_topic": "C++面向对象的意义"
  },
  {
    "head": "子类",
    "relation": "继承",
    "tail": "父类",
    "source_topic": "C++中类之间的基本关系"
  },
  {
    "head": "组合的类",
    "relation": "依赖",
    "tail": "其它的类",
    "source_topic": "C++中类之间的基本关系"
  },
  {
    "head": "组合的类",
    "relation": "组成",
    "tail": "其它的类",
    "source_topic": "C++中类之间的基本关系"
  },
  {
    "head": "C++类成员",
    "relation": "作用域限制",
    "tail": "类的内部",
    "source_topic": "C++中类成员的作用域"
  },
  {
    "head": "成员函数",
    "relation": "可直接访问",
    "tail": "成员变量",
    "source_topic": "C++中类成员的作用域"
  },
  {
    "head": "类的外部",
    "relation": "可访问",
    "tail": "public成员",
    "source_topic": "C++中类成员的作用域"
  },
  {
    "head": "C++类成员",
    "relation": "与访问级别无关",
    "tail": "作用域",
    "source_topic": "C++中类成员的作用域"
  },
  {
    "head": "struct定义的类",
    "relation": "默认访问级别",
    "tail": "public",
    "source_topic": "C++中类成员的作用域"
  },
  {
    "head": "class定义的类",
    "relation": "默认访问级别",
    "tail": "private",
    "source_topic": "C++中类成员的作用域"
  },
  {
    "head": "struct",
    "relation": "兼容",
    "tail": "C语言",
    "source_topic": "C++中类的关键字"
  },
  {
    "head": "class",
    "relation": "用于",
    "tail": "类定义",
    "source_topic": "C++中类的关键字"
  },
  {
    "head": "struct",
    "relation": "默认访问级别",
    "tail": "public",
    "source_topic": "C++中类的关键字"
  },
  {
    "head": "class",
    "relation": "默认访问级别",
    "tail": "private",
    "source_topic": "C++中类的关键字"
  },
  {
    "head": "struct",
    "relation": "用法相同",
    "tail": "class",
    "source_topic": "C++中类的关键字"
  },
  {
    "head": "C++类声明",
    "relation": "分离实现",
    "tail": "C++类实现",
    "source_topic": "C++中类声明和实现的分离"
  },
  {
    "head": "C++类声明",
    "relation": "包含",
    "tail": "成员变量",
    "source_topic": "C++中类声明和实现的分离"
  },
  {
    "head": "C++类声明",
    "relation": "包含",
    "tail": "成员函数",
    "source_topic": "C++中类声明和实现的分离"
  },
  {
    "head": "C++类实现",
    "relation": "完成",
    "tail": "成员函数的实现",
    "source_topic": "C++中类声明和实现的分离"
  },
  {
    "head": "C语言",
    "relation": "具有",
    "tail": "全局作用域",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "C语言",
    "relation": "导致",
    "tail": "标识符冲突",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "C++",
    "relation": "提出",
    "tail": "命名空间",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "命名空间",
    "relation": "解决",
    "tail": "名称冲突问题",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "命名空间",
    "relation": "划分",
    "tail": "全局作用域",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "命名空间",
    "relation": "允许",
    "tail": "标识符同名",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "命名空间",
    "relation": "支持",
    "tail": "嵌套",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "全局作用域",
    "relation": "称为",
    "tail": "默认命名空间",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "使用默认命名空间中的变量",
    "relation": "方法",
    "tail": "::variable",
    "source_topic": "C++中的命名空间"
  },
  {
    "head": "C++编译器",
    "relation": "兼容",
    "tail": "C语言编译方式",
    "source_topic": "C和C++相互调用"
  },
  {
    "head": "C++编译器",
    "relation": "优先使用",
    "tail": "C++编译方式",
    "source_topic": "C和C++相互调用"
  },
  {
    "head": "extern关键字",
    "relation": "强制",
    "tail": "C++编译器使用C方式编译",
    "source_topic": "C和C++相互调用"
  },
  {
    "head": "函数重载",
    "relation": "定义",
    "tail": "用同一个函数名定义不同的函数",
    "source_topic": "函数重载的定义、条件、注意事项"
  },
  {
    "head": "函数重载",
    "relation": "条件",
    "tail": "参数个数不同",
    "source_topic": "函数重载的定义、条件、注意事项"
  },
  {
    "head": "函数重载",
    "relation": "条件",
    "tail": "参数类型不同",
    "source_topic": "函数重载的定义、条件、注意事项"
  },
  {
    "head": "函数重载",
    "relation": "条件",
    "tail": "参数顺序不同",
    "source_topic": "函数重载的定义、条件、注意事项"
  },
  {
    "head": "重载函数",
    "relation": "本质",
    "tail": "相互独立的不同函数",
    "source_topic": "函数重载的定义、条件、注意事项"
  },
  {
    "head": "重载函数",
    "relation": "特性",
    "tail": "函数类型不同",
    "source_topic": "函数重载的定义、条件、注意事项"
  },
  {
    "head": "函数重载",
    "relation": "决定因素",
    "tail": "函数名和参数列表",
    "source_topic": "函数重载的定义、条件、注意事项"
  },
  {
    "head": "inline",
    "relation": "限制",
    "tail": "递归调用的函数",
    "source_topic": "C++中 inline 内联编译的限制"
  },
  {
    "head": "inline",
    "relation": "限制",
    "tail": "使用复杂流程控制语句的函数",
    "source_topic": "C++中 inline 内联编译的限制"
  },
  {
    "head": "inline",
    "relation": "限制",
    "tail": "函数体过于庞大的函数",
    "source_topic": "C++中 inline 内联编译的限制"
  },
  {
    "head": "inline",
    "relation": "限制",
    "tail": "对函数进行取址操作",
    "source_topic": "C++中 inline 内联编译的限制"
  },
  {
    "head": "inline",
    "relation": "限制",
    "tail": "函数内联声明在调用语句之后",
    "source_topic": "C++中 inline 内联编译的限制"
  },
  {
    "head": "内联函数",
    "relation": "声明方式",
    "tail": "inline 关键字",
    "source_topic": "内联函数的定义和特点"
  },
  {
    "head": "inline 关键字",
    "relation": "必须结合",
    "tail": "函数定义",
    "source_topic": "内联函数的定义和特点"
  },
  {
    "head": "内联函数",
    "relation": "特点",
    "tail": "没有普通函数调用时的额外开销",
    "source_topic": "内联函数的定义和特点"
  },
  {
    "head": "内联函数",
    "relation": "推荐替代",
    "tail": "宏代码片段",
    "source_topic": "内联函数的定义和特点"
  },
  {
    "head": "C++编译器",
    "relation": "不一定满足",
    "tail": "函数的内联请求",
    "source_topic": "内联函数的定义和特点"
  },
  {
    "head": "C++引用",
    "relation": "代替",
    "tail": "指针",
    "source_topic": "C++引用的意义"
  },
  {
    "head": "C++引用",
    "relation": "解决",
    "tail": "指针操作不当导致的内存错误",
    "source_topic": "C++引用的意义"
  },
  {
    "head": "C++引用",
    "relation": "具有",
    "tail": "简单易用的操作性",
    "source_topic": "C++引用的意义"
  },
  {
    "head": "C++引用",
    "relation": "具有",
    "tail": "功能强大的特性",
    "source_topic": "C++引用的意义"
  },
  {
    "head": "C++引用",
    "relation": "内部实现",
    "tail": "常量指针",
    "source_topic": "C++引用的本质"
  },
  {
    "head": "C++引用",
    "relation": "占用空间大小",
    "tail": "指针",
    "source_topic": "C++引用的本质"
  },
  {
    "head": "C++引用",
    "relation": "编译转换",
    "tail": "int* const a",
    "source_topic": "C++引用的本质"
  },
  {
    "head": "C++引用",
    "relation": "使用转换",
    "tail": "*a",
    "source_topic": "C++引用的本质"
  },
  {
    "head": "C++引用",
    "relation": "隐藏细节",
    "tail": "存储空间",
    "source_topic": "C++引用的本质"
  },
  {
    "head": "const引用",
    "relation": "属于",
    "tail": "C++",
    "source_topic": "C++中特殊的引用--const引用"
  },
  {
    "head": "const引用",
    "relation": "核心特性",
    "tail": "只读属性",
    "source_topic": "C++中特殊的引用--const引用"
  },
  {
    "head": "const引用",
    "relation": "导致",
    "tail": "只读变量生成",
    "source_topic": "C++中特殊的引用--const引用"
  },
  {
    "head": "const引用初始化",
    "relation": "包含",
    "tail": "常量值分配空间",
    "source_topic": "C++中特殊的引用--const引用"
  },
  {
    "head": "const引用初始化",
    "relation": "包含",
    "tail": "引用名作为别名",
    "source_topic": "C++中特殊的引用--const引用"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "register关键字",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "C++编译器",
    "relation": "优化方式",
    "tail": "内存存储",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "C语言编译器",
    "relation": "优化方式",
    "tail": "无优化",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "C语言",
    "relation": "允许",
    "tail": "重复定义同名全局变量",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "C++",
    "relation": "禁止",
    "tail": "重复定义同名全局变量",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "register关键字",
    "relation": "兼容性",
    "tail": "C语言",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "register关键字",
    "relation": "存在原因",
    "tail": "兼容C语言",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "C++",
    "relation": "不推荐使用",
    "tail": "register关键字",
    "source_topic": "C 到 C++ 的升级（至少列出三点）"
  },
  {
    "head": "三目运算符",
    "relation": "返回",
    "tail": "变量的值",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "C语言",
    "relation": "定义",
    "tail": "三目运算符返回的是变量的值",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "C++语言",
    "relation": "定义",
    "tail": "三目运算符返回变量的引用",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "C++三目运算符",
    "relation": "行为",
    "tail": "返回变量的值",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "C++三目运算符",
    "relation": "条件",
    "tail": "如果?后面的两个操作数都是变量",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "C++三目运算符",
    "relation": "行为",
    "tail": "返回变量的引用",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "三目运算符",
    "relation": "允许作为",
    "tail": "右值",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "三目运算符",
    "relation": "允许作为",
    "tail": "左值",
    "source_topic": "C和C++语言中的三目运算符"
  },
  {
    "head": "顺序点",
    "relation": "包含",
    "tail": "完整表达式结束时",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "完整表达式结束时",
    "relation": "位于",
    "tail": "分号处",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "顺序点",
    "relation": "包含",
    "tail": "逻辑与运算符",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "顺序点",
    "relation": "包含",
    "tail": "逻辑或运算符",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "顺序点",
    "relation": "包含",
    "tail": "条件运算符",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "顺序点",
    "relation": "包含",
    "tail": "逗号表达式",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "顺序点",
    "relation": "包含",
    "tail": "函数调用",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "函数调用",
    "relation": "触发",
    "tail": "实参求值完成",
    "source_topic": "C 语言中的顺序点"
  },
  {
    "head": "函数参数",
    "relation": "属于",
    "tail": "局部变量",
    "source_topic": "C/C++语言中的函数参数"
  },
  {
    "head": "函数参数",
    "relation": "初始值",
    "tail": "实参值",
    "source_topic": "C/C++语言中的函数参数"
  },
  {
    "head": "函数参数的求值顺序",
    "relation": "依赖",
    "tail": "编译器实现",
    "source_topic": "C/C++语言中的函数参数"
  },
  {
    "head": "声明",
    "relation": "表达",
    "tail": "程序单元的存在",
    "source_topic": "声明和定义"
  },
  {
    "head": "定义",
    "relation": "表达",
    "tail": "程序单元的意义",
    "source_topic": "声明和定义"
  },
  {
    "head": "C语言",
    "relation": "使用",
    "tail": "extern进行程序单元的声明",
    "source_topic": "声明和定义"
  },
  {
    "head": "结构体",
    "relation": "允许",
    "tail": "声明时省略extern",
    "source_topic": "声明和定义"
  },
  {
    "head": "声明",
    "relation": "与",
    "tail": "定义不同",
    "source_topic": "声明和定义"
  },
  {
    "head": "动态内存申请",
    "relation": "需要检查",
    "tail": "指针是否为NULL",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "free指针",
    "relation": "必须赋值",
    "tail": "NULL",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "内存操作函数",
    "relation": "必须带",
    "tail": "长度信息",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "malloc操作",
    "relation": "必须匹配",
    "tail": "free操作",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "内存泄漏",
    "relation": "源于",
    "tail": "malloc和free不匹配",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "内存错误",
    "relation": "源于",
    "tail": "指针保存非法地址",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "指针保存非法地址",
    "relation": "包括",
    "tail": "未初始化指针",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "指针保存非法地址",
    "relation": "包括",
    "tail": "指针运算越界",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "内存泄漏",
    "relation": "导致",
    "tail": "程序内存消耗增加",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "多次释放",
    "relation": "导致",
    "tail": "程序崩溃",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "谁申请",
    "relation": "谁释放",
    "tail": "内存操作原则",
    "source_topic": "C/C++语言中内存操作的交通规则"
  },
  {
    "head": "结构体成员指针未初始化",
    "relation": "导致",
    "tail": "内存错误",
    "source_topic": "C/C++语言中常见的内存错误"
  },
  {
    "head": "结构体成员指针未分配足够的内存",
    "relation": "导致",
    "tail": "内存错误",
    "source_topic": "C/C++语言中常见的内存错误"
  },
  {
    "head": "内存分配成功但未初始化",
    "relation": "导致",
    "tail": "内存错误",
    "source_topic": "C/C++语言中常见的内存错误"
  },
  {
    "head": "内存操作越界",
    "relation": "导致",
    "tail": "内存错误",
    "source_topic": "C/C++语言中常见的内存错误"
  },
  {
    "head": "字符数组",
    "relation": "必须确认",
    "tail": "0 结束符",
    "source_topic": "内存操作的基本原则"
  },
  {
    "head": "内存操作相关函数",
    "relation": "必须指定",
    "tail": "长度信息",
    "source_topic": "内存操作的基本原则"
  },
  {
    "head": "野指针",
    "relation": "定义",
    "tail": "指针变量中的值是非法的内存地址",
    "source_topic": "C/C++语言中野指针的含义"
  },
  {
    "head": "野指针",
    "relation": "区别",
    "tail": "不是 NULL 指针",
    "source_topic": "C/C++语言中野指针的含义"
  },
  {
    "head": "野指针",
    "relation": "指向",
    "tail": "不可用内存地址",
    "source_topic": "C/C++语言中野指针的含义"
  },
  {
    "head": "NULL 指针",
    "relation": "特性",
    "tail": "并无危害",
    "source_topic": "C/C++语言中野指针的含义"
  },
  {
    "head": "NULL 指针",
    "relation": "特性",
    "tail": "很好判断",
    "source_topic": "C/C++语言中野指针的含义"
  },
  {
    "head": "NULL 指针",
    "relation": "特性",
    "tail": "很好调试",
    "source_topic": "C/C++语言中野指针的含义"
  },
  {
    "head": "堆栈段",
    "relation": "属于",
    "tail": "程序运行的基础",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "bss段",
    "relation": "存放",
    "tail": "未初始化的全局变量和静态变量",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "text段",
    "relation": "存放",
    "tail": "程序中的可执行代码",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "data段",
    "relation": "保存",
    "tail": "已经初始化的全局变量和静态变量",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "rodata段",
    "relation": "存放",
    "tail": "程序中的常量值",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "静态存储区",
    "relation": "指代",
    "tail": "bss段和data段",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "只读存储区",
    "relation": "指代",
    "tail": "rodata段",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "局部变量",
    "relation": "占用空间",
    "tail": "栈上的空间",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "动态空间",
    "relation": "属于",
    "tail": "堆中的空间",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "程序可执行代码",
    "relation": "存放于",
    "tail": "text段",
    "source_topic": "C/C++语言中文件布局在内存中的映射"
  },
  {
    "head": "进程",
    "relation": "属于",
    "tail": "动态概念",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "进程",
    "relation": "对应",
    "tail": "一个程序",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "脚本文件",
    "relation": "属于",
    "tail": "可执行程序",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "脚本文件",
    "relation": "需要",
    "tail": "脚本解释程序",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "操作系统",
    "relation": "加载",
    "tail": "脚本解释程序",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "脚本解释程序",
    "relation": "生成",
    "tail": "进程",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "进程",
    "relation": "执行",
    "tail": "脚本代码",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "进程",
    "relation": "功能依赖",
    "tail": "脚本文本内容",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "脚本文件",
    "relation": "与",
    "tail": "脚本解释程序",
    "source_topic": "C/C++语言中程序与进程"
  },
  {
    "head": "静态存储区",
    "relation": "分配时机",
    "tail": "程序运行时",
    "source_topic": "C/C++程序中的静态存储区"
  },
  {
    "head": "静态存储区",
    "relation": "生命周期",
    "tail": "直到程序运行结束",
    "source_topic": "C/C++程序中的静态存储区"
  },
  {
    "head": "静态存储区",
    "relation": "确定大小时机",
    "tail": "编译期",
    "source_topic": "C/C++程序中的静态存储区"
  },
  {
    "head": "静态存储区",
    "relation": "主要用途",
    "tail": "保存全局变量和静态局部变量",
    "source_topic": "C/C++程序中的静态存储区"
  },
  {
    "head": "静态存储区",
    "relation": "信息保存方式",
    "tail": "保存到可执行程序中",
    "source_topic": "C/C++程序中的静态存储区"
  },
  {
    "head": "函数调用上下文",
    "relation": "包含",
    "tail": "参数和局部变量",
    "source_topic": "C/C++程序中的栈"
  },
  {
    "head": "函数调用",
    "relation": "对应",
    "tail": "栈上的活动记录",
    "source_topic": "C/C++程序中的栈"
  },
  {
    "head": "调用函数的活动记录",
    "relation": "位于",
    "tail": "栈的中部",
    "source_topic": "C/C++程序中的栈"
  },
  {
    "head": "被调用函数的活动记录",
    "relation": "位于",
    "tail": "栈的顶部",
    "source_topic": "C/C++程序中的栈"
  },
  {
    "head": "栈空间",
    "relation": "在函数返回前",
    "tail": "专用",
    "source_topic": "C/C++程序中的栈"
  },
  {
    "head": "栈空间",
    "relation": "在函数调用结束后",
    "tail": "被释放",
    "source_topic": "C/C++程序中的栈"
  },
  {
    "head": "calloc",
    "relation": "属于",
    "tail": "C语言内存分配函数",
    "source_topic": "C语言中calloc 和 realloc 函数"
  },
  {
    "head": "realloc",
    "relation": "属于",
    "tail": "C语言内存分配函数",
    "source_topic": "C语言中calloc 和 realloc 函数"
  },
  {
    "head": "malloc",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "free",
    "relation": "属于",
    "tail": "库函数",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "用于",
    "tail": "动态内存分配",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "free",
    "relation": "用于",
    "tail": "动态内存释放",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "分配",
    "tail": "连续内存",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "以字节为单位",
    "tail": "分配内存",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "返回值类型",
    "tail": "void*",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "free",
    "relation": "参数类型",
    "tail": "void*",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "_msize",
    "relation": "参数类型",
    "tail": "void*",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "可能分配",
    "tail": "比请求更多的内存",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "不能依赖",
    "tail": "不同平台下的行为",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "返回",
    "tail": "NULL 当无法满足内存请求",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "free",
    "relation": "处理",
    "tail": "NULL 参数直接返回",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "malloc",
    "relation": "不是",
    "tail": "系统调用",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "free",
    "relation": "不是",
    "tail": "系统调用",
    "source_topic": "malloc和free函数及使用过程需要注意的地方"
  },
  {
    "head": "数组",
    "relation": "属于",
    "tail": "内存的别名",
    "source_topic": "C语言中动态内存分配"
  },
  {
    "head": "内存分配",
    "relation": "由",
    "tail": "编译器",
    "source_topic": "C语言中动态内存分配"
  },
  {
    "head": "内存分配",
    "relation": "在",
    "tail": "编译期间决定",
    "source_topic": "C语言中动态内存分配"
  },
  {
    "head": "数组",
    "relation": "必须指定",
    "tail": "数组长度",
    "source_topic": "C语言中动态内存分配"
  },
  {
    "head": "数组长度",
    "relation": "在编译期确定",
    "tail": "必须",
    "source_topic": "C语言中动态内存分配"
  },
  {
    "head": "程序运行",
    "relation": "可能需要",
    "tail": "额外内存空间",
    "source_topic": "C语言中动态内存分配"
  },
  {
    "head": "C语言指针阅读",
    "relation": "使用技巧",
    "tail": "右左法则",
    "source_topic": "C语言中的指针阅读技巧"
  },
  {
    "head": "右左法则",
    "relation": "步骤",
    "tail": "首先往右看,再往左看",
    "source_topic": "C语言中的指针阅读技巧"
  },
  {
    "head": "函数名",
    "relation": "是",
    "tail": "执行函数体的入口地址",
    "source_topic": "C语言中的函数指针"
  },
  {
    "head": "函数指针",
    "relation": "定义方法",
    "tail": "通过函数类型定义",
    "source_topic": "C语言中的函数指针"
  },
  {
    "head": "函数指针",
    "relation": "定义方法",
    "tail": "直接定义",
    "source_topic": "C语言中的函数指针"
  },
  {
    "head": "type",
    "relation": "为",
    "tail": "返回值类型",
    "source_topic": "C语言中的函数指针"
  },
  {
    "head": "pointer",
    "relation": "为",
    "tail": "函数指针变量名",
    "source_topic": "C语言中的函数指针"
  },
  {
    "head": "parameter list",
    "relation": "为",
    "tail": "参数类型列表",
    "source_topic": "C语言中的函数指针"
  },
  {
    "head": "指针",
    "relation": "占用",
    "tail": "内存空间",
    "source_topic": "C语言中指向指针的指针"
  },
  {
    "head": "指针的指针",
    "relation": "保存",
    "tail": "指针变量的地址值",
    "source_topic": "C语言中指向指针的指针"
  },
  {
    "head": "指针",
    "relation": "存在",
    "tail": "传值调用",
    "source_topic": "C语言中指向指针的指针"
  },
  {
    "head": "指针",
    "relation": "存在",
    "tail": "传址调用",
    "source_topic": "C语言中指向指针的指针"
  },
  {
    "head": "数组指针",
    "relation": "用于指向",
    "tail": "数组",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "数组名",
    "relation": "是",
    "tail": "数组首元素的起始地址",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "数组名",
    "relation": "不是",
    "tail": "数组的起始地址",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "数组指针",
    "relation": "定义方式",
    "tail": "数组类型定义数组指针",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "数组指针",
    "relation": "定义方式",
    "tail": "直接定义",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "指针数组",
    "relation": "属于",
    "tail": "普通数组",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "指针数组",
    "relation": "组成",
    "tail": "指针元素",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "指针数组",
    "relation": "定义格式",
    "tail": "type* pArray[n]",
    "source_topic": "C语言中的数组指针和指针数组"
  },
  {
    "head": "C语言字符串相等比较",
    "relation": "需要使用",
    "tail": "strcmp",
    "source_topic": "C语言中字符串相等的比较"
  },
  {
    "head": "C语言字符串相等比较",
    "relation": "不可直接使用",
    "tail": "==",
    "source_topic": "C语言中字符串相等的比较"
  },
  {
    "head": "字符串字面量",
    "relation": "本质",
    "tail": "字符数组",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "字符串字面量",
    "relation": "存储位置",
    "tail": "全局只读存储区",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "字符串字面量",
    "relation": "自动添加",
    "tail": "'\\0'字符",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "字符串字面量",
    "relation": "可以视为",
    "tail": "常量指针",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "字符串字面量",
    "relation": "包含",
    "tail": "'\\0'",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "C语言",
    "relation": "不包含",
    "tail": "字符串数据类型",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "C语言",
    "relation": "模拟",
    "tail": "字符串",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "字符串",
    "relation": "定义",
    "tail": "有序字符的集合",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "字符串字面量",
    "relation": "不可修改",
    "tail": "字符",
    "source_topic": "C语言中的字符串和字符数组"
  },
  {
    "head": "数组参数",
    "relation": "底层结构",
    "tail": "指针",
    "source_topic": "数组参数"
  },
  {
    "head": "数组参数",
    "relation": "导致",
    "tail": "丢失数组长度信息",
    "source_topic": "数组参数"
  },
  {
    "head": "void f(int a[])",
    "relation": "等价于",
    "tail": "void f(int* a)",
    "source_topic": "数组参数"
  },
  {
    "head": "数组",
    "relation": "访问方式",
    "tail": "下标形式",
    "source_topic": "数组的访问方式"
  },
  {
    "head": "数组",
    "relation": "访问方式",
    "tail": "指针形式",
    "source_topic": "数组的访问方式"
  },
  {
    "head": "下标形式",
    "relation": "等价于",
    "tail": "指针形式",
    "source_topic": "数组的访问方式"
  },
  {
    "head": "数组元素访问",
    "relation": "转换方式",
    "tail": "下标与指针转换",
    "source_topic": "数组的访问方式"
  },
  {
    "head": "数组名",
    "relation": "代表",
    "tail": "数组首元素的地址",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "数组名 a",
    "relation": "表示",
    "tail": "元素的地址",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "a[i]",
    "relation": "等价于",
    "tail": "*（a+i）",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "数组名 a",
    "relation": "等同于",
    "tail": "&a[0]",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "数组名 a+i",
    "relation": "等同于",
    "tail": "&a[i]",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "数组地址",
    "relation": "需要",
    "tail": "取地址符&",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "&a",
    "relation": "表示",
    "tail": "整个数组的地址",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "&a+1",
    "relation": "指向",
    "tail": "整个数组的最后面的位置",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "数组首元素的地址",
    "relation": "与",
    "tail": "数组的地址值相同",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "数组首元素的地址",
    "relation": "属于",
    "tail": "不同的概念",
    "source_topic": "数组地址与数组名"
  },
  {
    "head": "C++类",
    "relation": "包含",
    "tail": "类的实现细节",
    "source_topic": "C++中类封装的基本概念"
  },
  {
    "head": "C++类",
    "relation": "包含",
    "tail": "类的使用方式",
    "source_topic": "C++中类封装的基本概念"
  },
  {
    "head": "类的使用方式",
    "relation": "隔离",
    "tail": "类的实现细节",
    "source_topic": "C++中类封装的基本概念"
  },
  {
    "head": "C++类",
    "relation": "定义",
    "tail": "属性的公开级别",
    "source_topic": "C++中类封装的基本概念"
  },
  {
    "head": "C++类",
    "relation": "定义",
    "tail": "行为的公开级别",
    "source_topic": "C++中类封装的基本概念"
  },
  {
    "head": "C++引用",
    "relation": "属于",
    "tail": "变量别名",
    "source_topic": "C++中的引用基本点"
  },
  {
    "head": "普通引用",
    "relation": "初始化要求",
    "tail": "同类型变量",
    "source_topic": "C++中的引用基本点"
  },
  {
    "head": "函数参数引用",
    "relation": "初始化时机",
    "tail": "函数调用时",
    "source_topic": "C++中的引用基本点"
  },
  {
    "head": "C++引用",
    "relation": "替代方案",
    "tail": "指针",
    "source_topic": "C++中的引用基本点"
  },
  {
    "head": "C++引用",
    "relation": "优势",
    "tail": "更好的可读性和实用性",
    "source_topic": "C++中的引用基本点"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "独立功能模块",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "函数名反映功能",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "参数名体现参数意义",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "避免使用全局变量",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "参数不可修改时使用const",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "输入指针参数使用const",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "明确返回值类型",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "参数有效性检查",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "避免返回栈内存指针",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "函数体规模控制",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "相同输入相同输出",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "参数数量控制",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "附加返回值增加灵活性",
    "source_topic": "函数设计原则"
  },
  {
    "head": "函数设计原则",
    "relation": "包含",
    "tail": "函数名与返回值类型语义一致",
    "source_topic": "函数设计原则"
  },
  {
    "head": "回调函数",
    "relation": "实现方式",
    "tail": "函数指针",
    "source_topic": "C语言中的回调函数"
  },
  {
    "head": "回调机制",
    "relation": "特性",
    "tail": "调用者和被调用者互不依赖",
    "source_topic": "C语言中的回调函数"
  },
  {
    "head": "二维数组参数",
    "relation": "退化为",
    "tail": "一维数组",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "二维数组参数",
    "relation": "允许省略",
    "tail": "第一维参数",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "一维数组",
    "relation": "等效指针参数",
    "tail": "float* a",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "指针数组",
    "relation": "等效指针参数",
    "tail": "int** a",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "二维数组",
    "relation": "等效指针参数",
    "tail": "char(*a)[4]",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "C语言",
    "relation": "限制",
    "tail": "无法传递任意多维数组",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "int a[][3]",
    "relation": "合法",
    "tail": "C语言",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "int a[][]",
    "relation": "非法",
    "tail": "C语言",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "第一维之外的维度信息",
    "relation": "用于",
    "tail": "指针运算",
    "source_topic": "C语言中二维数组参数"
  },
  {
    "head": "数组",
    "relation": "本质",
    "tail": "一段连续的内存空间",
    "source_topic": "数组的本质"
  },
  {
    "head": "数组名",
    "relation": "可视为",
    "tail": "指向数组第一个元素的常量指针",
    "source_topic": "数组的本质"
  },
  {
    "head": "指针声明",
    "relation": "导致",
    "tail": "分配用于容纳地址值的4字节空间",
    "source_topic": "数组的本质"
  },
  {
    "head": "数组",
    "relation": "属于/分类",
    "tail": "相同类型的变量的有序集合",
    "source_topic": "数组的含义"
  },
  {
    "head": "数组",
    "relation": "存储方式",
    "tail": "连续的内存空间",
    "source_topic": "数组的含义"
  },
  {
    "head": "数组",
    "relation": "元素个数指定方式",
    "tail": "显示或隐式指定",
    "source_topic": "数组的含义"
  },
  {
    "head": "#pragma",
    "relation": "用于",
    "tail": "指示编译器完成特定动作",
    "source_topic": "C语言中#pragma 的使用"
  },
  {
    "head": "#pragma",
    "relation": "具有",
    "tail": "编译器特有指示字",
    "source_topic": "C语言中#pragma 的使用"
  },
  {
    "head": "预处理器",
    "relation": "忽略",
    "tail": "不认识的#pragma指令",
    "source_topic": "C语言中#pragma 的使用"
  },
  {
    "head": "不同编译器",
    "relation": "可能以不同方式解释",
    "tail": "同一条#pragma指令",
    "source_topic": "C语言中#pragma 的使用"
  },
  {
    "head": "#line",
    "relation": "属于",
    "tail": "预处理指令",
    "source_topic": "C语言中#line的用法"
  },
  {
    "head": "#line",
    "relation": "功能",
    "tail": "强制指定新的行号和编译文件名",
    "source_topic": "C语言中#line的用法"
  },
  {
    "head": "#line",
    "relation": "功能",
    "tail": "对源程序的代码重新编号",
    "source_topic": "C语言中#line的用法"
  },
  {
    "head": "#error",
    "relation": "属于",
    "tail": "预编译器指示字",
    "source_topic": "C语言中#error的用法"
  },
  {
    "head": "#error",
    "relation": "用法",
    "tail": "生成编译错误消息",
    "source_topic": "C语言中#error的用法"
  },
  {
    "head": "#error",
    "relation": "与",
    "tail": "#warning",
    "source_topic": "C语言中#error的用法"
  },
  {
    "head": "#error",
    "relation": "功能",
    "tail": "自定义程序员特有的编译错误消息",
    "source_topic": "C语言中#error的用法"
  },
  {
    "head": "#error",
    "relation": "用于",
    "tail": "提示编译条件是否满足",
    "source_topic": "C语言中#error的用法"
  },
  {
    "head": "编译错误",
    "relation": "导致",
    "tail": "无法生成最终的可执行程序",
    "source_topic": "C语言中#error的用法"
  },
  {
    "head": "C语言数组参数",
    "relation": "退化为",
    "tail": "指针",
    "source_topic": "c语言中数组参数退化为指针的意义"
  },
  {
    "head": "数组参数传递",
    "relation": "导致",
    "tail": "值拷贝",
    "source_topic": "c语言中数组参数退化为指针的意义"
  },
  {
    "head": "值拷贝",
    "relation": "导致",
    "tail": "执行效率低下",
    "source_topic": "c语言中数组参数退化为指针的意义"
  },
  {
    "head": "C语言",
    "relation": "设计目标",
    "tail": "高效",
    "source_topic": "c语言中数组参数退化为指针的意义"
  },
  {
    "head": "数组参数传递",
    "relation": "导致",
    "tail": "栈溢出",
    "source_topic": "c语言中数组参数退化为指针的意义"
  },
  {
    "head": "数组名",
    "relation": "视为",
    "tail": "常量指针",
    "source_topic": "c语言中数组参数退化为指针的意义"
  },
  {
    "head": "数组参数传递",
    "relation": "传递",
    "tail": "数组首元素地址",
    "source_topic": "c语言中数组参数退化为指针的意义"
  },
  {
    "head": "顺序点",
    "relation": "定义",
    "tail": "程序中存在一定的顺序点",
    "source_topic": "程序中的顺序点"
  },
  {
    "head": "顺序点",
    "relation": "核心特性",
    "tail": "执行过程中修改变量值的最晚时刻",
    "source_topic": "程序中的顺序点"
  },
  {
    "head": "顺序点",
    "relation": "保证",
    "tail": "之前所做的一切操作必须完成",
    "source_topic": "程序中的顺序点"
  },
  {
    "head": "面向过程的程序设计",
    "relation": "属于",
    "tail": "编程思想",
    "source_topic": "面向过程的程序设计"
  },
  {
    "head": "面向过程的程序设计",
    "relation": "核心特性",
    "tail": "以过程为中心",
    "source_topic": "面向过程的程序设计"
  },
  {
    "head": "面向过程的程序设计",
    "relation": "解决方式",
    "tail": "将复杂问题分解为容易解决的问题",
    "source_topic": "面向过程的程序设计"
  },
  {
    "head": "面向过程的程序设计",
    "relation": "解决方式",
    "tail": "按照步骤一步步完成",
    "source_topic": "面向过程的程序设计"
  },
  {
    "head": "C语言函数类型",
    "relation": "由",
    "tail": "返回值",
    "source_topic": "C语言中的函数类型"
  },
  {
    "head": "C语言函数类型",
    "relation": "由",
    "tail": "参数类型",
    "source_topic": "C语言中的函数类型"
  },
  {
    "head": "C语言函数类型",
    "relation": "由",
    "tail": "参数个数",
    "source_topic": "C语言中的函数类型"
  },
  {
    "head": "typedef",
    "relation": "用于",
    "tail": "函数类型重命名",
    "source_topic": "C语言中的函数类型"
  },
  {
    "head": "typedef",
    "relation": "定义",
    "tail": "函数类型别名",
    "source_topic": "C语言中的函数类型"
  },
  {
    "head": "二维数组",
    "relation": "内存排布方式",
    "tail": "一维方式",
    "source_topic": "C语言二维数组与二级指针"
  },
  {
    "head": "二维数组",
    "relation": "组成结构",
    "tail": "一维数组",
    "source_topic": "C语言二维数组与二级指针"
  },
  {
    "head": "二维数组",
    "relation": "组成结构",
    "tail": "具体值",
    "source_topic": "C语言二维数组与二级指针"
  },
  {
    "head": "二维数组的数组名",
    "relation": "类型",
    "tail": "常量指针",
    "source_topic": "C语言二维数组与二级指针"
  },
  {
    "head": "C语言字符串长度",
    "relation": "定义",
    "tail": "字符串所包含字符的个数",
    "source_topic": "C语言中字符串的长度"
  },
  {
    "head": "C语言字符串长度",
    "relation": "确定方式",
    "tail": "第一个\\0字符前出现的字符个数",
    "source_topic": "C语言中字符串的长度"
  },
  {
    "head": "C语言字符串长度",
    "relation": "计算方法",
    "tail": "strlen函数",
    "source_topic": "C语言中字符串的长度"
  },
  {
    "head": "指针",
    "relation": "运算规则",
    "tail": "整数运算规则",
    "source_topic": "指针的运算"
  },
  {
    "head": "指针",
    "relation": "运算规则",
    "tail": "p-1 指向上一个元素",
    "source_topic": "指针的运算"
  },
  {
    "head": "指针减法运算",
    "relation": "前提条件",
    "tail": "两个指针类型必须相同",
    "source_topic": "指针的运算"
  },
  {
    "head": "指针减法运算",
    "relation": "前提条件",
    "tail": "两个指针指向同一个数组中的元素",
    "source_topic": "指针的运算"
  },
  {
    "head": "指针减法运算",
    "relation": "意义",
    "tail": "指针所指元素的下标差",
    "source_topic": "指针的运算"
  },
  {
    "head": "数组名",
    "relation": "指代实体",
    "tail": "数组",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "可视为",
    "tail": "常量指针",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "不分配内存",
    "tail": "编译器",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "只能作为",
    "tail": "右值",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "退化为",
    "tail": "指针",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "sizeof",
    "tail": "整个数组的大小",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "取地址",
    "tail": "数组的地址",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组引用",
    "relation": "访问内存次数",
    "tail": "一次",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "指针引用",
    "relation": "访问内存次数",
    "tail": "两次",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "包含信息",
    "tail": "数组大小",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "包含信息",
    "tail": "数组地址",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "存储于",
    "tail": "符号表",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "操作限制",
    "tail": "不能进行自增自减",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "数组名",
    "relation": "操作限制",
    "tail": "不能直接赋值给另一个数组名",
    "source_topic": "数组名的知识点"
  },
  {
    "head": "条件编译",
    "relation": "属于",
    "tail": "预编译指示命令",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译",
    "relation": "功能",
    "tail": "控制是否编译某段代码",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译",
    "relation": "与",
    "tail": "if…else…",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译",
    "relation": "区别",
    "tail": "运行期分支判断",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译指令",
    "relation": "处理时机",
    "tail": "预编译期",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "if…else…语句",
    "relation": "处理时机",
    "tail": "运行期",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译",
    "relation": "意义",
    "tail": "按不同的条件编译不同的代码段",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译",
    "relation": "意义",
    "tail": "产生不同的目标代码",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译",
    "relation": "应用场景",
    "tail": "不同的产品线共用一份代码",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "条件编译",
    "relation": "应用场景",
    "tail": "区分编译产品的调试版和发布版",
    "source_topic": "C语言中的条件编译"
  },
  {
    "head": "宏定义",
    "relation": "处理阶段",
    "tail": "预处理器",
    "source_topic": "C语言中函数和宏定义的对比"
  },
  {
    "head": "宏定义",
    "relation": "编译器处理",
    "tail": "未知",
    "source_topic": "C语言中函数和宏定义的对比"
  },
  {
    "head": "宏定义",
    "relation": "参数替换方式",
    "tail": "实参完全替代形参",
    "source_topic": "C语言中函数和宏定义的对比"
  },
  {
    "head": "宏定义",
    "relation": "调用开销",
    "tail": "无开销",
    "source_topic": "C语言中函数和宏定义的对比"
  },
  {
    "head": "宏定义",
    "relation": "限制",
    "tail": "不能递归定义",
    "source_topic": "C语言中函数和宏定义的对比"
  },
  {
    "head": "C语言源文件",
    "relation": "生成",
    "tail": "目标文件",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "目标文件",
    "relation": "被链接",
    "tail": "可执行文件",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "链接器",
    "relation": "作用",
    "tail": "处理模块之间相互引用的部分",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "gcc",
    "relation": "编译",
    "tail": "静态库源码",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "ar",
    "relation": "生成",
    "tail": "静态库文件",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "静态库文件",
    "relation": "包含",
    "tail": "lib.o",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "gcc",
    "relation": "使用",
    "tail": "静态库文件",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "动态链接",
    "relation": "实现方式",
    "tail": "在运行时动态加载库进行链接",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "动态链接库",
    "relation": "不包含",
    "tail": "可执行程序",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "gcc",
    "relation": "编译",
    "tail": "动态库源码",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "gcc",
    "relation": "使用",
    "tail": "-ldl",
    "source_topic": "c语言中动态库和静态库的使用"
  },
  {
    "head": "逗号表达式",
    "relation": "属于",
    "tail": "C语言语法",
    "source_topic": "c语言中的逗号表达式"
  },
  {
    "head": "逗号表达式",
    "relation": "功能",
    "tail": "连接多个子表达式为一个表达式",
    "source_topic": "c语言中的逗号表达式"
  },
  {
    "head": "逗号表达式",
    "relation": "计算顺序",
    "tail": "从左向右",
    "source_topic": "c语言中的逗号表达式"
  },
  {
    "head": "逗号表达式",
    "relation": "返回值",
    "tail": "最后一个子表达式的值",
    "source_topic": "c语言中的逗号表达式"
  },
  {
    "head": "'a'",
    "relation": "表示",
    "tail": "字符字面量",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "字符字面量",
    "relation": "被编译为",
    "tail": "ASCII码",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "'a'",
    "relation": "在内存中占用",
    "tail": "1个字节",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "'a' + 1",
    "relation": "表示",
    "tail": "字符字面量的ASCII码加1",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "\"a\"",
    "relation": "表示",
    "tail": "字符串字面量",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "字符串字面量",
    "relation": "被编译为",
    "tail": "内存地址",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "\"a\"",
    "relation": "在内存中占用",
    "tail": "2个字节",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "\"a\" + 1",
    "relation": "表示",
    "tail": "指针运算",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "指针运算",
    "relation": "指向",
    "tail": "\"\\0\"",
    "source_topic": "C语言中的单引号和双引号"
  },
  {
    "head": "反斜杠",
    "relation": "属于",
    "tail": "C语言接续符",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "反斜杠",
    "relation": "属于",
    "tail": "C语言转义符",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "C语言接续符",
    "relation": "使用限制",
    "tail": "反斜杠之后不能有空格",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "C语言接续符",
    "relation": "使用限制",
    "tail": "反斜杠下一行之前也不能有空格",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "C语言接续符",
    "relation": "适用场景",
    "tail": "宏定义代码块",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "C语言转义符",
    "relation": "作用",
    "tail": "表示无回显字符",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "C语言转义符",
    "relation": "作用",
    "tail": "表示常规字符",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "C语言转义符",
    "relation": "使用限制",
    "tail": "必须出现在单引号或双引号之间",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "反斜杠",
    "relation": "使用条件",
    "tail": "作为接续符时可直接出现在程序中",
    "source_topic": "C语言中接续符和转义符"
  },
  {
    "head": "union",
    "relation": "属于",
    "tail": "C语言",
    "source_topic": "C语言中union关键字"
  },
  {
    "head": "union",
    "relation": "语法相似",
    "tail": "struct",
    "source_topic": "C语言中union关键字"
  },
  {
    "head": "union",
    "relation": "分配空间",
    "tail": "最大成员的空间",
    "source_topic": "C语言中union关键字"
  },
  {
    "head": "union",
    "relation": "共享空间",
    "tail": "所有成员",
    "source_topic": "C语言中union关键字"
  },
  {
    "head": "union",
    "relation": "受系统影响",
    "tail": "大小端",
    "source_topic": "C语言中union关键字"
  },
  {
    "head": "auto关键字",
    "relation": "存储位置",
    "tail": "栈空间",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "register关键字",
    "relation": "请求存储位置",
    "tail": "寄存器",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "register关键字",
    "relation": "限制",
    "tail": "不能使用&运算符获取地址",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "register关键字",
    "relation": "不确定性",
    "tail": "不一定会成功",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "static关键字",
    "relation": "存储位置",
    "tail": "程序静态区",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "static关键字",
    "relation": "作用域限定",
    "tail": "函数作用域限定在声明的文件中",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "extern关键字",
    "relation": "用途",
    "tail": "声明外部定义的变量和函数",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "extern关键字",
    "relation": "分配空间",
    "tail": "文件的其它地方",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "extern关键字",
    "relation": "编译方式",
    "tail": "以标准C方式编译",
    "source_topic": "C语言中变量的属性关键字"
  },
  {
    "head": "enum",
    "relation": "属于",
    "tail": "C语言自定义类型",
    "source_topic": "c语言中enum关键字的作用"
  },
  {
    "head": "enum",
    "relation": "包含",
    "tail": "离散值",
    "source_topic": "c语言中enum关键字的作用"
  },
  {
    "head": "enum值",
    "relation": "可以定义为",
    "tail": "自定义整型值",
    "source_topic": "c语言中enum关键字的作用"
  },
  {
    "head": "enum值",
    "relation": "默认递增方式",
    "tail": "前一个定义值加1",
    "source_topic": "c语言中enum关键字的作用"
  },
  {
    "head": "enum类型变量",
    "relation": "只能取",
    "tail": "定义时的离散值",
    "source_topic": "c语言中enum关键字的作用"
  },
  {
    "head": "sizeof",
    "relation": "属于",
    "tail": "编译器内置指示符",
    "source_topic": "C语言中sizeof关键字的作用"
  },
  {
    "head": "sizeof",
    "relation": "用于",
    "tail": "计算类型或变量所占的内存大小",
    "source_topic": "C语言中sizeof关键字的作用"
  },
  {
    "head": "sizeof",
    "relation": "确定时机",
    "tail": "编译期",
    "source_topic": "C语言中sizeof关键字的作用"
  },
  {
    "head": "extern",
    "relation": "应用",
    "tail": "引用同一个文件中的变量",
    "source_topic": "c语言中extern关键字的作用"
  },
  {
    "head": "extern",
    "relation": "应用",
    "tail": "引用另一个文件中的变量",
    "source_topic": "c语言中extern关键字的作用"
  },
  {
    "head": "extern",
    "relation": "应用",
    "tail": "引用另一个文件中的函数",
    "source_topic": "c语言中extern关键字的作用"
  },
  {
    "head": "extern \"C\"",
    "relation": "指示",
    "tail": "编译器按C语言进行编译",
    "source_topic": "c语言中extern关键字的作用"
  },
  {
    "head": "volatile",
    "relation": "属于",
    "tail": "类型修饰符",
    "source_topic": "C语言中volatile关键字的作用"
  },
  {
    "head": "volatile",
    "relation": "设计用途",
    "tail": "修饰被不同线程访问和修改的变量",
    "source_topic": "C语言中volatile关键字的作用"
  },
  {
    "head": "volatile",
    "relation": "作用",
    "tail": "要求每次直接读值",
    "source_topic": "C语言中volatile关键字的作用"
  },
  {
    "head": "volatile变量",
    "relation": "说明",
    "tail": "变量可能会被意想不到地改变",
    "source_topic": "C语言中volatile关键字的作用"
  },
  {
    "head": "const关键字",
    "relation": "定义",
    "tail": "常变量",
    "source_topic": "C语言中const关键字的作用"
  },
  {
    "head": "const关键字",
    "relation": "修饰",
    "tail": "函数参数",
    "source_topic": "C语言中const关键字的作用"
  },
  {
    "head": "const关键字",
    "relation": "修饰",
    "tail": "函数返回值",
    "source_topic": "C语言中const关键字的作用"
  },
  {
    "head": "const关键字",
    "relation": "保护",
    "tail": "变量被意外修改",
    "source_topic": "C语言中const关键字的作用"
  },
  {
    "head": "const关键字",
    "relation": "增强",
    "tail": "程序的健壮性",
    "source_topic": "C语言中const关键字的作用"
  },
  {
    "head": "const关键字",
    "relation": "让逻辑错误在",
    "tail": "编译期间被发现",
    "source_topic": "C语言中const关键字的作用"
  },
  {
    "head": "const关键字",
    "relation": "避免",
    "tail": "运行阶段程序异常终止",
    "source_topic": "C语言中const关键字的作用"
  },
  {
    "head": "##",
    "relation": "功能",
    "tail": "将两个宏参数连接",
    "source_topic": "‘#’与‘##’的区别"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "引用头文件",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "全局变量",
    "relation": "引用方式",
    "tail": "extern关键字",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "引用头文件",
    "relation": "错误检测阶段",
    "tail": "编译期间",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "extern关键字",
    "relation": "错误检测阶段",
    "tail": "连接期间",
    "source_topic": "如何引用一个已经定义过的全局变量？"
  },
  {
    "head": "ARM",
    "relation": "使用",
    "tail": "大端模式",
    "source_topic": "大小端问题"
  },
  {
    "head": "PowerPC",
    "relation": "使用",
    "tail": "大端模式",
    "source_topic": "大小端问题"
  },
  {
    "head": "Intel x86",
    "relation": "使用",
    "tail": "小端模式",
    "source_topic": "大小端问题"
  },
  {
    "head": "typedef",
    "relation": "属于",
    "tail": "C语言关键字",
    "source_topic": "typedef关键字"
  },
  {
    "head": "typedef",
    "relation": "功能",
    "tail": "为现有类型创建一个新的名字",
    "source_topic": "typedef关键字"
  },
  {
    "head": "typedef",
    "relation": "使用场景",
    "tail": "创建易于记忆的类型名",
    "source_topic": "typedef关键字"
  },
  {
    "head": "封装",
    "relation": "属于",
    "tail": "信息隐藏的设计理念",
    "source_topic": "什么是封装？C++中是如何实现的？"
  },
  {
    "head": "封装",
    "relation": "核心特性",
    "tail": "接口与具体实现相隔离",
    "source_topic": "什么是封装？C++中是如何实现的？"
  },
  {
    "head": "C++",
    "relation": "实现",
    "tail": "封装",
    "source_topic": "什么是封装？C++中是如何实现的？"
  },
  {
    "head": "C语言",
    "relation": "定义常量方式",
    "tail": "#define宏定义",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "C++语言",
    "relation": "定义常量方式",
    "tail": "const关键字",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "const关键字",
    "relation": "具有",
    "tail": "数据类型",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "#define宏定义",
    "relation": "缺乏",
    "tail": "数据类型",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "const常量",
    "relation": "支持",
    "tail": "静态类型安全检查",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "#define宏定义",
    "relation": "缺乏",
    "tail": "静态类型安全检查",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "const常量",
    "relation": "可能支持",
    "tail": "调试",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "#define宏定义",
    "relation": "不支持",
    "tail": "调试",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "#define宏定义",
    "relation": "可能导致",
    "tail": "边际效应",
    "source_topic": "C与C++各自是如何定义常量的？有什么不同？"
  },
  {
    "head": "内存分配方式",
    "relation": "分类",
    "tail": "静态存储区域分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "内存分配方式",
    "relation": "分类",
    "tail": "栈上分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "内存分配方式",
    "relation": "分类",
    "tail": "堆上分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "程序编译时分配",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "特点",
    "tail": "内存在整个运行期间存在",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "静态存储区域分配",
    "relation": "举例",
    "tail": "全局变量",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "函数执行时分配局部变量存储单元",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "函数执行结束时自动释放内存",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "内存分配效率高",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "栈上分配",
    "relation": "特点",
    "tail": "分配的内存容量有限",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "程序运行时动态申请内存",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "程序员手动释放内存",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "内存生存期由程序员决定",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "特点",
    "tail": "使用灵活",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "堆上分配",
    "relation": "问题",
    "tail": "内存管理复杂",
    "source_topic": "内存的分配方式的分配方式有几种?"
  },
  {
    "head": "预编译",
    "relation": "属于",
    "tail": "编译过程",
    "source_topic": "什么是预编译？何时需要预编译？"
  },
  {
    "head": "预编译",
    "relation": "解决",
    "tail": "编译效率问题",
    "source_topic": "什么是预编译？何时需要预编译？"
  },
  {
    "head": "预编译头",
    "relation": "包含",
    "tail": "标准包含文件",
    "source_topic": "什么是预编译？何时需要预编译？"
  },
  {
    "head": "预编译头",
    "relation": "包含",
    "tail": "相同的编译选项",
    "source_topic": "什么是预编译？何时需要预编译？"
  },
  {
    "head": "预编译",
    "relation": "适用场景",
    "tail": "不经常改动的大型代码体",
    "source_topic": "什么是预编译？何时需要预编译？"
  },
  {
    "head": "预编译",
    "relation": "适用场景",
    "tail": "多模块程序使用相同包含文件",
    "source_topic": "什么是预编译？何时需要预编译？"
  },
  {
    "head": "C语言函数",
    "relation": "属于",
    "tail": "C编译器编译后的符号库",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明?"
  },
  {
    "head": "extern\"C\"",
    "relation": "指定",
    "tail": "C连接方式",
    "source_topic": "在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”声明?"
  },
  {
    "head": "memset",
    "relation": "典型应用场景",
    "tail": "初始化定义的字符串为’\\0′",
    "source_topic": "memset ,memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "功能",
    "tail": "做内存拷贝",
    "source_topic": "memset ,memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "适用对象",
    "tail": "任何数据类型的对象",
    "source_topic": "memset ,memcpy 的区别"
  },
  {
    "head": "memcpy",
    "relation": "可指定参数",
    "tail": "拷贝的数据长度",
    "source_topic": "memset ,memcpy 的区别"
  },
  {
    "head": "char * const t",
    "relation": "定义为",
    "tail": "常量指针",
    "source_topic": "一下三种指针的区别？"
  },
  {
    "head": "char const * t",
    "relation": "定义为",
    "tail": "指向常量的指针",
    "source_topic": "一下三种指针的区别？"
  },
  {
    "head": "const char *t",
    "relation": "等价于",
    "tail": "char const *t",
    "source_topic": "一下三种指针的区别？"
  },
  {
    "head": "const int *p1",
    "relation": "表示",
    "tail": "常量指针",
    "source_topic": "“常量指针”和“指针常量”有什么区别？"
  },
  {
    "head": "int *const p2",
    "relation": "表示",
    "tail": "指针常量",
    "source_topic": "“常量指针”和“指针常量”有什么区别？"
  },
  {
    "head": "单向链表逆序输出",
    "relation": "实现方式",
    "tail": "迭代法",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "迭代法",
    "relation": "使用",
    "tail": "指针操作",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "指针操作",
    "relation": "涉及",
    "tail": "节点指针",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "节点指针",
    "relation": "包括",
    "tail": "pleft",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "节点指针",
    "relation": "包括",
    "tail": "pcurrent",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "节点指针",
    "relation": "包括",
    "tail": "pright",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "单向链表逆序输出",
    "relation": "实现方式",
    "tail": "栈结构",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "栈结构",
    "relation": "使用",
    "tail": "Java Stack类",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "Java Stack类",
    "relation": "属于",
    "tail": "Java集合框架",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "Java集合框架",
    "relation": "属于",
    "tail": "Java语言",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "单向链表逆序输出",
    "relation": "实现方式",
    "tail": "递归法",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "递归法",
    "relation": "使用",
    "tail": "函数调用",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "函数调用",
    "relation": "属于",
    "tail": "编程范式",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "编程范式",
    "relation": "属于",
    "tail": "计算机科学",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "单向链表逆序输出",
    "relation": "实现方式",
    "tail": "链表遍历",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "链表遍历",
    "relation": "涉及",
    "tail": "节点访问",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "节点访问",
    "relation": "属于",
    "tail": "数据结构操作",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "数据结构操作",
    "relation": "属于",
    "tail": "算法",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "算法",
    "relation": "属于",
    "tail": "计算机科学",
    "source_topic": "问题：如何实现一个高效的单向链表逆序输出？"
  },
  {
    "head": "Epoll",
    "relation": "属于",
    "tail": "I/O多路复用技术",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "Select",
    "relation": "属于",
    "tail": "I/O多路复用技术",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "Select",
    "relation": "核心特性",
    "tail": "基于轮询机制",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "Epoll",
    "relation": "效率",
    "tail": "高于Select",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "Epoll",
    "relation": "支持",
    "tail": "水平触发",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "Epoll",
    "relation": "支持",
    "tail": "边沿触发",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "Select",
    "relation": "限制",
    "tail": "最大1024连接",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "边沿触发",
    "relation": "注意事项",
    "tail": "需要确保读取所有数据以避免遗漏",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "边沿触发",
    "relation": "注意事项",
    "tail": "避免在未读取完数据时重复触发",
    "source_topic": "问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选）"
  },
  {
    "head": "集合",
    "relation": "属于",
    "tail": "MongoDB",
    "source_topic": "题目：什么是集合"
  },
  {
    "head": "集合",
    "relation": "相当于",
    "tail": "关系型数据库中的表",
    "source_topic": "题目：什么是集合"
  },
  {
    "head": "集合",
    "relation": "位于",
    "tail": "数据库",
    "source_topic": "题目：什么是集合"
  },
  {
    "head": "集合",
    "relation": "包含",
    "tail": "多个文档",
    "source_topic": "题目：什么是集合"
  },
  {
    "head": "文档",
    "relation": "可以有",
    "tail": "多个不同的字段",
    "source_topic": "题目：什么是集合"
  },
  {
    "head": "集合",
    "relation": "具有",
    "tail": "相同或相关的目的",
    "source_topic": "题目：什么是集合"
  },
  {
    "head": "ZooKeeper",
    "relation": "包含",
    "tail": "PERSISTENT",
    "source_topic": "zookeeper的四种类型的znode"
  },
  {
    "head": "ZooKeeper",
    "relation": "包含",
    "tail": "EPHEMERAL",
    "source_topic": "zookeeper的四种类型的znode"
  },
  {
    "head": "PERSISTENT",
    "relation": "属于",
    "tail": "Znode类型",
    "source_topic": "zookeeper的四种类型的znode"
  },
  {
    "head": "EPHEMERAL",
    "relation": "属于",
    "tail": "Znode类型",
    "source_topic": "zookeeper的四种类型的znode"
  },
  {
    "head": "MySQL",
    "relation": "依赖",
    "tail": "全量备份",
    "source_topic": "题目：MySQL 的数据如何恢复到任意时间点？"
  },
  {
    "head": "MySQL",
    "relation": "依赖",
    "tail": "binlog日志",
    "source_topic": "题目：MySQL 的数据如何恢复到任意时间点？"
  },
  {
    "head": "数据恢复",
    "relation": "前提",
    "tail": "全量备份",
    "source_topic": "题目：MySQL 的数据如何恢复到任意时间点？"
  },
  {
    "head": "数据恢复",
    "relation": "前提",
    "tail": "binlog日志",
    "source_topic": "题目：MySQL 的数据如何恢复到任意时间点？"
  },
  {
    "head": "恢复到任意时间点",
    "relation": "步骤",
    "tail": "恢复全量备份",
    "source_topic": "题目：MySQL 的数据如何恢复到任意时间点？"
  },
  {
    "head": "恢复到任意时间点",
    "relation": "步骤",
    "tail": "回放binlog日志",
    "source_topic": "题目：MySQL 的数据如何恢复到任意时间点？"
  },
  {
    "head": "回放binlog日志",
    "relation": "目标",
    "tail": "指定时间点",
    "source_topic": "题目：MySQL 的数据如何恢复到任意时间点？"
  },
  {
    "head": "NFS",
    "relation": "属于",
    "tail": "NAS协议",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "SMB",
    "relation": "属于",
    "tail": "NAS协议",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "文件系统",
    "relation": "共享协议",
    "tail": "NFS",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "文件系统",
    "relation": "共享协议",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "导致",
    "tail": "文件系统一致性问题",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "SMB",
    "relation": "导致",
    "tail": "文件系统一致性问题",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "解决",
    "tail": "跨主机文件访问",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "SMB",
    "relation": "解决",
    "tail": "跨主机文件访问",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "NFS",
    "relation": "与",
    "tail": "SMB",
    "source_topic": "题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选）"
  },
  {
    "head": "链表",
    "relation": "操作",
    "tail": "删除倒数第N个节点",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "删除倒数第N个节点",
    "relation": "实现方式",
    "tail": "双指针法",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "双指针法",
    "relation": "使用",
    "tail": "第一个指针",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "双指针法",
    "relation": "使用",
    "tail": "第二个指针",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "第一个指针",
    "relation": "移动",
    "tail": "n+1步",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "第二个指针",
    "relation": "移动",
    "tail": "与第一个指针保持n个节点间隔",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "双指针法",
    "relation": "目标",
    "tail": "一次遍历完成删除操作",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "算法",
    "relation": "时间复杂度",
    "tail": "O(L)",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "算法",
    "relation": "空间复杂度",
    "tail": "O(1)",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "ListNode",
    "relation": "属于",
    "tail": "链表结构",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "dummy",
    "relation": "属于",
    "tail": "虚拟头结点",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "虚拟头结点",
    "relation": "作用",
    "tail": "简化边界条件处理",
    "source_topic": "题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。"
  },
  {
    "head": "考察点",
    "relation": "包含",
    "tail": "基础数据结构的理解和编码能力",
    "source_topic": "* 考察点"
  },
  {
    "head": "考察点",
    "relation": "包含",
    "tail": "递归使用",
    "source_topic": "* 考察点"
  },
  {
    "head": "createBST1",
    "relation": "构建",
    "tail": "二叉搜索树",
    "source_topic": "* 示例"
  },
  {
    "head": "createBST2",
    "relation": "构建",
    "tail": "二叉搜索树",
    "source_topic": "* 示例"
  },
  {
    "head": "createBST3",
    "relation": "构建",
    "tail": "二叉搜索树",
    "source_topic": "* 示例"
  },
  {
    "head": "createBST4",
    "relation": "构建",
    "tail": "二叉搜索树",
    "source_topic": "* 示例"
  },
  {
    "head": "createBST6",
    "relation": "构建",
    "tail": "二叉搜索树",
    "source_topic": "* 示例"
  },
  {
    "head": "BST",
    "relation": "属于",
    "tail": "数据结构",
    "source_topic": "* 示例"
  },
  {
    "head": "setLeft",
    "relation": "属于",
    "tail": "二叉搜索树操作",
    "source_topic": "* 示例"
  },
  {
    "head": "setRight",
    "relation": "属于",
    "tail": "二叉搜索树操作",
    "source_topic": "* 示例"
  },
  {
    "head": "check",
    "relation": "用于",
    "tail": "验证二叉搜索树的查找功能",
    "source_topic": "* 示例"
  },
  {
    "head": "find",
    "relation": "属于",
    "tail": "二叉搜索树查找方法",
    "source_topic": "* 示例"
  },
  {
    "head": "循环数数问题",
    "relation": "解决",
    "tail": "循环链表",
    "source_topic": "题目：用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"
  },
  {
    "head": "循环链表",
    "relation": "使用",
    "tail": "取余操作",
    "source_topic": "题目：用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "丰富数据类型",
    "source_topic": "redis相比memcached有哪些优势？："
  },
  {
    "head": "Redis",
    "relation": "速度",
    "tail": "比Memcached快",
    "source_topic": "redis相比memcached有哪些优势？："
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "数据持久化",
    "source_topic": "redis相比memcached有哪些优势？："
  },
  {
    "head": "Redis Sentinel",
    "relation": "核心特性",
    "tail": "高可用",
    "source_topic": "题目：是否使用过Redis集群，集群的原理是什么？"
  },
  {
    "head": "Redis Sentinel",
    "relation": "解决",
    "tail": "master宕机",
    "source_topic": "题目：是否使用过Redis集群，集群的原理是什么？"
  },
  {
    "head": "Redis Sentinel",
    "relation": "导致",
    "tail": "slave提升为master",
    "source_topic": "题目：是否使用过Redis集群，集群的原理是什么？"
  },
  {
    "head": "Redis Cluster",
    "relation": "核心特性",
    "tail": "扩展性",
    "source_topic": "题目：是否使用过Redis集群，集群的原理是什么？"
  },
  {
    "head": "Redis Cluster",
    "relation": "解决",
    "tail": "单个redis内存不足",
    "source_topic": "题目：是否使用过Redis集群，集群的原理是什么？"
  },
  {
    "head": "Redis Cluster",
    "relation": "基于",
    "tail": "分片存储",
    "source_topic": "题目：是否使用过Redis集群，集群的原理是什么？"
  },
  {
    "head": "Zookeeper",
    "relation": "使用",
    "tail": "basic paxos",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper",
    "relation": "使用",
    "tail": "fast paxos",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper",
    "relation": "默认使用",
    "tail": "fast paxos",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "basic paxos",
    "relation": "属于",
    "tail": "Zookeeper选主流程",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "fast paxos",
    "relation": "属于",
    "tail": "Zookeeper选主流程",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "选举线程",
    "relation": "由",
    "tail": "当前Server发起选举的线程",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper选主流程",
    "relation": "包含",
    "tail": "选举线程发起询问",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper选主流程",
    "relation": "包含",
    "tail": "验证zxid一致性",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper选主流程",
    "relation": "包含",
    "tail": "存储投票记录",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper选主流程",
    "relation": "包含",
    "tail": "计算zxid最大Server",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper选主流程",
    "relation": "包含",
    "tail": "设置推荐Leader",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper选主流程",
    "relation": "包含",
    "tail": "获得多数Server支持",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper选主流程",
    "relation": "要求",
    "tail": "Server总数为奇数2n+1",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "fast paxos",
    "relation": "包含",
    "tail": "提议成为Leader",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "fast paxos",
    "relation": "包含",
    "tail": "解决epoch和zxid冲突",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "fast paxos",
    "relation": "包含",
    "tail": "接受对方提议",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "fast paxos",
    "relation": "包含",
    "tail": "发送接受完成消息",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper",
    "relation": "解决",
    "tail": "Leader选举",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper",
    "relation": "恢复模式",
    "tail": "重新选举Leader",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper",
    "relation": "记录",
    "tail": "事务日志",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper",
    "relation": "定期进行",
    "tail": "快照",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "Zookeeper",
    "relation": "恢复时使用",
    "tail": "磁盘快照",
    "source_topic": "题目：zookeeper是如何选举Leader的?"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "面向文档的存储",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "面向文档的存储",
    "relation": "数据格式",
    "tail": "BSON",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "BSON",
    "relation": "限制",
    "tail": "最大16M",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "包含",
    "tail": "GridFS文件系统",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "GridFS文件系统",
    "relation": "用途",
    "tail": "存储大于16M的文件",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "任何属性都可以建立索引",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "复制",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "高可扩展性",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "自动分片",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "丰富的查询功能",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "核心特性",
    "tail": "快速的即时更新",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "MongoDB",
    "relation": "支持",
    "tail": "专业支持",
    "source_topic": "题目：MongoDB的优势有哪些"
  },
  {
    "head": "最大通路长度",
    "relation": "属于",
    "tail": "二叉树问题",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "TreeNode",
    "relation": "属于",
    "tail": "二叉树结构",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "递归求解",
    "relation": "实现",
    "tail": "最大通路长度",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "maxChildHeight",
    "relation": "属于",
    "tail": "递归方法",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "maxChildHeight",
    "relation": "计算",
    "tail": "左右子树高度",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "Math.max",
    "relation": "用于",
    "tail": "比较左右子树高度",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "迭代求解",
    "relation": "实现",
    "tail": "最大通路长度",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "Queue",
    "relation": "属于",
    "tail": "数据结构",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "LinkedList",
    "relation": "实现",
    "tail": "Queue",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "BFS",
    "relation": "属于",
    "tail": "迭代方法",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "BFS",
    "relation": "用于",
    "tail": "计算树的高度",
    "source_topic": "题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和）"
  },
  {
    "head": "视图",
    "relation": "属于",
    "tail": "虚拟表",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "包含",
    "tail": "动态检索数据的查询",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "作用",
    "tail": "简化复杂的SQL操作",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "作用",
    "tail": "隐藏具体细节",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "作用",
    "tail": "保护数据",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "使用方式",
    "tail": "与表相同的方式",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "限制",
    "tail": "不能被索引",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "限制",
    "tail": "不能有关联的触发器",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "限制",
    "tail": "不能有默认值",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "可更新性",
    "tail": "部分视图可以更新",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图更新",
    "relation": "影响",
    "tail": "基表将被更新",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "主要用途",
    "tail": "简化检索",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "主要用途",
    "tail": "保护数据",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "不用于",
    "tail": "更新",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "视图",
    "relation": "限制",
    "tail": "大部分视图不可更新",
    "source_topic": "题目：视图的作用，视图可以更改么？"
  },
  {
    "head": "static变量",
    "relation": "维持",
    "tail": "函数调用过程中值不变",
    "source_topic": "题目： static有什么用途？（请至少说明两种）"
  },
  {
    "head": "static变量",
    "relation": "限制访问范围",
    "tail": "模块内函数",
    "source_topic": "题目： static有什么用途？（请至少说明两种）"
  },
  {
    "head": "static函数",
    "relation": "限制使用范围",
    "tail": "声明它的模块",
    "source_topic": "题目： static有什么用途？（请至少说明两种）"
  },
  {
    "head": "use",
    "relation": "属于",
    "tail": "MongoDB命令",
    "source_topic": "题目：MongoDB哪个命令可以切换数据库"
  },
  {
    "head": "主键",
    "relation": "属于",
    "tail": "候选键",
    "source_topic": "总结"
  },
  {
    "head": "候选键",
    "relation": "属于",
    "tail": "超键",
    "source_topic": "总结"
  },
  {
    "head": "外键",
    "relation": "确定依据",
    "tail": "主键",
    "source_topic": "总结"
  },
  {
    "head": "Memcache",
    "relation": "数据支持类型",
    "tail": "简单数据类型",
    "source_topic": "题目：Memcache与Redis的区别都有哪些？"
  },
  {
    "head": "Redis",
    "relation": "数据支持类型",
    "tail": "复杂数据类型",
    "source_topic": "题目：Memcache与Redis的区别都有哪些？"
  },
  {
    "head": "Memcache",
    "relation": "最大value大小",
    "tail": "1MB",
    "source_topic": "题目：Memcache与Redis的区别都有哪些？"
  },
  {
    "head": "Redis",
    "relation": "最大value大小",
    "tail": "1GB",
    "source_topic": "题目：Memcache与Redis的区别都有哪些？"
  },
  {
    "head": "Redis",
    "relation": "底层模型",
    "tail": "VM机制",
    "source_topic": "题目：Memcache与Redis的区别都有哪些？"
  },
  {
    "head": "Memcache",
    "relation": "底层模型",
    "tail": "一般系统调用",
    "source_topic": "题目：Memcache与Redis的区别都有哪些？"
  },
  {
    "head": "Zookeeper",
    "relation": "解决",
    "tail": "分布式锁问题",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "Zookeeper",
    "relation": "包含",
    "tail": "一致性文件系统",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "分布式锁",
    "relation": "分类",
    "tail": "保持独占",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "分布式锁",
    "relation": "分类",
    "tail": "控制时序",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "创建Znode",
    "relation": "实现",
    "tail": "保持独占锁",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "临时顺序编号目录节点",
    "relation": "用于",
    "tail": "控制时序锁",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "获取分布式锁",
    "relation": "基于",
    "tail": "创建临时顺序节点",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "获取分布式锁",
    "relation": "涉及",
    "tail": "获取子节点列表",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "获取分布式锁",
    "relation": "涉及",
    "tail": "判断节点序号最小",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "释放分布式锁",
    "relation": "通过",
    "tail": "删除临时节点",
    "source_topic": "题目：zookeeper分布式锁"
  },
  {
    "head": "ZooKeeper文件系统",
    "relation": "属于",
    "tail": "分布式协调服务",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "ZooKeeper文件系统",
    "relation": "提供",
    "tail": "多层级节点命名空间",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "ZooKeeper节点",
    "relation": "称为",
    "tail": "Znode",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "Znode",
    "relation": "可以设置",
    "tail": "关联数据",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "Unix文件系统",
    "relation": "不同",
    "tail": "ZooKeeper文件系统",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "Unix文件系统目录",
    "relation": "不同",
    "tail": "ZooKeeper文件系统",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "ZooKeeper文件系统",
    "relation": "维护",
    "tail": "树状目录结构",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "ZooKeeper文件系统",
    "relation": "限制",
    "tail": "每个节点数据上限为1M",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "ZooKeeper文件系统",
    "relation": "设计目标",
    "tail": "高吞吐和低延迟",
    "source_topic": "题目：zookeeper文件系统"
  },
  {
    "head": "Redis",
    "relation": "核心特性",
    "tail": "速度快",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "核心特性",
    "tail": "数据存在内存中",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "底层结构",
    "tail": "HashMap",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "支持数据类型",
    "tail": "string",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "支持数据类型",
    "tail": "list",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "支持数据类型",
    "tail": "set",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "支持数据类型",
    "tail": "sorted set",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "支持数据类型",
    "tail": "hash",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "核心特性",
    "tail": "支持事务",
    "source_topic": "题目："
  },
  {
    "head": "事务",
    "relation": "核心特性",
    "tail": "操作都是原子性",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "核心特性",
    "tail": "丰富的特性",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "可用于",
    "tail": "缓存",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "按key设置过期时间",
    "source_topic": "题目："
  },
  {
    "head": "Redis",
    "relation": "支持",
    "tail": "过期后自动删除",
    "source_topic": "题目："
  },
  {
    "head": "Hive",
    "relation": "存储数据",
    "tail": "气象观测站数据",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "气象局API",
    "relation": "限制",
    "tail": "单个观测点查询",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "Shell",
    "relation": "调用",
    "tail": "API",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "Python",
    "relation": "调用",
    "tail": "API",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "DataX",
    "relation": "包含",
    "tail": "HTTPReader插件",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "DataX",
    "relation": "包含",
    "tail": "HDFSWriter插件",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "计算引擎",
    "relation": "支持",
    "tail": "UDF",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "UDF",
    "relation": "调用",
    "tail": "API",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "计算引擎",
    "relation": "提供",
    "tail": "分布式框架",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "分布式框架",
    "relation": "提供",
    "tail": "容错",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "分布式框架",
    "relation": "提供",
    "tail": "并发",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "Hive",
    "relation": "存储数据",
    "tail": "查询结果",
    "source_topic": "题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"
  },
  {
    "head": "深复制",
    "relation": "实现方式",
    "tail": "递归复制",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "深复制",
    "relation": "处理对象",
    "tail": "对象类型",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "深复制",
    "relation": "处理对象",
    "tail": "数组类型",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "深复制",
    "relation": "使用方法",
    "tail": "Reflect.get",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "深复制",
    "relation": "使用方法",
    "tail": "Object.assign",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "深复制",
    "relation": "判断对象",
    "tail": "isObject函数",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "深复制",
    "relation": "判断对象",
    "tail": "isArray函数",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "深复制",
    "relation": "适用场景",
    "tail": "处理嵌套对象和数组",
    "source_topic": "题目：浅复制和深复制？怎样实现深复制？"
  },
  {
    "head": "constructor函数",
    "relation": "不能声明为",
    "tail": "虚函数",
    "source_topic": "题目：什么函数不能声明为虚函数？"
  },
  {
    "head": "文档",
    "relation": "属于",
    "tail": "动态模式",
    "source_topic": "题目：什么是文档"
  },
  {
    "head": "文档",
    "relation": "组成",
    "tail": "key value",
    "source_topic": "题目：什么是文档"
  },
  {
    "head": "文档",
    "relation": "对应",
    "tail": "关系型数据库表中的记录",
    "source_topic": "题目：什么是文档"
  },
  {
    "head": "MongoDB",
    "relation": "包含",
    "tail": "文档",
    "source_topic": "题目：什么是文档"
  },
  {
    "head": "mongod",
    "relation": "属于",
    "tail": "MongoDB进程",
    "source_topic": "题目：什么是”mongod“"
  },
  {
    "head": "ZAB协议",
    "relation": "包含",
    "tail": "恢复模式",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB协议",
    "relation": "包含",
    "tail": "广播模式",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB",
    "relation": "核心特性",
    "tail": "崩溃可恢复的原子消息广播算法",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZooKeeper",
    "relation": "采用",
    "tail": "ZAB协议",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB",
    "relation": "作用",
    "tail": "保证事务的完整性和顺序性",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB",
    "relation": "解决",
    "tail": "集群中多个服务器状态变更不一致",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB",
    "relation": "进入",
    "tail": "恢复模式",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "恢复模式",
    "relation": "触发条件",
    "tail": "服务启动或Leader崩溃",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB",
    "relation": "进入",
    "tail": "广播模式",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB",
    "relation": "保证",
    "tail": "事务的完整性",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "ZAB",
    "relation": "保证",
    "tail": "事务的顺序性",
    "source_topic": "题目：zk中zab的工作原理"
  },
  {
    "head": "并行计算",
    "relation": "分类",
    "tail": "分布式内存模式",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "并行计算",
    "relation": "分类",
    "tail": "共享内存模式",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "分布式内存模式",
    "relation": "实现",
    "tail": "MPI",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存模式",
    "relation": "实现",
    "tail": "OpenMP",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "MPI",
    "relation": "实现",
    "tail": "N个处理器对M个变量的求和",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "OpenMP",
    "relation": "实现",
    "tail": "N个处理器对M个变量的求和",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "SIMD",
    "relation": "实现",
    "tail": "单指令多数据",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "SIMD指令",
    "relation": "限制",
    "tail": "数组长度",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "SIMD指令",
    "relation": "限制",
    "tail": "cache line利用",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "SIMD指令",
    "relation": "限制",
    "tail": "内部循环依赖",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "SIMD指令",
    "relation": "限制",
    "tail": "条件调用",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "向量化优化",
    "relation": "手段",
    "tail": "SSE指令",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "向量化优化",
    "relation": "手段",
    "tail": "AVX指令",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "向量化优化",
    "relation": "手段",
    "tail": "编译器优化",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "Amdahl定律",
    "relation": "定义",
    "tail": "并行效率",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "Amdahl定律",
    "relation": "定义",
    "tail": "并行算法的扩展性",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "扩展性",
    "relation": "性能指标",
    "tail": "实测HPL和峰值HPL比率",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "扩展性",
    "relation": "性能指标",
    "tail": "并行效率随处理器数目的变化关系",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "扩展性",
    "relation": "限制因素",
    "tail": "串行部分的天花板效应",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存计算机",
    "relation": "限制",
    "tail": "内存一致性",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存计算机",
    "relation": "限制",
    "tail": "NUMA架构",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "OpenMP",
    "relation": "实现",
    "tail": "共享内存编程环境",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "OpenMP",
    "relation": "核心特性",
    "tail": "private参数",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "MPI",
    "relation": "核心特性",
    "tail": "阻塞读写",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "MPI",
    "relation": "核心特性",
    "tail": "非阻塞读写",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存编程",
    "relation": "分类",
    "tail": "EREW模型",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存编程",
    "relation": "分类",
    "tail": "CREW模型",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存编程",
    "relation": "分类",
    "tail": "ERCW模型",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存编程",
    "relation": "分类",
    "tail": "CRCW模型",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "MPI",
    "relation": "核心函数",
    "tail": "MPI_Init",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "MPI",
    "relation": "核心函数",
    "tail": "MPI_Comm_rank",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "MPI",
    "relation": "核心函数",
    "tail": "MPI_Comm_size",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "MPI",
    "relation": "核心函数",
    "tail": "MPI_Reduce",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "共享内存",
    "relation": "实现",
    "tail": "OpenMP",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "分布式内存",
    "relation": "实现",
    "tail": "MPI",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "NUMA",
    "relation": "解决",
    "tail": "内存一致性问题",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "内存一致性",
    "relation": "导致",
    "tail": "共享内存限制",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "并行计算",
    "relation": "包含",
    "tail": "进程级并行",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "并行计算",
    "relation": "包含",
    "tail": "线程级并行",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "并行计算",
    "relation": "包含",
    "tail": "指令级并行",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "进程级并行",
    "relation": "实现",
    "tail": "分布式内存",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "线程级并行",
    "relation": "实现",
    "tail": "共享内存",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "指令级并行",
    "relation": "实现",
    "tail": "SIMD指令",
    "source_topic": "题目： 关于并行计算的一些基础开放问题。"
  },
  {
    "head": "SQL语句优化",
    "relation": "包含",
    "tail": "避免使用!=或<>操作符",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "避免使用!=或<>操作符",
    "relation": "导致",
    "tail": "引擎放弃使用索引而进行全表扫描",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "SQL语句优化",
    "relation": "包含",
    "tail": "使用exists代替in",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "索引优化",
    "relation": "包含",
    "tail": "查看上文索引",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "数据库结构优化",
    "relation": "包含",
    "tail": "范式优化",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "范式优化",
    "relation": "解决",
    "tail": "消除冗余",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "范式优化",
    "relation": "目标",
    "tail": "节省空间",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "数据库结构优化",
    "relation": "包含",
    "tail": "反范式优化",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "反范式优化",
    "relation": "解决",
    "tail": "减少join",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "反范式优化",
    "relation": "包含",
    "tail": "适当加冗余",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "数据库结构优化",
    "relation": "包含",
    "tail": "拆分表",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "拆分表",
    "relation": "解决",
    "tail": "数据量大的时时表压力",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "拆分表",
    "relation": "包含",
    "tail": "分区",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "分区",
    "relation": "解决",
    "tail": "全表扫描",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "分区",
    "relation": "包含",
    "tail": "物理上分隔数据",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "分区",
    "relation": "包含",
    "tail": "分散磁盘I/O竞争",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "拆分表",
    "relation": "包含",
    "tail": "垂直拆分",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "垂直拆分",
    "relation": "解决",
    "tail": "表与表之间的io竞争",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "垂直拆分",
    "relation": "不解决",
    "tail": "单表中数据量增长出现的压力",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "拆分表",
    "relation": "包含",
    "tail": "水平拆分",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "水平拆分",
    "relation": "解决",
    "tail": "单表中数据量增长出现的压力",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "水平拆分",
    "relation": "不解决",
    "tail": "表与表之间的io竞争",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "水平拆分",
    "relation": "包含",
    "tail": "女用户表放一个server上",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "服务器硬件优化",
    "relation": "包含",
    "tail": "增加服务器硬件资源",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "服务器硬件优化",
    "relation": "导致",
    "tail": "需要花费更多资金",
    "source_topic": "题目：数据库优化的思路"
  },
  {
    "head": "MongoDB",
    "relation": "包含",
    "tail": "show dbs命令",
    "source_topic": "题目：在MongoDB中如何查看数据库列表"
  },
  {
    "head": "二分法",
    "relation": "属于",
    "tail": "基础算法",
    "source_topic": "* 考察点"
  },
  {
    "head": "牛顿迭代法",
    "relation": "属于",
    "tail": "数值计算算法",
    "source_topic": "* 考察点"
  },
  {
    "head": "退出条件设计",
    "relation": "属于",
    "tail": "算法设计考量",
    "source_topic": "* 考察点"
  },
  {
    "head": "MOV指令",
    "relation": "执行消耗",
    "tail": "时钟周期",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "MOV指令执行数量",
    "relation": "依赖",
    "tail": "CPU主频",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "MOV指令执行数量",
    "relation": "依赖",
    "tail": "IPC",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "IPC",
    "relation": "影响因素",
    "tail": "数据预取",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "IPC",
    "relation": "影响因素",
    "tail": "乱序执行",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "IPC",
    "relation": "影响因素",
    "tail": "多发射",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "IPC",
    "relation": "影响因素",
    "tail": "内存stall",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "内存stall",
    "relation": "包含",
    "tail": "前端stall",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "内存stall",
    "relation": "包含",
    "tail": "后端stall",
    "source_topic": "题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？"
  },
  {
    "head": "分片",
    "relation": "属于",
    "tail": "MongoDB",
    "source_topic": "题目：MongoDB中的分片是什么意思"
  },
  {
    "head": "分片",
    "relation": "解决",
    "tail": "单台机器存储数据不足",
    "source_topic": "题目：MongoDB中的分片是什么意思"
  },
  {
    "head": "分片",
    "relation": "解决",
    "tail": "单台机器读写吞吐量不足",
    "source_topic": "题目：MongoDB中的分片是什么意思"
  },
  {
    "head": "分片",
    "relation": "实现方式",
    "tail": "水平切分数据到物理节点",
    "source_topic": "题目：MongoDB中的分片是什么意思"
  },
  {
    "head": "queue.take()",
    "relation": "导致",
    "tail": "阻塞",
    "source_topic": "题目：请评估一下程序的执行结果？"
  },
  {
    "head": "冒泡排序算法",
    "relation": "时间复杂度",
    "tail": "O(n^2)",
    "source_topic": "题目： 冒泡排序算法的时间复杂度是什么？"
  },
  {
    "head": "数据库事务",
    "relation": "核心特性",
    "tail": "原子性",
    "source_topic": "题目：数据库事务的四个特性及含义"
  },
  {
    "head": "数据库事务",
    "relation": "核心特性",
    "tail": "一致性",
    "source_topic": "题目：数据库事务的四个特性及含义"
  },
  {
    "head": "数据库事务",
    "relation": "核心特性",
    "tail": "隔离性",
    "source_topic": "题目：数据库事务的四个特性及含义"
  },
  {
    "head": "数据库事务",
    "relation": "核心特性",
    "tail": "持久性",
    "source_topic": "题目：数据库事务的四个特性及含义"
  },
  {
    "head": "数据库事务",
    "relation": "简称",
    "tail": "ACID",
    "source_topic": "题目：数据库事务的四个特性及含义"
  },
  {
    "head": "原子性",
    "relation": "实现方式",
    "tail": "回滚（Rollback）",
    "source_topic": "题目：数据库事务的四个特性及含义"
  },
  {
    "head": "全局变量",
    "relation": "存储位置",
    "tail": "静态存储区",
    "source_topic": "题目：全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"
  },
  {
    "head": "局部变量",
    "relation": "存储位置",
    "tail": "堆栈",
    "source_topic": "题目：全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"
  },
  {
    "head": "SQL",
    "relation": "包含",
    "tail": "left join",
    "source_topic": "题目：解释 SQL 的 left join 和 right join"
  },
  {
    "head": "SQL",
    "relation": "包含",
    "tail": "right join",
    "source_topic": "题目：解释 SQL 的 left join 和 right join"
  },
  {
    "head": "left join",
    "relation": "操作方式",
    "tail": "将右边的表 merge 到左边",
    "source_topic": "题目：解释 SQL 的 left join 和 right join"
  },
  {
    "head": "right join",
    "relation": "操作方式",
    "tail": "将左边的表 merge 到右边",
    "source_topic": "题目：解释 SQL 的 left join 和 right join"
  },
  {
    "head": "left join",
    "relation": "依赖",
    "tail": "指定 merge 列",
    "source_topic": "题目：解释 SQL 的 left join 和 right join"
  },
  {
    "head": "right join",
    "relation": "依赖",
    "tail": "指定 merge 列",
    "source_topic": "题目：解释 SQL 的 left join 和 right join"
  },
  {
    "head": "ZooKeeper",
    "relation": "提供",
    "tail": "命名服务",
    "source_topic": "题目： zk的命名服务"
  },
  {
    "head": "命名服务",
    "relation": "实现方式",
    "tail": "创建全局路径",
    "source_topic": "题目： zk的命名服务"
  },
  {
    "head": "全局路径",
    "relation": "特性",
    "tail": "唯一性",
    "source_topic": "题目： zk的命名服务"
  },
  {
    "head": "全局路径",
    "relation": "指向",
    "tail": "集群地址",
    "source_topic": "题目： zk的命名服务"
  },
  {
    "head": "全局路径",
    "relation": "指向",
    "tail": "服务地址",
    "source_topic": "题目： zk的命名服务"
  },
  {
    "head": "全局路径",
    "relation": "指向",
    "tail": "远程对象",
    "source_topic": "题目： zk的命名服务"
  },
  {
    "head": "第一范式",
    "relation": "属于",
    "tail": "数据库范式",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第一范式",
    "relation": "要求",
    "tail": "同一列中不能有多个值",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第一范式",
    "relation": "解决",
    "tail": "重复的属性",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第一范式",
    "relation": "定义",
    "tail": "无重复的列",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第二范式",
    "relation": "属于",
    "tail": "数据库范式",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第二范式",
    "relation": "要求",
    "tail": "实体的属性完全依赖于主关键字",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第二范式",
    "relation": "解决",
    "tail": "仅依赖主关键字一部分的属性",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第二范式",
    "relation": "定义",
    "tail": "非主属性非部分依赖于主关键字",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第三范式",
    "relation": "属于",
    "tail": "数据库范式",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第三范式",
    "relation": "解决",
    "tail": "数据冗余",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第三范式",
    "relation": "定义",
    "tail": "属性不依赖于其它非主属性",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第二范式",
    "relation": "前提",
    "tail": "第一范式",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "第三范式",
    "relation": "前提",
    "tail": "第二范式",
    "source_topic": "题目：数据库范式"
  },
  {
    "head": "Proxy",
    "relation": "用于",
    "tail": "监听数组元素变化",
    "source_topic": "题目： 找出被修改过的数字"
  },
  {
    "head": "Reflect.set",
    "relation": "用于",
    "tail": "存储修改后的数值和次数",
    "source_topic": "题目： 找出被修改过的数字"
  },
  {
    "head": "saveModifyNum",
    "relation": "存储",
    "tail": "被修改的数字及其修改次数",
    "source_topic": "题目： 找出被修改过的数字"
  },
  {
    "head": "set",
    "relation": "属于",
    "tail": "Proxy的拦截方法",
    "source_topic": "题目： 找出被修改过的数字"
  },
  {
    "head": "Reflect.get",
    "relation": "用于",
    "tail": "获取保存的修改信息",
    "source_topic": "题目： 找出被修改过的数字"
  },
  {
    "head": "外连接",
    "relation": "分类",
    "tail": "左连接",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "外连接",
    "relation": "分类",
    "tail": "右连接",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "外连接",
    "relation": "分类",
    "tail": "完整外部联接",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "左连接",
    "relation": "实现方式",
    "tail": "left join",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "左连接",
    "relation": "实现方式",
    "tail": "left outer join",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "左连接",
    "relation": "结果特性",
    "tail": "包含左表所有行",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "左连接",
    "relation": "结果特性",
    "tail": "右表未匹配行显示为NULL",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "右连接",
    "relation": "实现方式",
    "tail": "right join",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "右连接",
    "relation": "结果特性",
    "tail": "包含右表所有行",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "右连接",
    "relation": "结果特性",
    "tail": "左表未匹配行显示为NULL",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "完整外部联接",
    "relation": "实现方式",
    "tail": "full join",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "完整外部联接",
    "relation": "实现方式",
    "tail": "full outer join",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "完整外部联接",
    "relation": "结果特性",
    "tail": "包含左表和右表所有行",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "完整外部联接",
    "relation": "结果特性",
    "tail": "未匹配行显示为NULL",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "内连接",
    "relation": "分类",
    "tail": "join",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "内连接",
    "relation": "分类",
    "tail": "inner join",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "内连接",
    "relation": "结果特性",
    "tail": "仅包含匹配行",
    "source_topic": "题目：连接的种类"
  },
  {
    "head": "ZooKeeper",
    "relation": "提供",
    "tail": "文件系统",
    "source_topic": "题目：zookeeper提供了什么？"
  },
  {
    "head": "ZooKeeper",
    "relation": "提供",
    "tail": "通知机制",
    "source_topic": "题目：zookeeper提供了什么？"
  },
  {
    "head": "Zookeeper",
    "relation": "包含",
    "tail": "同步流程",
    "source_topic": "题目：zookeeper同步流程"
  },
  {
    "head": "同步流程",
    "relation": "步骤",
    "tail": "Follower接受客户端请求",
    "source_topic": "题目：zookeeper同步流程"
  },
  {
    "head": "Zookeeper",
    "relation": "包含",
    "tail": "SNAP-全量同步",
    "source_topic": "题目：zookeeper同步流程"
  },
  {
    "head": "数组",
    "relation": "使用",
    "tail": "Object对象",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "Object对象",
    "relation": "存储",
    "tail": "元素出现次数",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "遍历数组",
    "relation": "实现",
    "tail": "reduce方法",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "reduce方法",
    "relation": "处理",
    "tail": "当前元素",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "当前元素",
    "relation": "更新",
    "tail": "Object对象",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "Object对象",
    "relation": "记录",
    "tail": "最大出现次数",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "最大出现次数",
    "relation": "比较",
    "tail": "当前元素出现次数",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "数组",
    "relation": "满足条件",
    "tail": "某个数出现次数超过一半",
    "source_topic": "题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"
  },
  {
    "head": "drop",
    "relation": "删除内容",
    "tail": "整个表的结构和数据",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "删除内容",
    "tail": "表中的数据",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "删除内容",
    "tail": "表中的数据",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "支持条件",
    "tail": "where字句",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "支持条件",
    "tail": "无where字句",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "影响对象",
    "tail": "表结构、约束、触发器、索引",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "影响对象",
    "tail": "表和视图",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "操作类型",
    "tail": "DML",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "操作类型",
    "tail": "DDL",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "操作类型",
    "tail": "DDL",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "日志记录",
    "tail": "事务日志中记录每一行的删除操作",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "日志记录",
    "tail": "事务日志中仅记录页的释放",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "日志记录",
    "tail": "不记录事务日志",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "回滚支持",
    "tail": "支持回滚",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "回滚支持",
    "tail": "不支持回滚",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "回滚支持",
    "tail": "不支持回滚",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "触发器激活",
    "tail": "激活触发器",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "触发器激活",
    "tail": "不激活触发器",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "触发器激活",
    "tail": "不激活触发器",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "空间释放",
    "tail": "不减少表或索引所占空间",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "空间释放",
    "tail": "释放表和索引所占空间到初始大小",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "空间释放",
    "tail": "释放整个表所占空间",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "效率",
    "tail": "比delete高",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "效率",
    "tail": "比truncate低",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "重置标识",
    "tail": "将自增长id的计数值重置为种子",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "重置标识",
    "tail": "不重置自增长id的计数值",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "保留对象",
    "tail": "不保留表结构",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "保留对象",
    "tail": "保留表结构",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "保留对象",
    "tail": "保留表结构",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "事务处理",
    "tail": "属于事务操作",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "事务处理",
    "tail": "不属于事务操作",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "事务处理",
    "tail": "不属于事务操作",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "触发器支持",
    "tail": "支持触发器",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "触发器支持",
    "tail": "不支持触发器",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "drop",
    "relation": "触发器支持",
    "tail": "不支持触发器",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "truncate",
    "relation": "外键约束",
    "tail": "不能用于有外键约束引用的表",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "delete",
    "relation": "外键约束",
    "tail": "可以用于有外键约束引用的表",
    "source_topic": "题目：drop,delete与truncate的区别"
  },
  {
    "head": "Server",
    "relation": "具有",
    "tail": "LOOKING状态",
    "source_topic": "题目：zk集群下server工作状态"
  },
  {
    "head": "Server",
    "relation": "具有",
    "tail": "LEADING状态",
    "source_topic": "题目：zk集群下server工作状态"
  },
  {
    "head": "Server",
    "relation": "具有",
    "tail": "FOLLOWING状态",
    "source_topic": "题目：zk集群下server工作状态"
  },
  {
    "head": "Server",
    "relation": "具有",
    "tail": "OBSERVING状态",
    "source_topic": "题目：zk集群下server工作状态"
  },
  {
    "head": "LEADING状态",
    "relation": "表示",
    "tail": "Server角色为leader",
    "source_topic": "题目：zk集群下server工作状态"
  },
  {
    "head": "MongoDB",
    "relation": "属于",
    "tail": "文档数据库",
    "source_topic": "题目：什么是MongoDB"
  },
  {
    "head": "MongoDB",
    "relation": "采用",
    "tail": "BSON存储文档数据",
    "source_topic": "题目：什么是MongoDB"
  },
  {
    "head": "MongoDB",
    "relation": "由",
    "tail": "10gen团队",
    "source_topic": "题目：什么是MongoDB"
  },
  {
    "head": "MongoDB",
    "relation": "首度推出时间",
    "tail": "2009年2月",
    "source_topic": "题目：什么是MongoDB"
  },
  {
    "head": "MongoDB",
    "relation": "官网网址",
    "tail": "www.mongodb.com",
    "source_topic": "题目：什么是MongoDB"
  },
  {
    "head": "Redis主从复制",
    "relation": "建议避免",
    "tail": "Master持久化工作",
    "source_topic": "题目：redis常见性能问题和解决方案"
  },
  {
    "head": "Redis主从复制",
    "relation": "推荐方案",
    "tail": "Slave开启AOF备份",
    "source_topic": "题目：redis常见性能问题和解决方案"
  },
  {
    "head": "Slave AOF备份",
    "relation": "同步策略",
    "tail": "每秒同步一次",
    "source_topic": "题目：redis常见性能问题和解决方案"
  },
  {
    "head": "Redis主从复制",
    "relation": "建议避免",
    "tail": "在压力大的主库增加从库",
    "source_topic": "题目：redis常见性能问题和解决方案"
  },
  {
    "head": "Redis主从复制",
    "relation": "建议结构",
    "tail": "单向链表结构",
    "source_topic": "题目：redis常见性能问题和解决方案"
  },
  {
    "head": "单向链表结构",
    "relation": "优势",
    "tail": "解决单点故障",
    "source_topic": "题目：redis常见性能问题和解决方案"
  },
  {
    "head": "mongo",
    "relation": "属于",
    "tail": "命令行工具",
    "source_topic": "题目：什么是\"mongo\""
  },
  {
    "head": "mongo",
    "relation": "用于连接",
    "tail": "mongod实例",
    "source_topic": "题目：什么是\"mongo\""
  },
  {
    "head": "mongo",
    "relation": "默认连接",
    "tail": "localhost",
    "source_topic": "题目：什么是\"mongo\""
  },
  {
    "head": "mongo",
    "relation": "默认使用",
    "tail": "默认端口号",
    "source_topic": "题目：什么是\"mongo\""
  },
  {
    "head": "非关系型数据库",
    "relation": "属于",
    "tail": "数据库",
    "source_topic": "题目：什么是非关系型数据库"
  },
  {
    "head": "非关系型数据库",
    "relation": "不使用",
    "tail": "SQL",
    "source_topic": "题目：什么是非关系型数据库"
  },
  {
    "head": "非关系型数据库",
    "relation": "不需要",
    "tail": "表格模式",
    "source_topic": "题目：什么是非关系型数据库"
  },
  {
    "head": "非关系型数据库",
    "relation": "具有",
    "tail": "简单的设计",
    "source_topic": "题目：什么是非关系型数据库"
  },
  {
    "head": "非关系型数据库",
    "relation": "具有",
    "tail": "非常好的性能",
    "source_topic": "题目：什么是非关系型数据库"
  },
  {
    "head": "非关系型数据库",
    "relation": "用于",
    "tail": "大数据",
    "source_topic": "题目：什么是非关系型数据库"
  },
  {
    "head": "非关系型数据库",
    "relation": "用于",
    "tail": "Web Apps",
    "source_topic": "题目：什么是非关系型数据库"
  },
  {
    "head": "堆栈溢出",
    "relation": "导致",
    "tail": "没有回收垃圾资源",
    "source_topic": "题目：堆栈溢出一般是由什么原因导致的？"
  },
  {
    "head": "Zookeeper",
    "relation": "采用",
    "tail": "递增的事务Id",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "事务Id",
    "relation": "标识",
    "tail": "proposal",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "zxid",
    "relation": "是",
    "tail": "64位的数字",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "zxid",
    "relation": "包含",
    "tail": "高32位的epoch",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "epoch",
    "relation": "用于标识",
    "tail": "leader是否发生改变",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "zxid",
    "relation": "包含",
    "tail": "低32位的递增计数",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "Zookeeper",
    "relation": "基于",
    "tail": "数据库的两阶段过程",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "两阶段过程",
    "relation": "用于",
    "tail": "事务执行请求",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "事务执行请求",
    "relation": "需要",
    "tail": "超过半数的机器执行并成功",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "Zookeeper",
    "relation": "保证",
    "tail": "事务的顺序一致性",
    "source_topic": "题目：zookeeper是如何保证事务的顺序一致性的？"
  },
  {
    "head": "单字段索引",
    "relation": "字段",
    "tail": "age",
    "source_topic": "单字段索引"
  },
  {
    "head": "升序索引",
    "relation": "表示方式",
    "tail": "{age: 1}",
    "source_topic": "单字段索引"
  },
  {
    "head": "降序索引",
    "relation": "表示方式",
    "tail": "{age: -1}",
    "source_topic": "单字段索引"
  },
  {
    "head": "单字段索引",
    "relation": "效果",
    "tail": "升序/降序效果一样",
    "source_topic": "单字段索引"
  },
  {
    "head": "复合索引",
    "relation": "升级关系",
    "tail": "单字段索引",
    "source_topic": "单字段索引"
  },
  {
    "head": "复合索引",
    "relation": "字段",
    "tail": "age",
    "source_topic": "单字段索引"
  },
  {
    "head": "复合索引",
    "relation": "字段",
    "tail": "name",
    "source_topic": "单字段索引"
  },
  {
    "head": "复合索引",
    "relation": "排序方式",
    "tail": "按第一个字段排序",
    "source_topic": "单字段索引"
  },
  {
    "head": "多key索引",
    "relation": "属于",
    "tail": "索引类型",
    "source_topic": "多key索引"
  },
  {
    "head": "多key索引",
    "relation": "创建条件",
    "tail": "字段为数组",
    "source_topic": "多key索引"
  },
  {
    "head": "多key索引",
    "relation": "功能",
    "tail": "为数组的每个元素建立一条索引",
    "source_topic": "多key索引"
  },
  {
    "head": "MongoDB",
    "relation": "支持",
    "tail": "多key索引",
    "source_topic": "多key索引"
  },
  {
    "head": "db.person.find",
    "relation": "利用",
    "tail": "多key索引",
    "source_topic": "多key索引"
  },
  {
    "head": "MongoDB",
    "relation": "底层实现语言",
    "tail": "C++",
    "source_topic": "题目：MongoDB是由哪种语言写的"
  },
  {
    "head": "MySQL",
    "relation": "底层实现语言",
    "tail": "C++",
    "source_topic": "题目：MongoDB是由哪种语言写的"
  },
  {
    "head": "C++",
    "relation": "发行时间",
    "tail": "1983年",
    "source_topic": "题目：MongoDB是由哪种语言写的"
  },
  {
    "head": "C++",
    "relation": "分类",
    "tail": "通用程序设计语言",
    "source_topic": "题目：MongoDB是由哪种语言写的"
  },
  {
    "head": "C++",
    "relation": "支持",
    "tail": "多重编程模式",
    "source_topic": "题目：MongoDB是由哪种语言写的"
  },
  {
    "head": "微博系统",
    "relation": "导致",
    "tail": "系统崩溃",
    "source_topic": "题目：请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"
  },
  {
    "head": "流量明星发微博",
    "relation": "需要区分对待",
    "tail": "普通用户发微博",
    "source_topic": "题目：请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"
  },
  {
    "head": "Sharding",
    "relation": "需要考虑",
    "tail": "流量明星发微博",
    "source_topic": "题目：请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"
  },
  {
    "head": "ping IP",
    "relation": "触发",
    "tail": "查路由表",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "查路由表",
    "relation": "确定",
    "tail": "出接口",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "出接口",
    "relation": "属于",
    "tail": "直连接口子网",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "直连接口子网",
    "relation": "使用",
    "tail": "以太网",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "以太网",
    "relation": "分类",
    "tail": "多路访问网络",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "多路访问网络",
    "relation": "需要查询",
    "tail": "arp缓存",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "arp缓存",
    "relation": "命中",
    "tail": "直接发出",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "arp缓存",
    "relation": "未命中",
    "tail": "发arp询问",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "发arp询问",
    "relation": "获取",
    "tail": "目标ip的mac地址",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "出接口",
    "relation": "属于",
    "tail": "ppp",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "ppp",
    "relation": "分类",
    "tail": "点对点网络",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "点对点网络",
    "relation": "直接",
    "tail": "发出",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "查路由表",
    "relation": "确定",
    "tail": "缺省路由",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "缺省路由",
    "relation": "使用",
    "tail": "以太网",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "以太网",
    "relation": "分类",
    "tail": "多路访问网络",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "多路访问网络",
    "relation": "需要查询",
    "tail": "网关arp缓存",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "网关arp缓存",
    "relation": "命中",
    "tail": "直接发出",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "网关arp缓存",
    "relation": "未命中",
    "tail": "发arp询问",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "发arp询问",
    "relation": "获取",
    "tail": "网关的mac地址",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "查路由表",
    "relation": "未命中",
    "tail": "返回不可达",
    "source_topic": "题目：输入 ping IP 后敲回车，发包前会发生什么？"
  },
  {
    "head": "数据库索引",
    "relation": "属于",
    "tail": "排序的数据结构",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "数据库索引",
    "relation": "实现方式",
    "tail": "B树",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "数据库索引",
    "relation": "实现方式",
    "tail": "B+树",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "数据库索引",
    "relation": "作用",
    "tail": "协助快速查询数据库表中数据",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "数据库索引",
    "relation": "作用",
    "tail": "协助快速更新数据库表中数据",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "数据库索引",
    "relation": "代价",
    "tail": "增加数据库存储空间",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "数据库索引",
    "relation": "代价",
    "tail": "插入和修改数据时花费更多时间",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "二叉查找树",
    "relation": "用于",
    "tail": "加快Col2的查找",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "二叉查找树",
    "relation": "包含",
    "tail": "索引键值",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "二叉查找树",
    "relation": "包含",
    "tail": "指向数据记录物理地址的指针",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "创建索引",
    "relation": "提高性能",
    "tail": "数据检索速度",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "创建索引",
    "relation": "提高性能",
    "tail": "表和表之间的连接",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "创建索引",
    "relation": "提高性能",
    "tail": "分组和排序子句的查询",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "创建索引",
    "relation": "提高性能",
    "tail": "查询优化隐藏器",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "创建索引",
    "relation": "保证",
    "tail": "数据库表中每一行数据的唯一性",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "唯一索引",
    "relation": "特性",
    "tail": "不允许任何两行具有相同索引值",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "主键索引",
    "relation": "属于",
    "tail": "唯一索引的特定类型",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "主键索引",
    "relation": "作用",
    "tail": "唯一标识表中的每一行",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "聚集索引",
    "relation": "限制",
    "tail": "一个表只能包含一个",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "局部性原理",
    "relation": "与",
    "tail": "磁盘预读",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "磁盘预读",
    "relation": "基于",
    "tail": "存储介质的特性",
    "source_topic": "题目：索引的工作原理及其种类"
  },
  {
    "head": "FreqStack",
    "relation": "实现",
    "tail": "栈数据结构",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "push(int x)",
    "relation": "属于",
    "tail": "FreqStack函数",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "pop()",
    "relation": "属于",
    "tail": "FreqStack函数",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "freq",
    "relation": "是",
    "tail": "HashMap",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "group",
    "relation": "是",
    "tail": "Map",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "maxfreq",
    "relation": "是",
    "tail": "整数",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "group",
    "relation": "映射",
    "tail": "频率到元素的集合",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "freq",
    "relation": "记录",
    "tail": "元素的出现次数",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "maxfreq",
    "relation": "表示",
    "tail": "栈中元素的最大频率",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "group",
    "relation": "使用",
    "tail": "栈来存储相同频率的元素",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "push(int x)",
    "relation": "增加",
    "tail": "元素x的频率",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "pop()",
    "relation": "移除并返回",
    "tail": "出现最频繁的元素",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "pop()",
    "relation": "处理",
    "tail": "相同频率元素的最新性",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "group",
    "relation": "存储",
    "tail": "频率对应的元素栈",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "HashMap",
    "relation": "实现",
    "tail": "元素频率的映射",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "Stack",
    "relation": "属于",
    "tail": "Java集合框架",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "maxfreq--",
    "relation": "执行",
    "tail": "当频率栈为空时减少最大频率",
    "source_topic": "题目：最大频率栈。"
  },
  {
    "head": "浮点数相加",
    "relation": "导致",
    "tail": "精度丢失",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "JavaScript",
    "relation": "涉及",
    "tail": "浮点数运算",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "浮点数运算",
    "relation": "存在",
    "tail": "精度丢失问题",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "精度丢失问题",
    "relation": "解决",
    "tail": "转为整数运算",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "转为整数运算",
    "relation": "方法",
    "tail": "字符串转换",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "字符串转换",
    "relation": "涉及",
    "tail": "乘以100",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "乘以100",
    "relation": "可能导致",
    "tail": "浮点数运算",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "浮点数运算",
    "relation": "导致",
    "tail": "精度丢失",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "字符串转换",
    "relation": "涉及",
    "tail": "除以100",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "除以100",
    "relation": "可能导致",
    "tail": "浮点数运算",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "浮点数运算",
    "relation": "导致",
    "tail": "精度丢失",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "字符串转整数",
    "relation": "需要考虑",
    "tail": "小数点对齐",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "toFixed(2)",
    "relation": "可能导致",
    "tail": "小数点对齐错误",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "大数计算",
    "relation": "涉及",
    "tail": "循环遍历",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "大数计算",
    "relation": "涉及",
    "tail": "算法复杂度优化",
    "source_topic": "题目：如何实现两金额数据相加（最多小数点两位）？"
  },
  {
    "head": "Zookeeper",
    "relation": "实现",
    "tail": "通知机制",
    "source_topic": "题目：zookeeper通知机制"
  },
  {
    "head": "Client端",
    "relation": "建立",
    "tail": "Watcher事件",
    "source_topic": "题目：zookeeper通知机制"
  },
  {
    "head": "Znode",
    "relation": "触发",
    "tail": "Watcher事件",
    "source_topic": "题目：zookeeper通知机制"
  },
  {
    "head": "Zookeeper",
    "relation": "通知",
    "tail": "Client端",
    "source_topic": "题目：zookeeper通知机制"
  },
  {
    "head": "Watcher",
    "relation": "核心特性",
    "tail": "轻量级",
    "source_topic": "watcher的特点："
  },
  {
    "head": "Watcher",
    "relation": "核心特性",
    "tail": "异步性",
    "source_topic": "watcher的特点："
  },
  {
    "head": "Watcher",
    "relation": "核心特性",
    "tail": "主动推送",
    "source_topic": "watcher的特点："
  },
  {
    "head": "Watcher",
    "relation": "核心特性",
    "tail": "一次性",
    "source_topic": "watcher的特点："
  },
  {
    "head": "Watcher",
    "relation": "核心特性",
    "tail": "仅通知",
    "source_topic": "watcher的特点："
  },
  {
    "head": "Watcher",
    "relation": "核心特性",
    "tail": "顺序性",
    "source_topic": "watcher的特点："
  },
  {
    "head": "watcher",
    "relation": "导致",
    "tail": "性能下降",
    "source_topic": "使用watch的注意事项："
  },
  {
    "head": "watcher",
    "relation": "需要实现",
    "tail": "永久watch",
    "source_topic": "使用watch的注意事项："
  },
  {
    "head": "watcher",
    "relation": "导致",
    "tail": "丢数据",
    "source_topic": "使用watch的注意事项："
  },
  {
    "head": "InnoDB索引",
    "relation": "导致",
    "tail": "索引树页数目增加",
    "source_topic": "题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？"
  },
  {
    "head": "索引树页数目增加",
    "relation": "导致",
    "tail": "索引层次增加",
    "source_topic": "题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？"
  },
  {
    "head": "索引层次增加",
    "relation": "影响",
    "tail": "查询变更效率",
    "source_topic": "题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？"
  },
  {
    "head": "InnoDB索引",
    "relation": "基于",
    "tail": "B+树结构",
    "source_topic": "题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？"
  },
  {
    "head": "B+树结构",
    "relation": "限制",
    "tail": "页中key数量",
    "source_topic": "题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？"
  },
  {
    "head": "Hadoop",
    "relation": "包含",
    "tail": "map端保存分片数据",
    "source_topic": "简单说一下hadoop和spark的shuffle过程"
  },
  {
    "head": "Hadoop",
    "relation": "包含",
    "tail": "通过网络收集到reduce端",
    "source_topic": "简单说一下hadoop和spark的shuffle过程"
  },
  {
    "head": "Stage",
    "relation": "属于",
    "tail": "Spark",
    "source_topic": "简单说一下hadoop和spark的shuffle过程"
  },
  {
    "head": "Redis Master",
    "relation": "导致",
    "tail": "服务暂停",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "save命令",
    "relation": "调度",
    "tail": "rdbSave函数",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "rdbSave函数",
    "relation": "阻塞",
    "tail": "主线程",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "AOF文件",
    "relation": "增大",
    "tail": "文件大小",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "AOF文件",
    "relation": "影响",
    "tail": "恢复速度",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "BGREWRITEAOF",
    "relation": "导致",
    "tail": "服务暂停",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "BGREWRITEAOF",
    "relation": "占用",
    "tail": "CPU资源",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "BGREWRITEAOF",
    "relation": "占用",
    "tail": "内存资源",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "主从复制",
    "relation": "影响",
    "tail": "连接稳定性",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "Slave",
    "relation": "建议",
    "tail": "与Master同局域网",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "Redis Master",
    "relation": "建议",
    "tail": "不启用内存快照",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "Redis Master",
    "relation": "建议",
    "tail": "不启用AOF持久化",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "Slave",
    "relation": "建议",
    "tail": "启用AOF备份",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  },
  {
    "head": "AOF持久化",
    "relation": "策略",
    "tail": "每秒同步一次",
    "source_topic": "题目：Redis 常见的性能问题都有哪些？如何解决？"
  }
]